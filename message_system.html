<!DOCTYPE html>
<html>
<head>
    <title>Tramona System Code Documentation</title>
    <style>
        body { font-family: monospace; max-width: 1200px; margin: 0 auto; padding: 20px; }
        .section { margin: 40px 0; }
        .section-title { font-size: 24px; color: #2563eb; margin: 20px 0; }
        .file { margin: 20px 0; padding: 20px; background: #f5f5f5; border-radius: 5px; }
        .file-name { font-weight: bold; color: #333; margin-bottom: 10px; }
        pre { background: #fff; padding: 15px; border-radius: 3px; overflow-x: auto; }
    </style>
</head>
<body>
    <h1>Tramona System Code Documentation</h1>
<div class='section'>
<h2 class='section-title'>Authentication & Authorization</h2>
<div class='file'>
<div class='file-name'>./src/server/api/trpc.ts</div>
<pre><code>
/**
 * YOU PROBABLY DON'T NEED TO EDIT THIS FILE, UNLESS:
 * 1. You want to modify request context (see Part 1).
 * 2. You want to create a new middleware or type of procedure (see Part 3).
 *
 * TL;DR - This is where all the tRPC server stuff is created and plugged in. The pieces you will
 * need to use are documented accordingly near the end.
 */

import { hostProfiles, type User, users } from "../db/schema";
import { initTRPC, TRPCError } from "@trpc/server";
import { type CreateNextContextOptions } from "@trpc/server/adapters/next";
import { type Session } from "next-auth";
import superjson from "superjson";
import { ZodError } from "zod";
import { getServerAuthSession } from "@/server/auth";
import { db } from "@/server/db";
import { eq } from "drizzle-orm";
import { s3 } from "../s3";

/**
 * 1. CONTEXT
 *
 * This section defines the "contexts" that are available in the backend API.
 *
 * These allow you to access things when processing a request, like the database, the session, etc.
 */

interface CreateContextOptions {
  session: Session | null;
}

/**
 * This helper generates the "internals" for a tRPC context. If you need to use it, you can export
 * it from here.
 *
 * Examples of things you may need it for:
 * - testing, so we don't have to mock Next.js' req/res
 * - tRPC's `createSSGHelpers`, where we don't have req/res
 *
 * @see https://create.t3.gg/en/usage/trpc#-serverapitrpcts
 */
const createInnerTRPCContext = (opts: CreateContextOptions) => {
  return {
    session: opts.session,
    db,
    s3,
  };
};

/**
 * This is the actual context you will use in your router. It will be used to process every request
 * that goes through your tRPC endpoint.
 *
 * @see https://trpc.io/docs/context
 */
export const createTRPCContext = async (opts: CreateNextContextOptions) => {
  const { req, res } = opts;

  // Get the session from the server using the getServerSession wrapper function
  const session = await getServerAuthSession({ req, res });

  return createInnerTRPCContext({
    session,
  });
};

/**
 * 2. INITIALIZATION
 *
 * This is where the tRPC API is initialized, connecting the context and transformer. We also parse
 * ZodErrors so that you get typesafety on the frontend if your procedure fails due to validation
 * errors on the backend.
 */

const t = initTRPC.context<typeof createTRPCContext>().create({
  transformer: superjson,
  errorFormatter({ shape, error }) {
    return {
      ...shape,
      data: {
        ...shape.data,
        zodError:
          error.cause instanceof ZodError ? error.cause.flatten() : null,
      },
    };
  },
});

/**
 * 3. ROUTER & PROCEDURE (THE IMPORTANT BIT)
 *
 * These are the pieces you use to build your tRPC API. You should import these a lot in the
 * "/src/server/api/routers" directory.
 */

/**
 * This is how you create new routers and sub-routers in your tRPC API.
 *
 * @see https://trpc.io/docs/router
 */
export const createTRPCRouter = t.router;

/**
 * Public (unauthenticated) procedure
 *
 * This is the base piece you use to build new queries and mutations on your tRPC API. It does not
 * guarantee that a user querying is authorized, but you can still access user session data if they
 * are logged in.
 */
export const publicProcedure = t.procedure;

/**
 * Protected (authenticated) procedure
 *
 * If you want a query or mutation to ONLY be accessible to logged in users, use this. It verifies
 * the session is valid and guarantees `ctx.session.user` is not null.
 *
 * @see https://trpc.io/docs/procedures
 */
export const protectedProcedure = t.procedure.use(({ ctx, next }) => {
  if (!ctx.session?.user) {
    throw new TRPCError({ code: "UNAUTHORIZED" });
  }

  const { user, ...session } = ctx.session;

  return next({
    ctx: {
      // infers the `session` as non-nullable
      user,
      session,
      db,
    },
  });
});

export const hostProcedure = t.procedure.use(async ({ ctx, next }) => {
  if (!ctx.session?.user) {
    throw new TRPCError({ code: "UNAUTHORIZED" });
  }

  const { user, ...session } = ctx.session;

  const hostProfile = await ctx.db.query.hostProfiles.findFirst({
    where: eq(hostProfiles.userId, user.id),
  });

  if (!hostProfile) {
    throw new TRPCError({
      code: "UNAUTHORIZED",
      message: `Host profile not found for user id ${user.id}`,
    });
  }

  return next({
    ctx: {
      // infers the `session` as non-nullable
      user,
      hostProfile,
      session,
      db,
    },
  });
});

export const optionallyAuthedProcedure = t.procedure.use(({ ctx, next }) => {
  return next({
    ctx: {
      // infers `session` as nullable
      user: ctx.session?.user,
      session: ctx.session,
      db,
    },
  });
});

export const roleRestrictedProcedure = <
  TAllowedRoles extends readonly User["role"][],
>(
  allowedRoles: TAllowedRoles,
) =>
  t.procedure.use(async ({ ctx, next }) => {
    if (!ctx.session?.user) {
      throw new TRPCError({ code: "UNAUTHORIZED" });
    }

    const { user, ...session } = ctx.session;

    const data = await ctx.db.query.users.findFirst({
      where: eq(users.id, user.id),
      columns: { role: true },
    });

    const role = data?.role ?? "guest";

    if (
      allowedRoles.length === 1 &&
      allowedRoles[0] === "admin" &&
      role !== "admin"
    ) {
      throw new TRPCError({ code: "UNAUTHORIZED" });
    }

    return next({
      ctx: {
        // infers `session` as non-nullable and `role` as one of the allowed ones
        user: { ...user, role: role as TAllowedRoles[number] },
        session,
        db,
      },
    });
  });
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/server/auth.ts</div>
<pre><code>
import { env } from "@/env";
import { db } from "@/server/db";
import * as bycrypt from "bcrypt";
import { eq } from "drizzle-orm";
import { type GetServerSidePropsContext } from "next";
import {
  getServerSession,
  type DefaultSession,
  type NextAuthOptions,
  type User,
} from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import GoogleProvider from "next-auth/providers/google";
import { CustomPgDrizzleAdapter } from "./adapter";
import { users, type User as TramonaUser } from "./db/schema";

const THIRTY_DAYS = 30 * 24 * 60 * 60;
const THIRTY_MINUTES = 30 * 60;

const adapter = CustomPgDrizzleAdapter(db); // custom adapter

/**
 * Module augmentation for `next-auth` types. Allows us to add custom properties to the `session`
 * object and keep type safety.
 *
 * @see https://next-auth.js.org/getting-started/typescript#module-augmentation
 */
declare module "next-auth" {
  // eslint-disable-next-line @typescript-eslint/no-empty-interface
  interface User extends TramonaUser {}

  interface Session extends DefaultSession {
    user: Pick<
      TramonaUser,
      | "name"
      | "firstName"
      | "lastName"
      | "email"
      | "image"
      | "id"
      | "role"
      | "username"
      | "referralCodeUsed"
      | "referralTier"
      | "phoneNumber"
      | "createdAt"
      | "stripeCustomerId"
      | "stripeConnectId"
      | "setupIntentId"
      | "isIdentityVerified"
      | "isWhatsApp"
      | "dateOfBirth"
      | "chargesEnabled"
    >;
  }
}

/**
 * Options for NextAuth.js used to configure adapters, providers, callbacks, etc.
 *
 * @see https://next-auth.js.org/configuration/options
 */
export const authOptions: NextAuthOptions = {
  debug: true,
  callbacks: {
    session: ({ session, token }) => {
      // return {...session, user}}
      return {
        ...session,
        user: {
          ...session.user,
          id: token.id,
          role: token.role,
          username: token.username,
          referralCodeUsed: token.referralCodeUsed,
          referralTier: token.referralTier,
          phoneNumber: token.phoneNumber,
          createdAt: token.createdAt,
          stripeCustomerId: token.stripeCustomerId,
          stripeConnectId: token.stripeConnectId,
          setupIntentId: token.setupIntentId,
          isIdentityVerified: token.isIdentityVerified,
          isWhatsApp: token.isWhatsApp,
          dateOfBirth: token.dateOfBirth,
          firstName: token.firstName,
          lastName: token.lastName,
          chargesEnabled: token.chargesEnabled,
        },
      };
    },
    async jwt({ token, user, trigger }) {
      const newToken = token;

      if (trigger === "update" && token.sub) {
        if (adapter.getUser) {
          const latestUser = await adapter.getUser(token.sub);
          if (latestUser) {
            user = latestUser;
          }
        }
      }

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (user) {
        newToken.id = user.id;
        newToken.role = user.role;
        newToken.username = user.username;
        newToken.name = user.name;
        newToken.firstName = user.firstName;
        newToken.lastName = user.lastName;
        newToken.referralCodeUsed = user.referralCodeUsed;
        newToken.referralTier = user.referralTier;
        newToken.phoneNumber = user.phoneNumber;
        newToken.createdAt = user.createdAt;
        newToken.stripeCustomerId = user.stripeCustomerId;
        newToken.stripeConnectId = user.stripeConnectId;
        newToken.setupIntentId = user.setupIntentId;
        newToken.isIdentityVerified = user.isIdentityVerified;
        newToken.isWhatsApp = user.isWhatsApp;
        newToken.dateOfBirth = user.dateOfBirth;
        newToken.chargesEnabled = user.chargesEnabled;
      }

      return newToken;
    },
  },
  adapter,
  providers: [
    // DiscordProvider({
    //   clientId: env.DISCORD_CLIENT_ID,
    //   clientSecret: env.DISCORD_CLIENT_SECRET,
    // }),
    /**
     * ...add more providers here.
     *
     * Most other providers require a bit more work than the Discord provider. For example, the
     * GitHub provider requires you to add the `refresh_token_expires_in` field to the Account
     * model. Refer to the NextAuth.js docs for the provider you want to use. Example:
     *
     * @see https://next-auth.js.org/providers/github
     */
    // -- You can use the credential with another service like etherum, oAuth, etc.
    CredentialsProvider({
      name: "Credentials",
      credentials: {
        email: {
          label: "Email",
          type: "email",
          placeholder: "name@domain.com",
        },
        password: { label: "Password", type: "password" },
      },
      authorize: async (credentials) => {
        if (credentials === undefined) return Promise.resolve(null);

        let user = null;

        user = await db.query.users.findFirst({
          where: eq(users.email, credentials.email),
        });

        if (user === undefined) return Promise.resolve(null); // user not found

        if (user.password === null) {
          return Promise.resolve(null); // users created with google auth
        }

        const isPasswordValid = await bycrypt.compare(
          credentials.password,
          user.password,
        );

        if (!isPasswordValid) return Promise.resolve(null);

        // Check if email is verified
        if (user.emailVerified === null) {
          return Promise.resolve(null);
        }

        return Promise.resolve(user as User);
      },
    }),
    // FacebookProvider({
    //   clientId: env.FACEBOOK_CLIENT_ID,
    //   clientSecret: env.FACEBOOK_CLIENT_SECRET,
    // }),
    GoogleProvider({
      clientId: env.GOOGLE_CLIENT_ID,
      clientSecret: env.GOOGLE_CLIENT_SECRET,
    }),
  ],
  session: {
    strategy: "jwt",
    maxAge: THIRTY_DAYS,
    updateAge: THIRTY_MINUTES,
  },
  pages: {
    signIn: "/auth/signin",
    error: "/auth/error",
    newUser: "/auth/onboarding",
    signOut: "/",
  },
};

/**
 * Wrapper for `getServerSession` so that you don't need to import the `authOptions` in every file.
 *
 * @see https://next-auth.js.org/configuration/nextjs
 */
export async function getServerAuthSession(
  ctx: Pick<GetServerSidePropsContext, "req" | "res">,
) {
  return await getServerSession(ctx.req, ctx.res, authOptions);
}
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/server/db/schema/tables/users.ts</div>
<pre><code>
import {
  boolean,
  index,
  integer,
  pgEnum,
  pgTable,
  serial,
  text,
  timestamp,
  varchar,
} from "drizzle-orm/pg-core";
import { createInsertSchema, createSelectSchema } from "drizzle-zod";
import { offers } from "..";
import { z } from "zod";
import { sql } from "drizzle-orm";
import { zodString } from "@/utils/zod-utils";

// we need to put referralCodes and users in the same file because
// the tables depend on each other

export const REFERRAL_CODE_LENGTH = 7;
export const ALL_ROLES = ["guest", "host", "admin"] as const;
export const roleEnum = pgEnum("role", ALL_ROLES);
export const referralTierEnum = pgEnum("referral_tier", [
  "Partner",
  "Ambassador",
]);
export const earningStatusEnum = pgEnum("earning_status", [
  "pending",
  "paid",
  "cancelled",
]);

export const isIdentityVerifiedEnum = pgEnum("is_identity_verified", [
  "false",
  "true",
  "pending",
]);

// NOTE: every time you add a column to the users table,
// you can choose to either add it to the session (e.g. session.user.newColumn)
// or not. If you do want to, go to src/server/auth.ts and youll see 3 places
// where you need to add the new column
export const users = pgTable(
  "user",
  {
    // nextauth fields
    id: text("id").notNull().primaryKey(),
    name: text("name"),
    firstName: text("first_name"),
    lastName: text("last_name"),
    email: text("email").notNull(),
    emailVerified: timestamp("emailVerified", { withTimezone: true }),
    image: text("image"),

    // custom fields
    password: varchar("password", { length: 510 }),
    username: varchar("username", { length: 60 }),
    referralCodeUsed: varchar("referral_code_used", {
      length: REFERRAL_CODE_LENGTH,
    }),
    role: roleEnum("role").notNull().default("guest"),
    referralTier: referralTierEnum("referral_tier")
      .notNull()
      .default("Partner"),
    phoneNumber: varchar("phone_number", { length: 20 }),
    lastTextAt: timestamp("last_text_at", { withTimezone: true }).defaultNow(),
    isWhatsApp: boolean("is_whats_app").default(false).notNull(),
    stripeCustomerId: varchar("stripe_customer_id"),
    stripeConnectId: varchar("stripe_connect_id"),
    chargesEnabled: boolean("charges_enabled").default(false),
    setupIntentId: varchar("setup_intent_id"),

    // mode: "string" cuz nextauth doesnt serialize/deserialize dates
    createdAt: timestamp("created_at", { withTimezone: true, mode: "string" })
      .notNull()
      .defaultNow(),
    //stripe identity verifications
    isIdentityVerified: isIdentityVerifiedEnum("is_identity_verified")
      .default("false")
      .notNull(),
    verificationReportId: varchar("verification_report_id"),
    dateOfBirth: varchar("date_of_birth"),

    profileUrl: varchar("profile_url", { length: 1000 }),
    location: varchar("location", { length: 1000 }),
    socials: varchar("socials")
      .array()
      .default(sql`'{}'`),
    about: text("about"),
    // destinations: varchar("destinations").array(),
    onboardingStep: integer("onboarding_step").notNull().default(0),
    isBurner: boolean("is_burner").default(false),
    sessionToken: text("session_token").unique(),
  },
  (t) => ({
    phoneNumberIdx: index().on(t.phoneNumber),
    emailIdx: index().on(t.email),
  }),
);

export type User = typeof users.$inferSelect;

export const referralCodes = pgTable(
  "referral_codes",
  {
    referralCode: varchar("referral_code", {
      length: REFERRAL_CODE_LENGTH,
    }).primaryKey(),
    ownerId: text("owner_id")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),
    totalBookingVolume: integer("total_booking_volume").notNull().default(0),
    numSignUpsUsingCode: integer("num_sign_ups_using_code")
      .notNull()
      .default(0),
    numBookingsUsingCode: integer("num_bookings_using_code")
      .notNull()
      .default(0),
    numHostSignUpsUsingCode: integer("num_host_sign_ups_using_code")
      .notNull()
      .default(0),
    curBalance: integer("cur_balance").notNull().default(0),
    createdAt: timestamp("created_at", { withTimezone: true })
      .notNull()
      .defaultNow(),
  },
  (t) => ({
    ownerIdIdx: index("owner_id_idx").on(t.ownerId),
  }),
);

export const referralEarnings = pgTable(
  "referral_earnings",
  {
    id: serial("id").primaryKey(),
    referralCode: text("referral_code")
      .notNull()
      .references(() => referralCodes.referralCode, { onDelete: "cascade" }),
    refereeId: text("referee_id")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),
    offerId: integer("offer_id")
      .notNull()
      .references(() => offers.id, { onDelete: "cascade" }),
    earningStatus: earningStatusEnum("earning_status").default("pending"),
    cashbackEarned: integer("cashback_earned").notNull(),
    createdAt: timestamp("created_at", { withTimezone: true })
      .notNull()
      .defaultNow(),
    hostFeesSaved: integer("host_fees_saved"),
  },
  (t) => ({
    referralCodeIdx: index().on(t.referralCode),
    refereeIdIdx: index().on(t.refereeId),
    offerIdIdx: index().on(t.offerId),
  }),
);

export type ReferralEarnings = typeof referralEarnings.$inferSelect;
export const referralEarningsSelectSchema =
  createSelectSchema(referralEarnings);
export const referralEarningsInsertSchema =
  createInsertSchema(referralEarnings);

export type ReferralCode = typeof referralCodes.$inferSelect;
export const referralCodeSelectSchema = createSelectSchema(referralCodes);
export const referralCodeInsertSchema = createInsertSchema(referralCodes);

export const userInsertSchema = createInsertSchema(users, {
  socials: z.string().array(),
});
export const userSelectSchema = createSelectSchema(users);
export const userUpdateSchema = userInsertSchema
  .partial()
  .required({ id: true });
export const ProfileInfoSchema = z.object({
  name: zodString(),
  about: zodString({ maxLen: 1000 }),
  location: zodString(),
  facebook_link: z
    .string()
    .url()
    .startsWith("https://www.facebook.com/", "Must be a Facebook link")
    .optional()
    .or(z.literal("")),
  youtube_link: z
    .string()
    .url()
    .startsWith("https://www.youtube.com/", "Must be a YouTube link")
    .optional()
    .or(z.literal("")),
  instagram_link: z
    .string()
    .url()
    .startsWith("https://www.instagram.com/", "Must be a Instagram link")
    .optional()
    .or(z.literal("")),
  twitter_link: z
    .string()
    .url()
    .startsWith("https://x.com/", "Must be a Twitter link")
    .optional()
    .or(z.literal("")),
});
</code></pre>
</div>
<div class='section'>
<h2 class='section-title'>Messaging System Core</h2>
<div class='file'>
<div class='file-name'>./src/components/messages/ChatInput.tsx</div>
<pre><code>
import { useConversation } from "@/utils/store/conversations";
import { type ChatMessageType, useMessage } from "@/utils/store/messages";
import supabase from "@/utils/supabase-client";
import { errorToast } from "@/utils/toasts";
import { zodResolver } from "@hookform/resolvers/zod";
import { nanoid } from "nanoid";
import { useSession } from "next-auth/react";
import { useForm } from "react-hook-form";
import { z } from "zod";
import { Form, FormControl, FormField, FormItem } from "../ui/form";
import { Input } from "../ui/input";

import { api } from "@/utils/api";
import { sub } from "date-fns";
import { ArrowUp } from "lucide-react";
import { Button } from "../ui/button";
import { useUpdateUser } from "@/utils/utils";

const formSchema = z.object({
  message: z.string().refine((data) => data.trim() !== ""),
});

export default function ChatInput({
  conversationId,
}: {
  conversationId: string;
}) {
  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      message: "",
    },
  });

  const { data: session } = useSession();

  const addMessageToConversation = useMessage(
    (state) => state.addMessageToConversation,
  );

  const setOptimisticIds = useMessage((state) => state.setOptimisticIds);

  const setConversationToTop = useConversation(
    (state) => state.setConversationToTop,
  );

  const removeMessageFromConversation = useMessage(
    (state) => state.removeMessageFromConversation,
  );

  const { updateUser } = useUpdateUser();
  const { mutateAsync: sendSMS } = api.twilio.sendSMS.useMutation();
  const { mutateAsync: sendSlackToAdmin } =
    api.messages.sendAdminSlackMessage.useMutation();
  const { data: participantPhoneNumbers } =
    api.messages.getParticipantsPhoneNumbers.useQuery({ conversationId });

  const twilioWhatsAppMutation = api.twilio.sendWhatsApp.useMutation();

  const { data: _conversationExists } =
    api.messages.getConversations.useQuery();

  const conversationList = useConversation((state) => state.conversationList);

  // Add check before sending message
  if (!conversationId) {
    console.error("No conversation ID available");
    return;
  }

  // Validate conversation ID format if using nanoid
  if (conversationId.length !== 21) {
    console.error("Invalid conversation ID format");
    return;
  }

  const onSubmit = async (values: z.infer<typeof formSchema>) => {
    if (session) {
      console.log("1. Starting message submission...");
      console.log("Current conversation ID:", conversationId);
      console.log("Available conversations:", conversationList);

      // First verify the conversation exists in Supabase
      const { data: dbConversation, error: checkError } = await supabase
        .from("conversations")
        .select("id, created_at, name")
        .eq("id", conversationId)
        .single();

      console.log("2. Database check result:", {
        conversation: dbConversation,
        error: checkError,
      });

      if (checkError ?? !dbConversation) {
        console.error("3. Conversation not found in database:", checkError);
        errorToast("Conversation not found. Please refresh the page.");
        return;
      }

      const newMessage: ChatMessageType = {
        id: nanoid(),
        createdAt: new Date().toISOString(),
        conversationId: conversationId,
        userId: session.user.id,
        message: values.message,
        read: false,
        isEdit: false,
      };

      console.log("4. Created new message object:", newMessage);

      // Add message optimistically
      addMessageToConversation(conversationId, newMessage);
      setOptimisticIds(newMessage.id);
      setConversationToTop(conversationId, {
        id: newMessage.id,
        conversationId: conversationId,
        userId: session.user.id,
        message: newMessage.message,
        createdAt: new Date().toISOString(),
        read: false,
        isEdit: false,
      });
      form.reset();

      console.log("5. Attempting Supabase message insert...");

      // Insert message into database
      const messageData = {
        id: newMessage.id,
        conversation_id: conversationId,
        user_id: newMessage.userId,
        message: newMessage.message,
        read: false,
        is_edit: false,
        created_at: new Date().toISOString(),
      };

      console.log("6. Message data to insert:", messageData);

      const { error } = await supabase.from("messages").insert(messageData);

      if (error) {
        console.error("7. Supabase insert error:", {
          error,
          messageData,
          conversationId,
        });
        removeMessageFromConversation(conversationId, newMessage.id);
        errorToast();
        return;
      }

      console.log("8. Message successfully inserted");

      // Send Slack notification
      await sendSlackToAdmin({
        message: newMessage.message,
        conversationId,
        senderId: newMessage.userId,
      });

      // Only send SMS/WhatsApp if there are unread messages and enough time has passed
      if (participantPhoneNumbers) {
        const unreadParticipants = participantPhoneNumbers.filter(
          ({ lastTextAt }) =>
            !lastTextAt || lastTextAt <= sub(new Date(), { hours: 1 }),
        );

        if (unreadParticipants.length > 0) {
          void Promise.all(
            unreadParticipants.map(async ({ phoneNumber, isWhatsApp }) => {
              if (phoneNumber) {
                if (isWhatsApp) {
                  await twilioWhatsAppMutation.mutateAsync({
                    templateId: "HXae95c5b28aa2f5448a5d63ee454ccb74",
                    to: phoneNumber,
                  });
                } else {
                  await sendSMS({
                    to: phoneNumber,
                    msg: "You have a new unread message in Tramona, visit Tramona.com to view",
                  });
                }
                await updateUser({ lastTextAt: new Date() });
              }
            }),
          );
        }
      }
    }
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="p-2 pt-0">
        <div className="flex items-center overflow-clip rounded-full border-2">
          <div className="flex-1">
            <FormField
              control={form.control}
              name="message"
              render={({ field }) => (
                <FormItem>
                  <FormControl>
                    <Input
                      placeholder="Type a message"
                      className="border-none"
                      autoFocus
                      {...field}
                    />
                  </FormControl>
                  {/* <FormMessage /> */}
                </FormItem>
              )}
            />
          </div>
          <div className="pr-2">
            <Button size="icon" type="submit" className="h-7 w-7 rounded-full">
              <ArrowUp size={20} />
            </Button>
          </div>
        </div>
      </form>
    </Form>
  );
}
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/components/messages/ChatMessages.tsx</div>
<pre><code>
import { useMessage } from "@/utils/store/messages";
import { useEffect } from "react";
import ListMessages from "./ListMessages";

export const LIMIT_MESSAGE = 20;

export default function ChatMessages({
  conversationId,
}: {
  conversationId: string;
}) {
  const { switchConversation, fetchInitialMessages } = useMessage();

  // Fetch conversation on the client
  useEffect(() => {
    // Update conversation state
    switchConversation(conversationId);

    // Fetch initial messages when the component mounts
    void fetchInitialMessages(conversationId);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [conversationId]);

  return (
    <>
      <ListMessages />
    </>
  );
}
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/components/messages/ListMessages.tsx</div>
<pre><code>
import { type MessageDbType } from "@/types/supabase.message";
import { useMessage } from "@/utils/store/messages";
import supabase from "@/utils/supabase-client";
import { useEffect, useRef, useState } from "react";
import { Icons } from "../_icons/icons";
import { api } from "@/utils/api";
import { useConversation } from "@/utils/store/conversations";
import { useSession } from "next-auth/react";
import LoadMoreMessages from "./LoadMoreMessages";
import { groupMessages } from "./groupMessages";
import { MessageGroup } from "./MessageGroup";

function NoMessages() {
  return (
    <div className="absolute flex h-full flex-col items-center justify-center text-muted-foreground">
      No messages
    </div>
  );
}

export default function ListMessages() {
  const scrollRef = useRef<HTMLDivElement>(null);
  const [userScrolled, setUserScrolled] = useState(false);
  const [notification, setNotification] = useState(0);
  const { conversations } = useMessage();

  const currentConversationId = useMessage(
    (state) => state.currentConversationId,
  );

  const addMessageToConversation = useMessage(
    (state) => state.addMessageToConversation,
  );

  const messages = currentConversationId
    ? (conversations[currentConversationId]?.messages ?? [])
    : [];

  const { mutateAsync } = api.messages.setMessagesToRead.useMutation();

  const { data: session } = useSession();

  // Set all the messages to read when loaded
  useEffect(() => {
    const unreadMessageIds = messages
      .filter(
        (message) =>
          message.read === false && message.userId !== session?.user.id,
      )
      .map((message) => message.id);

    if (unreadMessageIds.length > 0) {
      void mutateAsync({ unreadMessageIds });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [messages]);

  const hasMore = currentConversationId
    ? (conversations[currentConversationId]?.hasMore ?? false)
    : false;

  const handlePostgresChange = async (payload: { new: MessageDbType }) => {
    if (payload.new.user_id !== session?.user.id) {
      addMessageToConversation(payload.new.conversation_id, {
        id: payload.new.id,
        conversationId: payload.new.conversation_id,
        userId: payload.new.user_id,
        message: payload.new.message,
        isEdit: payload.new.is_edit,
        createdAt: payload.new.created_at,
        read: payload.new.read,
      });
    }

    const scrollContainer = scrollRef.current;
    if (
      scrollContainer &&
      scrollContainer.scrollTop <
        scrollContainer.scrollHeight - scrollContainer.clientHeight - 10
    ) {
      setNotification((current) => current + 1);
    }
  };

  useEffect(() => {
    const channel = supabase
      .channel(`${currentConversationId}`)
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "messages",
        },
        (payload: { new: MessageDbType }) => void handlePostgresChange(payload),
      )
      .subscribe();

    return () => {
      void channel.unsubscribe();
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentConversationId, messages]);

  useEffect(() => {
    const scrollContainer = scrollRef.current;

    if (scrollContainer && !userScrolled) {
      scrollContainer.scrollTop = scrollContainer.scrollHeight;
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [messages]);

  const handleOnScroll = () => {
    const scrollContainer = scrollRef.current;

    // Check if scroll is more than 10 pixels
    if (scrollContainer) {
      const isScroll =
        scrollContainer.scrollTop <
        scrollContainer.scrollHeight - scrollContainer.clientHeight - 10;

      setUserScrolled(isScroll);

      // Set notification to 0 when scroll to bottom
      if (
        scrollContainer.scrollTop ===
        scrollContainer.scrollHeight - scrollContainer.clientHeight
      ) {
        setNotification(0);
      }
    }
  };

  const scrollDown = () => {
    // Clear notification when scorlled down
    setNotification(0);
    if (scrollRef.current) {
      scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
    }
  };

  // Get all participants
  const { conversationList } = useConversation();

  const conversationIndex = conversationList.findIndex(
    (conversation) => conversation.id === currentConversationId,
  );

  const participants = conversationList[conversationIndex]?.participants;

  const messagesWithUser = messages
    .map((message) => {
      if (!participants || !session) return null;

      // Handle current user messages
      if (message.userId === session.user.id) {
        return {
          message,
          user: {
            id: session.user.id,
            name: session.user.name,
            image: session.user.image,
            email: session.user.email,
          },
        };
      }

      // Handle other participants' messages
      const participant = participants.find((p) => p.id === message.userId);
      if (!participant) return null;

      return {
        message,
        user: {
          id: participant.id,
          name: participant.name,
          image: participant.image,
          email: participant.email,
        },
      };
    })
    .filter(Boolean);

  // Messages are now in correct order before grouping
  const messageGroups = groupMessages(messagesWithUser);

  return (
    <>
      <div
        ref={scrollRef}
        onScroll={handleOnScroll}
        className="relative flex flex-1 flex-col overflow-y-auto"
      >
        <div className="flex-1"></div>
        <div className="absolute w-full space-y-8 p-4 pt-12">
          {hasMore && <LoadMoreMessages />}
          {messageGroups.map((messageGroup) => (
            <MessageGroup
              key={messageGroup.messages[0]?.id}
              messageGroup={messageGroup}
            />
          ))}
        </div>
        {messages.length === 0 && (
          <div className="flex h-full w-full items-center justify-center">
            <NoMessages />
          </div>
        )}
      </div>
      {userScrolled && (
        <div
          className="absolute bottom-16 flex w-full items-center justify-center"
          onClick={() => scrollDown()}
        >
          {notification ? (
            <div className="cursor-pointer rounded-xl bg-black px-6 py-1 transition-all hover:scale-110">
              <h1 className="text-white">New {notification} messages</h1>
            </div>
          ) : (
            <div className="cursor-pointer rounded-full bg-black p-2 transition-all hover:scale-110">
              <Icons.arrowDown color="white" />
            </div>
          )}
        </div>
      )}
    </>
  );
}
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/components/messages/MessageGroup.tsx</div>
<pre><code>
import { type MessageType } from "@/server/db/schema";
import { formatRelative } from "date-fns";
import { useSession } from "next-auth/react";
import { type MessageGroup } from "./groupMessages";
import { cn } from "@/utils/utils";

export function MessageGroup({ messageGroup }: { messageGroup: MessageGroup }) {
  const { data: session } = useSession();
  const { user, messages } = messageGroup;
  const firstMessage = messages[0];
  if (!firstMessage || !session) return null;

  const me = session.user.id === user?.id;

  return (
    <div
      className={cn(
        "flex items-start gap-2",
        me ? "justify-start" : "justify-end",
      )}
    >
      {/* {user ? <UserAvatar {...user} /> : <AnonymousAvatar />} */}
      <div
        className={cn(
          "max-w-72 rounded-xl px-4 py-2 sm:max-w-96 lg:max-w-prose",
          me ? "bg-teal-900 text-white" : "bg-white",
        )}
      >
        {/* <div className="flex items-baseline gap-2">
          {user ? (
            <p className="font-semibold leading-none">{user.name}</p>
          ) : (
            <p className="leading-none text-muted-foreground">[deleted user]</p>
          )}
        </div> */}

        <div className="space-y-1">
          {messages.map((message) => (
            <Message key={message.id} message={message} />
          ))}
        </div>
        <div className="flex items-center justify-between gap-2 text-xs text-muted-foreground">
          <p>{formatRelative(firstMessage.createdAt, new Date())}</p>
          <p>
            {session.user.id === firstMessage.userId && firstMessage.read && (
              <>Read</>
            )}
          </p>
        </div>
      </div>
    </div>
  );
}

function Message({ message }: { message: MessageType }) {
  return (
    <p>
      {message.message}
      {message.isEdit && (
        <span className="ml-1 text-xs text-muted-foreground">(edited)</span>
      )}
    </p>
  );
}
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/components/messages/HostInitiateChat.tsx</div>
<pre><code>
import { useRouter } from "next/router";
import { api } from "@/utils/api";
import { type TRPCError } from "@trpc/server";

export function HostInitiateChat({ travelerId }: { travelerId: string }) {
  const router = useRouter();
  const { mutateAsync: createConversation } =
    api.messages.createConversationHostWithUser.useMutation();

  const handleClick = async () => {
    try {
      const conversation = await createConversation({ userId: travelerId });
      void router.push(`/host/messages?conversationId=${conversation.id}`);
    } catch (error) {
      const tRPCError = error as TRPCError;
      console.error("Failed to create conversation:", tRPCError.message);
    }
  };

  return <button onClick={() => void handleClick()}>Message Traveler</button>;
}
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/components/checkout/sections/ChatWithHost.tsx</div>
<pre><code>
import { useChatWithAdmin } from "@/utils/messaging/useChatWithAdmin";

export default function ChatWithHost() {
  const chatWithAdmin = useChatWithAdmin();

  return (
    <p className="text-sm">
      Questions?{" "}
      <button
        onClick={() => chatWithAdmin()}
        className="text-blue-600 underline underline-offset-2"
      >
        Chat with host
      </button>
    </p>
  );
}
</code></pre>
</div>
<div class='section'>
<h2 class='section-title'>State Management</h2>
<div class='file'>
<div class='file-name'>./src/utils/store/messages.ts</div>
<pre><code>
import { LIMIT_MESSAGE } from "@/components/messages/ChatMessages";
import { type MessageType } from "@/server/db/schema";
import { create } from "zustand";
import supabase from "../supabase-client";
import { errorToast } from "../toasts";

export type ChatMessageType = MessageType & { userId: string }; // make userId non-null

type ConversationsState = Record<
  string,
  {
    messages: ChatMessageType[];
    page: number;
    hasMore: boolean;
    alreadyFetched: boolean;
  }
>;

type MessageState = {
  conversations: ConversationsState;
  currentConversationId: string | null;
  setCurrentConversationId: (id: string) => void;
  switchConversation: (conversationId: string) => void;
  addMessageToConversation: (
    conversationId: string,
    messages: ChatMessageType,
  ) => void;
  optimisticIds: string[];
  setOptimisticIds: (id: string) => void;
  setMoreMessagesToConversation: (
    conversationId: string,
    moreMessages: ChatMessageType[],
  ) => void;
  fetchInitialMessages: (conversationId: string) => Promise<void>;
  removeMessageFromConversation: (
    conversationId: string,
    messageId: string,
  ) => void;
};

export const useMessage = create<MessageState>((set, get) => ({
  conversations: {},
  currentConversationId: null,
  setCurrentConversationId: (id: string) => {
    set(() => ({
      currentConversationId: id,
    }));
  },
  switchConversation: (conversationId: string) => {
    set({ currentConversationId: conversationId });
  },
  addMessageToConversation: (
    conversationId: string,
    newMessage: ChatMessageType,
  ) => {
    // Optimistically update the state
    set((state) => {
      const updatedConversations: ConversationsState = {
        ...state.conversations,
      };

      if (updatedConversations[conversationId]) {
        updatedConversations[conversationId] = {
          messages: [
            ...updatedConversations[conversationId].messages,
            newMessage,
          ],
          page: updatedConversations[conversationId].page,
          hasMore: updatedConversations[conversationId].hasMore,
          alreadyFetched: updatedConversations[conversationId].alreadyFetched,
        };
      }

      const updatedState: MessageState = {
        ...state,
        conversations: updatedConversations,
        optimisticIds: [...state.optimisticIds, newMessage.id],
      };

      return updatedState;
    });
  },
  optimisticIds: [],
  setOptimisticIds: (id: string) =>
    set((state) => ({
      optimisticIds: [...state.optimisticIds, id],
    })),
  setMoreMessagesToConversation: (
    conversationId: string,
    moreMessages: ChatMessageType[],
  ) => {
    set((state) => {
      const updatedConversations: ConversationsState = {
        ...state.conversations,
      };

      // Check if the conversation exists in the state
      if (updatedConversations[conversationId]) {
        // Add the new message to the existing conversation
        updatedConversations[conversationId] = {
          messages: [
            ...updatedConversations[conversationId].messages,
            ...moreMessages,
          ],
          page: updatedConversations[conversationId].page + 1,
          hasMore: moreMessages.length >= LIMIT_MESSAGE,
          alreadyFetched: updatedConversations[conversationId].alreadyFetched,
        };
      } else {
        // If the conversation doesn't exist, create a new conversation with the new message
        updatedConversations[conversationId] = {
          messages: moreMessages,
          page: 1, // Set a default value for page
          hasMore: true,
          alreadyFetched: true,
        };
      }

      const updatedState: MessageState = {
        ...state,
        conversations: updatedConversations,
      };

      return updatedState;
    });
  },
  fetchInitialMessages: async (conversationId: string): Promise<void> => {
    const state = get();

    // Check if messages for this conversation have already been fetched
    if (state.conversations[conversationId]?.alreadyFetched) {
      return;
    }

    try {
      const { data, error } = await supabase
        .from("messages")
        .select(
          `
            *,
            user(name, image, email)
          `,
        )
        .range(0, LIMIT_MESSAGE)
        .eq("conversation_id", conversationId)
        .order("created_at", { ascending: true });

      if (error) {
        throw new Error(error.message);
      }

      const chatMessages = data.map((message) => ({
        id: message.id,
        createdAt: message.created_at,
        conversationId: message.conversation_id,
        userId: message.user_id,
        message: message.message,
        read: message.read ?? false, // since fetched means it's read
        isEdit: message.is_edit ?? false, // Provide a default value if needed
        user: {
          name: message.user?.name ?? "",
          image: message.user?.image ?? "",
          email: message.user?.email ?? "",
        },
      }));

      const hasMore = chatMessages.length >= LIMIT_MESSAGE;

      set((state) => ({
        ...state,
        conversations: {
          ...state.conversations,
          [conversationId]: {
            messages: chatMessages,
            page: 1,
            hasMore,
            alreadyFetched: true, // Set the flag to true after fetching
          },
        },
      }));
    } catch (error) {
      errorToast();
    }
  },
  removeMessageFromConversation: (
    conversationId: string,
    messageId: string,
  ) => {
    set((state) => {
      const updatedConversations: ConversationsState = {
        ...state.conversations,
      };

      // Check if the conversation exists in the state
      if (updatedConversations[conversationId]) {
        // Remove the message from the existing conversation
        updatedConversations[conversationId] = {
          messages: updatedConversations[conversationId].messages.filter(
            (message) => message.id !== messageId,
          ),
          page: updatedConversations[conversationId].page,
          hasMore: updatedConversations[conversationId].hasMore,
          alreadyFetched: updatedConversations[conversationId].alreadyFetched,
        };
      }

      const updatedState: MessageState = {
        ...state,
        conversations: updatedConversations,
        optimisticIds: state.optimisticIds.filter((id) => id !== messageId),
      };

      return updatedState;
    });
  },
}));
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/utils/store/conversations.ts</div>
<pre><code>
import { type MessageType } from "@/server/db/schema";

import { create } from "zustand";
import { type RouterOutputs } from "../api";

export type Conversation =
  RouterOutputs["messages"]["getConversations"][number];

export type Conversations = RouterOutputs["messages"]["getConversations"];

type ConversationListState = {
  conversationList: Conversations | [];
  setConversationList: (conversationList: Conversations | []) => void;
  setConversationToTop: (
    conversationId: string,
    newMessage: MessageType,
  ) => void;
  setConversationReadState: (conversationId: string) => void;
};

export const useConversation = create<ConversationListState>((set) => ({
  conversationList: [],
  setConversationList: (conversationList: Conversations | []) => {
    set(() => ({ conversationList }));
  },
  setConversationToTop: (conversationId: string, newMessage: MessageType) => {
    set((state) => {
      const updatedConversations = [...state.conversationList];
      const conversationIndex = updatedConversations.findIndex(
        (conversation) => conversation.id === conversationId,
      );

      if (conversationIndex !== -1) {
        const conversation = updatedConversations[conversationIndex];
        if (conversation) {
          // Remove conversation from current position
          updatedConversations.splice(conversationIndex, 1);
          // Add conversation to top with updated messages and ensure participants is defined
          updatedConversations.unshift({
            ...conversation,
            participants: conversation.participants ?? [],
            id: conversation.id,
            name: conversation.name,
            createdAt: conversation.createdAt,
            offerId: conversation.offerId ?? null,
            messages: [newMessage, ...conversation.messages],
          });
        }
      }

      return { conversationList: updatedConversations };
    });
  },
  setConversationReadState: (conversationId: string) => {
    set((state) => {
      const updatedConversations = state.conversationList.map(
        (conversation) => {
          if (conversation.id === conversationId) {
            const updatedMessages = conversation.messages.map((message) => ({
              ...message,
              read: true,
            }));
            return { ...conversation, messages: updatedMessages };
          }
          return conversation;
        },
      );

      return { conversationList: updatedConversations };
    });
  },
}));
</code></pre>
</div>
<div class='section'>
<h2 class='section-title'>Supabase Integration</h2>
<div class='file'>
<div class='file-name'>./src/utils/supabase-client.ts</div>
<pre><code>
import { env } from "@/env";
import { type SupabaseDatabase } from "@/types/supabase";
import { createClient } from "@supabase/supabase-js";

const supabaseUrl = env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseAnonKey = env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

const supabase = createClient<SupabaseDatabase>(supabaseUrl, supabaseAnonKey);

export default supabase;
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/types/supabase.ts</div>
<pre><code>
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[];

export type SupabaseDatabase = {
  public: {
    Tables: {
      account: {
        Row: {
          access_token: string | null;
          expires_at: number | null;
          id_token: string | null;
          provider: string;
          providerAccountId: string;
          refresh_token: string | null;
          scope: string | null;
          session_state: string | null;
          token_type: string | null;
          type: string;
          userId: string;
        };
        Insert: {
          access_token?: string | null;
          expires_at?: number | null;
          id_token?: string | null;
          provider: string;
          providerAccountId: string;
          refresh_token?: string | null;
          scope?: string | null;
          session_state?: string | null;
          token_type?: string | null;
          type: string;
          userId: string;
        };
        Update: {
          access_token?: string | null;
          expires_at?: number | null;
          id_token?: string | null;
          provider?: string;
          providerAccountId?: string;
          refresh_token?: string | null;
          scope?: string | null;
          session_state?: string | null;
          token_type?: string | null;
          type?: string;
          userId?: string;
        };
        Relationships: [
          {
            foreignKeyName: "account_userId_user_id_fk";
            columns: ["userId"];
            isOneToOne: false;
            referencedRelation: "user";
            referencedColumns: ["id"];
          },
        ];
      };
      conversation_participants: {
        Row: {
          conversation_id: string;
          user_id: string;
        };
        Insert: {
          conversation_id: string;
          user_id: string;
        };
        Update: {
          conversation_id?: string;
          user_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: "conversation_participants_conversation_id_conversations_id_fk";
            columns: ["conversation_id"];
            isOneToOne: false;
            referencedRelation: "conversations";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "conversation_participants_user_id_user_id_fk";
            columns: ["user_id"];
            isOneToOne: false;
            referencedRelation: "user";
            referencedColumns: ["id"];
          },
        ];
      };
      conversations: {
        Row: {
          created_at: string;
          id: string;
          name: string | null;
        };
        Insert: {
          created_at?: string;
          id: string;
          name?: string | null;
        };
        Update: {
          created_at?: string;
          id?: string;
          name?: string | null;
        };
        Relationships: [];
      };
      host_profiles: {
        Row: {
          became_host_at: string;
          charges_enabled: boolean | null;
          profile_url: string | null;
          stripeAccountId: string | null;
          type: SupabaseDatabase["public"]["Enums"]["host_type"];
          user_id: string;
        };
        Insert: {
          became_host_at?: string;
          charges_enabled?: boolean | null;
          profile_url?: string | null;
          stripeAccountId?: string | null;
          type?: SupabaseDatabase["public"]["Enums"]["host_type"];
          user_id: string;
        };
        Update: {
          became_host_at?: string;
          charges_enabled?: boolean | null;
          profile_url?: string | null;
          stripeAccountId?: string | null;
          type?: SupabaseDatabase["public"]["Enums"]["host_type"];
          user_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: "host_profiles_user_id_user_id_fk";
            columns: ["user_id"];
            isOneToOne: false;
            referencedRelation: "user";
            referencedColumns: ["id"];
          },
        ];
      };
      messages: {
        Row: {
          conversation_id: string;
          created_at: string;
          id: string;
          is_edit: boolean | null;
          message: string;
          read: boolean | null;
          user_id: string;
        };
        Insert: {
          conversation_id: string;
          created_at?: string;
          id: string;
          is_edit?: boolean | null;
          message: string;
          read?: boolean | null;
          user_id: string;
        };
        Update: {
          conversation_id?: string;
          created_at?: string;
          id?: string;
          is_edit?: boolean | null;
          message?: string;
          read?: boolean | null;
          user_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: "messages_conversation_id_conversations_id_fk";
            columns: ["conversation_id"];
            isOneToOne: false;
            referencedRelation: "conversations";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "messages_user_id_user_id_fk";
            columns: ["user_id"];
            isOneToOne: false;
            referencedRelation: "user";
            referencedColumns: ["id"];
          },
        ];
      };
      offers: {
        Row: {
          accepted_at: string | null;
          checkout_session_id: string | null;
          created_at: string;
          id: number;
          made_public_at: string | null;
          payment_intent_id: string | null;
          property_id: number;
          request_id: number;
          total_price: number;
        };
        Insert: {
          accepted_at?: string | null;
          checkout_session_id?: string | null;
          created_at?: string;
          id?: number;
          made_public_at?: string | null;
          payment_intent_id?: string | null;
          property_id: number;
          request_id: number;
          total_price: number;
        };
        Update: {
          accepted_at?: string | null;
          checkout_session_id?: string | null;
          created_at?: string;
          id?: number;
          made_public_at?: string | null;
          payment_intent_id?: string | null;
          property_id?: number;
          request_id?: number;
          total_price?: number;
        };
        Relationships: [
          {
            foreignKeyName: "offers_property_id_properties_id_fk";
            columns: ["property_id"];
            isOneToOne: false;
            referencedRelation: "properties";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "offers_request_id_requests_id_fk";
            columns: ["request_id"];
            isOneToOne: false;
            referencedRelation: "requests";
            referencedColumns: ["id"];
          },
        ];
      };
      properties: {
        Row: {
          about: string;
          address: string | null;
          airbnb_message_url: string | null;
          airbnb_url: string | null;
          area_description: string | null;
          avg_rating: number;
          check_in_info: string | null;
          created_at: string;
          host_id: string | null;
          host_name: string | null;
          id: number;
          image_url: string[];
          map_screenshot: string | null;
          max_num_guests: number;
          name: string;
          num_bedrooms: number;
          num_beds: number;
          num_ratings: number;
          original_nightly_price: number;
          property_amenities: SupabaseDatabase["public"]["Enums"]["property_amenities"][];
          property_safety_items: SupabaseDatabase["public"]["Enums"]["property_safety_items"][];
          property_standout_amenities: SupabaseDatabase["public"]["Enums"]["property_standout_amenities"][];
          property_type: SupabaseDatabase["public"]["Enums"]["property_type"];
        };
        Insert: {
          about: string;
          address?: string | null;
          airbnb_message_url?: string | null;
          airbnb_url?: string | null;
          area_description?: string | null;
          avg_rating: number;
          check_in_info?: string | null;
          created_at?: string;
          host_id?: string | null;
          host_name?: string | null;
          id?: number;
          image_url: string[];
          map_screenshot?: string | null;
          max_num_guests: number;
          name: string;
          num_bedrooms: number;
          num_beds: number;
          num_ratings: number;
          original_nightly_price: number;
          property_amenities: SupabaseDatabase["public"]["Enums"]["property_amenities"][];
          property_safety_items: SupabaseDatabase["public"]["Enums"]["property_safety_items"][];
          property_standout_amenities: SupabaseDatabase["public"]["Enums"]["property_standout_amenities"][];
          property_type: SupabaseDatabase["public"]["Enums"]["property_type"];
        };
        Update: {
          about?: string;
          address?: string | null;
          airbnb_message_url?: string | null;
          airbnb_url?: string | null;
          area_description?: string | null;
          avg_rating?: number;
          check_in_info?: string | null;
          created_at?: string;
          host_id?: string | null;
          host_name?: string | null;
          id?: number;
          image_url?: string[];
          map_screenshot?: string | null;
          max_num_guests?: number;
          name?: string;
          num_bedrooms?: number;
          num_beds?: number;
          num_ratings?: number;
          original_nightly_price?: number;
          property_amenities?: SupabaseDatabase["public"]["Enums"]["property_amenities"][];
          property_safety_items?: SupabaseDatabase["public"]["Enums"]["property_safety_items"][];
          property_standout_amenities?: SupabaseDatabase["public"]["Enums"]["property_standout_amenities"][];
          property_type?: SupabaseDatabase["public"]["Enums"]["property_type"];
        };
        Relationships: [
          {
            foreignKeyName: "properties_host_id_user_id_fk";
            columns: ["host_id"];
            isOneToOne: false;
            referencedRelation: "user";
            referencedColumns: ["id"];
          },
        ];
      };
      referral_codes: {
        Row: {
          created_at: string;
          num_bookings_using_code: number;
          num_sign_ups_using_code: number;
          owner_id: string;
          referral_code: string;
          total_booking_volume: number;
        };
        Insert: {
          created_at?: string;
          num_bookings_using_code?: number;
          num_sign_ups_using_code?: number;
          owner_id: string;
          referral_code: string;
          total_booking_volume?: number;
        };
        Update: {
          created_at?: string;
          num_bookings_using_code?: number;
          num_sign_ups_using_code?: number;
          owner_id?: string;
          referral_code?: string;
          total_booking_volume?: number;
        };
        Relationships: [
          {
            foreignKeyName: "referral_codes_owner_id_user_id_fk";
            columns: ["owner_id"];
            isOneToOne: false;
            referencedRelation: "user";
            referencedColumns: ["id"];
          },
        ];
      };
      referral_earnings: {
        Row: {
          cashback_earned: number;
          created_at: string;
          earning_status: SupabaseDatabase["public"]["Enums"]["earning_status"];
          id: number;
          offer_id: number;
          referee_id: string;
          referral_code: string;
        };
        Insert: {
          cashback_earned: number;
          created_at?: string;
          earning_status?: SupabaseDatabase["public"]["Enums"]["earning_status"];
          id?: number;
          offer_id: number;
          referee_id: string;
          referral_code: string;
        };
        Update: {
          cashback_earned?: number;
          created_at?: string;
          earning_status?: SupabaseDatabase["public"]["Enums"]["earning_status"];
          id?: number;
          offer_id?: number;
          referee_id?: string;
          referral_code?: string;
        };
        Relationships: [
          {
            foreignKeyName: "referral_earnings_offer_id_offers_id_fk";
            columns: ["offer_id"];
            isOneToOne: false;
            referencedRelation: "offers";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "referral_earnings_referee_id_user_id_fk";
            columns: ["referee_id"];
            isOneToOne: false;
            referencedRelation: "user";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "referral_earnings_referral_code_referral_codes_referral_code_fk";
            columns: ["referral_code"];
            isOneToOne: false;
            referencedRelation: "referral_codes";
            referencedColumns: ["referral_code"];
          },
        ];
      };
      requests: {
        Row: {
          check_in: string;
          check_out: string;
          confirmation_sent_at: string;
          created_at: string;
          has_approved: boolean;
          have_sent_follow_up: boolean;
          id: number;
          location: string;
          max_total_price: number;
          min_num_bedrooms: number | null;
          min_num_beds: number | null;
          note: string | null;
          num_guests: number;
          property_type:
            | SupabaseDatabase["public"]["Enums"]["property_type"]
            | null;
          resolved_at: string | null;
          user_id: string;
        };
        Insert: {
          check_in: string;
          check_out: string;
          confirmation_sent_at?: string;
          created_at?: string;
          has_approved?: boolean;
          have_sent_follow_up?: boolean;
          id?: number;
          location: string;
          max_total_price: number;
          min_num_bedrooms?: number | null;
          min_num_beds?: number | null;
          note?: string | null;
          num_guests?: number;
          property_type?:
            | SupabaseDatabase["public"]["Enums"]["property_type"]
            | null;
          resolved_at?: string | null;
          user_id: string;
        };
        Update: {
          check_in?: string;
          check_out?: string;
          confirmation_sent_at?: string;
          created_at?: string;
          has_approved?: boolean;
          have_sent_follow_up?: boolean;
          id?: number;
          location?: string;
          max_total_price?: number;
          min_num_bedrooms?: number | null;
          min_num_beds?: number | null;
          note?: string | null;
          num_guests?: number;
          property_type?:
            | SupabaseDatabase["public"]["Enums"]["property_type"]
            | null;
          resolved_at?: string | null;
          user_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: "requests_user_id_user_id_fk";
            columns: ["user_id"];
            isOneToOne: false;
            referencedRelation: "user";
            referencedColumns: ["id"];
          },
        ];
      };
      session: {
        Row: {
          expires: string;
          sessionToken: string;
          userId: string;
        };
        Insert: {
          expires: string;
          sessionToken: string;
          userId: string;
        };
        Update: {
          expires?: string;
          sessionToken?: string;
          userId?: string;
        };
        Relationships: [
          {
            foreignKeyName: "session_userId_user_id_fk";
            columns: ["userId"];
            isOneToOne: false;
            referencedRelation: "user";
            referencedColumns: ["id"];
          },
        ];
      };
      user: {
        Row: {
          email: string;
          emailVerified: string | null;
          id: string;
          image: string | null;
          name: string | null;
          password: string | null;
          phone_number: string | null;
          referral_code_used: string | null;
          referral_tier: SupabaseDatabase["public"]["Enums"]["referral_tier"];
          role: SupabaseDatabase["public"]["Enums"]["role"];
          username: string | null;
        };
        Insert: {
          email: string;
          emailVerified?: string | null;
          id: string;
          image?: string | null;
          name?: string | null;
          password?: string | null;
          phone_number?: string | null;
          referral_code_used?: string | null;
          referral_tier?: SupabaseDatabase["public"]["Enums"]["referral_tier"];
          role?: SupabaseDatabase["public"]["Enums"]["role"];
          username?: string | null;
        };
        Update: {
          email?: string;
          emailVerified?: string | null;
          id?: string;
          image?: string | null;
          name?: string | null;
          password?: string | null;
          phone_number?: string | null;
          referral_code_used?: string | null;
          referral_tier?: SupabaseDatabase["public"]["Enums"]["referral_tier"];
          role?: SupabaseDatabase["public"]["Enums"]["role"];
          username?: string | null;
        };
        Relationships: [];
      };
      verificationToken: {
        Row: {
          expires: string;
          identifier: string;
          token: string;
        };
        Insert: {
          expires: string;
          identifier: string;
          token: string;
        };
        Update: {
          expires?: string;
          identifier?: string;
          token?: string;
        };
        Relationships: [];
      };
    };
    Views: {
      [_ in never]: never;
    };
    Functions: {
      [_ in never]: never;
    };
    Enums: {
      earning_status: "pending" | "paid" | "cancelled";
      host_type: "airbnb" | "direct" | "vrbo" | "other";
      property_amenities:
        | "Wifi"
        | "TV"
        | "Kitchen"
        | "Washer"
        | "Free parking on premises"
        | "Paid parking on premises"
        | "Air conditioning"
        | "Dedicated workspace";
      property_safety_items:
        | "Smoke alarm"
        | "First aid kit"
        | "Fire extinguisher"
        | "Carbon monoxide alarm";
      property_standout_amenities:
        | "Pool"
        | "Hot tub"
        | "Patio"
        | "BBQ grill"
        | "Outdoor dining area"
        | "Fire pit"
        | "Pool table"
        | "Indoor fireplace"
        | "Piano"
        | "Exercise equipment"
        | "Lake access"
        | "Beach access"
        | "Ski-in/Ski-out"
        | "Outdoor shower";
      property_type:
        | "house"
        | "guesthouse"
        | "apartment"
        | "room"
        | "townhouse";
      referral_tier: "Partner" | "Ambassador";
      role: "guest" | "host" | "admin";
    };
    CompositeTypes: {
      [_ in never]: never;
    };
  };
};

export type Tables<
  PublicTableNameOrOptions extends
    | keyof (SupabaseDatabase["public"]["Tables"] &
        SupabaseDatabase["public"]["Views"])
    | { schema: keyof SupabaseDatabase },
  TableName extends PublicTableNameOrOptions extends {
    schema: keyof SupabaseDatabase;
  }
    ? keyof (SupabaseDatabase[PublicTableNameOrOptions["schema"]]["Tables"] &
        SupabaseDatabase[PublicTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = PublicTableNameOrOptions extends { schema: keyof SupabaseDatabase }
  ? (SupabaseDatabase[PublicTableNameOrOptions["schema"]]["Tables"] &
      SupabaseDatabase[PublicTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R;
    }
    ? R
    : never
  : PublicTableNameOrOptions extends keyof (SupabaseDatabase["public"]["Tables"] &
        SupabaseDatabase["public"]["Views"])
    ? (SupabaseDatabase["public"]["Tables"] &
        SupabaseDatabase["public"]["Views"])[PublicTableNameOrOptions] extends {
        Row: infer R;
      }
      ? R
      : never
    : never;

export type TablesInsert<
  PublicTableNameOrOptions extends
    | keyof SupabaseDatabase["public"]["Tables"]
    | { schema: keyof SupabaseDatabase },
  TableName extends PublicTableNameOrOptions extends {
    schema: keyof SupabaseDatabase;
  }
    ? keyof SupabaseDatabase[PublicTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = PublicTableNameOrOptions extends { schema: keyof SupabaseDatabase }
  ? SupabaseDatabase[PublicTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I;
    }
    ? I
    : never
  : PublicTableNameOrOptions extends keyof SupabaseDatabase["public"]["Tables"]
    ? SupabaseDatabase["public"]["Tables"][PublicTableNameOrOptions] extends {
        Insert: infer I;
      }
      ? I
      : never
    : never;

export type TablesUpdate<
  PublicTableNameOrOptions extends
    | keyof SupabaseDatabase["public"]["Tables"]
    | { schema: keyof SupabaseDatabase },
  TableName extends PublicTableNameOrOptions extends {
    schema: keyof SupabaseDatabase;
  }
    ? keyof SupabaseDatabase[PublicTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = PublicTableNameOrOptions extends { schema: keyof SupabaseDatabase }
  ? SupabaseDatabase[PublicTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U;
    }
    ? U
    : never
  : PublicTableNameOrOptions extends keyof SupabaseDatabase["public"]["Tables"]
    ? SupabaseDatabase["public"]["Tables"][PublicTableNameOrOptions] extends {
        Update: infer U;
      }
      ? U
      : never
    : never;

export type Enums<
  PublicEnumNameOrOptions extends
    | keyof SupabaseDatabase["public"]["Enums"]
    | { schema: keyof SupabaseDatabase },
  EnumName extends PublicEnumNameOrOptions extends {
    schema: keyof SupabaseDatabase;
  }
    ? keyof SupabaseDatabase[PublicEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = PublicEnumNameOrOptions extends { schema: keyof SupabaseDatabase }
  ? SupabaseDatabase[PublicEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : PublicEnumNameOrOptions extends keyof SupabaseDatabase["public"]["Enums"]
    ? SupabaseDatabase["public"]["Enums"][PublicEnumNameOrOptions]
    : never;
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/types/supabase.message.ts</div>
<pre><code>
import { type SupabaseDatabase } from "./supabase";

export type MessageDbType =
  SupabaseDatabase["public"]["Tables"]["messages"]["Row"];
</code></pre>
</div>
<div class='section'>
<h2 class='section-title'>UI Components</h2>
<div class='file'>
<div class='file-name'>./src/components/ui/popover.tsx</div>
<pre><code>
import * as React from "react";
import * as PopoverPrimitive from "@radix-ui/react-popover";

import { cn } from "@/utils/utils";

const Popover = PopoverPrimitive.Root;

const PopoverTrigger = PopoverPrimitive.Trigger;

const PopoverAnchor = PopoverPrimitive.Anchor;

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content> & {
    dontAnimate?: boolean;
  }
>(
  (
    {
      className,
      align = "center",
      sideOffset = 4,
      dontAnimate = false,
      ...props
    },
    ref,
  ) => (
    <div className="relative z-50">
      <PopoverPrimitive.Content
        ref={ref}
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "w-72 overflow-clip rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none",
          !dontAnimate &&
            "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          className,
        )}
        {...props}
      />
    </div>
  ),
);
PopoverContent.displayName = PopoverPrimitive.Content.displayName;

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor };
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/components/ui/form.tsx</div>
<pre><code>
import type * as LabelPrimitive from "@radix-ui/react-label";
import { Slot } from "@radix-ui/react-slot";
import * as React from "react";
import {
  Controller,
  FormProvider,
  useFormContext,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form";

import { Label } from "@/components/ui/label";
import { cn } from "@/utils/utils";
import ErrorMsg from "./ErrorMsg";

const Form = FormProvider;

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName;
};

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue,
);

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  );
};

type FormItemContextValue = {
  id: string;
};

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue,
);

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId();

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("", className)} {...props} />
    </FormItemContext.Provider>
  );
});
FormItem.displayName = "FormItem";

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext);
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>");
  }

  const itemContext = React.useContext(FormItemContext);
  const { getFieldState, formState } = useFormContext();
  const fieldState = getFieldState(fieldContext.name, formState);

  const { id } = itemContext;

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  };
};

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { formItemId } = useFormField();

  return (
    <Label
      ref={ref}
      className={cn(
        "text-muted-foreground",
        // error ? 'text-destructive' : 'text-muted-foreground',
        className,
      )}
      htmlFor={formItemId}
      {...props}
    />
  );
});
FormLabel.displayName = "FormLabel";

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } =
    useFormField();

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  );
});
FormControl.displayName = "FormControl";

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField();

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  );
});
FormDescription.displayName = "FormDescription";

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>((props, ref) => {
  const { error, formMessageId } = useFormField();
  const body = error ? String(error.message) : "";

  return (
    <ErrorMsg ref={ref} id={formMessageId} className="mt-0.5" {...props}>
      {body}
    </ErrorMsg>
  );
});
FormMessage.displayName = "FormMessage";

export {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
  useFormField,
};
</code></pre>
</div>
<div class='section'>
<h2 class='section-title'>Email & Notifications</h2>
<div class='file'>
<div class='file-name'>./src/server/server-utils.ts</div>
<pre><code>
import { render } from "@react-email/render";
import nodemailler, { type TransportOptions } from "nodemailer";
import { env } from "@/env";
import { type ReactElement } from "react";
import { Twilio } from "twilio";
import { db } from "./db";
import { waitUntil } from "@vercel/functions";
import { formatCurrency, getNumNights, plural } from "@/utils/utils";
import axiosRetry from "axios-retry";
import {
  and,
  between,
  eq,
  exists,
  gte,
  inArray,
  isNotNull,
  isNull,
  lte,
  notExists,
  or,
  sql,
  type SQL,
} from "drizzle-orm";
import {
  type NewProperty,
  type Property,
  type User,
  type Request,
  type RequestsToBook,
  bookedDates,
  groupInvites,
  groupMembers,
  groups,
  hostTeamInvites,
  hostTeamMembers,
  properties,
  offers,
  users,
  hostReferralDiscounts,
  referralCodes,
  requests,
  rejectedRequests,
  hostTeams,
  requestsToBook,
  hostProfiles,
} from "./db/schema";
import { getAddress, getCoordinates } from "./google-maps";
import axios from "axios";
import { HttpsProxyAgent } from "https-proxy-agent";
import * as cheerio from "cheerio";
import { sendSlackMessage } from "./slack";
import { HOST_MARKUP, TRAVELER_MARKUP } from "@/utils/constants";
import {
  HostRequestsPageData,
  HostRequestsPageOfferData,
} from "./api/routers/propertiesRouter";
import { Session } from "next-auth";
import { calculateTotalTax } from "@/utils/payment-utils/taxData";
import {
  scrapePage,
  serpPageSchema,
  transformSearchResult,
} from "./external-listings-scraping/airbnbScraper";
import { getSerpUrl } from "./external-listings-scraping/airbnbScraper";
import { createStripeConnectId } from "@/utils/stripe-utils";

export const proxyAgent = new HttpsProxyAgent(env.PROXY_URL);

export const axiosWithRetry = axios.create({
  httpsAgent: proxyAgent,
});

axiosRetry(axiosWithRetry, {
  retries: 3,

  retryDelay: (retryCount) =>
    retryCount * 1000 /* Wait 1s, 2s, 3s between retries*/,

  retryCondition: (error) => {
    // Retry on knowing errors and any 5xx errors
    return (
      error.code === "EPROTO" ||
      error.code === "ERR_BAD_RESPONSE" ||
      (error.response?.status !== undefined && error.response.status >= 500)
    );
  },
});

export async function urlScrape(url: string) {
  return await axios
    .get<string>(url, { httpsAgent: proxyAgent, responseType: "text" })
    .then((res) => res.data)
    .then(cheerio.load);
}

// List of user agents to rotate
const userAgents = [
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.102 Safari/537.36",
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.3 Safari/605.1.15",
  "Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko",
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36",
  "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:88.0) Gecko/20100101 Firefox/88.0",
];

// Function to get a random user agent
function getRandomUserAgent() {
  return userAgents[Math.floor(Math.random() * userAgents.length)];
}

export async function scrapeUrlLikeHuman(url: string) {
  return await axios
    .get<string>(url, {
      httpsAgent: proxyAgent,
      responseType: "text",
      headers: {
        "User-Agent": getRandomUserAgent(),
      },
      timeout: 10000,
    })
    .then((res) => res.data)
    .then(cheerio.load);
}

export async function scrapeUrl(url: string) {
  return await axios
    .get<string>(url, { httpsAgent: proxyAgent, responseType: "text" })
    .then((res) => res.data)
    .then(cheerio.load);
}

const transporter = nodemailler.createTransport({
  host: env.SMTP_HOST,
  port: env.SMTP_PORT,
  // debug: true,
  auth: {
    user: env.SMTP_USER,
    pass: env.SMTP_PASSWORD,
  },
} as TransportOptions);

const twilio = new Twilio(env.TWILIO_ACCOUNT_SID, env.TWILIO_AUTH_TOKEN);

export async function sendEmail({
  to,
  subject,
  content,
}: {
  to: string;
  subject: string;
  content: ReactElement;
}) {
  return await new Promise((resolve, reject) => {
    transporter.sendMail(
      {
        from: env.EMAIL_FROM,
        to,
        subject,
        html: render(content),
      },
      (err, info) => {
        if (err) {
          reject(err);
        } else {
          resolve(info);
        }
      },
    );
  });
}

export async function addUserToGroups(user: Pick<User, "email" | "id">) {
  // get the groups they were invited to
  const groupIds = await db.query.groupInvites
    .findMany({
      where: eq(groupInvites.inviteeEmail, user.email),
      columns: { groupId: true },
    })
    .then((res) => res.map((invite) => invite.groupId));

  if (groupIds.length === 0) return;

  await db.transaction(async (tx) => {
    // add user to groups
    await tx
      .insert(groupMembers)
      .values(groupIds.map((groupId) => ({ groupId, userId: user.id })));

    // delete invites
    await tx
      .delete(groupInvites)
      .where(
        and(
          inArray(groupInvites.groupId, groupIds),
          eq(groupInvites.inviteeEmail, user.email),
        ),
      );
  });
}

export async function sendTextToHostTeamMembers({
  hostTeamId,
  message,
}: {
  hostTeamId: number;
  message: string;
}) {
  const hostTeamMembers = await db.query.hostTeams.findMany({
    where: eq(hostTeams.id, hostTeamId),
    with: {
      members: {
        with: {
          user: {
            columns: { phoneNumber: true },
          },
        },
      },
    },
  });
  const hostTeamMemberPhoneNumbers = hostTeamMembers.flatMap((member) =>
    member.members.map((m) => m.user.phoneNumber),
  );

  await Promise.all(
    hostTeamMemberPhoneNumbers.map((phoneNumber) =>
      sendText({ to: phoneNumber!, content: message }),
    ),
  );
}

export async function sendText({
  to,
  content,
}: {
  to: string;
  content: string;
}) {
  const response = await twilio.messages.create({
    body: content,
    from: env.TWILIO_FROM,
    to,
  });
  return response;
}

export async function sendScheduledText({
  to,
  content,
  sendAt,
}: {
  to: string;
  content: string;
  sendAt: Date;
}) {
  const response = await twilio.messages.create({
    body: content,
    from: env.TWILIO_FROM,
    to,
    sendAt,
    messagingServiceSid: "MG7f313e1063abc277e6503fd9c9f3ef07",
    scheduleType: "fixed",
  });
  return response;
}

export async function sendWhatsApp({
  templateId,
  to,
  propertyName,
  propertyAddress,
  url,
  checkIn,
  checkOut,
  numRequests,
}: {
  templateId: string;
  to: string;
  propertyName?: string;
  propertyAddress?: string;
  url?: string;
  checkIn?: Date;
  checkOut?: Date;
  numRequests?: number;
}) {
  let contentVariables: Record<number, string | undefined> = {};

  // Set content variables based on template ID
  if (
    templateId === "HXd5256ff10d6debdf70a13d70504d39d5" ||
    templateId === "HXb293923af34665e7eefc81be0579e5db"
  ) {
    contentVariables = {
      1: propertyName,
      2: propertyAddress,
      3: checkIn?.toISOString(),
      4: checkOut?.toISOString(), //is this a problem?
    };

    if (templateId === "HXd5256ff10d6debdf70a13d70504d39d5") {
      contentVariables[5] = url;
    }
  } else if (templateId === "HX82b075be3d74f02e45957a453fd48cef") {
    if (numRequests) {
      contentVariables = {
        1:
          numRequests > 1
            ? `${numRequests} unconfirmed requests`
            : `${numRequests} unconfirmed request`,
        2:
          numRequests > 1
            ? `${numRequests} requests`
            : `${numRequests} request`,
        3: url,
      };
    }
  } else if (templateId === "HX08c870ee406c7ef4ff763917f0b3c411") {
    contentVariables = {
      1: propertyAddress,
    };
  }

  // Create Twilio message payload
  const twilioMessagePayload = {
    contentSid: templateId,
    from: `whatsapp:${env.TWILIO_FROM}`,
    messagingServiceSid: "MG7f313e1063abc277e6503fd9c9f3ef07",
    to: `whatsapp:${to}`,
    contentVariables: JSON.stringify(contentVariables),
  };

  // Send the Twilio message
  const response = await twilio.messages.create(twilioMessagePayload);
  return response;
}

export async function getGroupOwnerId(groupId: number) {
  return await db.query.groups
    .findFirst({
      columns: { ownerId: true },
      where: eq(groups.id, groupId),
    })
    .then((res) => res?.ownerId);
}

export async function getHostTeamOwnerId(hostTeamId: number) {
  return await db.query.hostTeams
    .findFirst({
      columns: { ownerId: true },
      where: eq(groups.id, hostTeamId),
    })
    .then((res) => res?.ownerId);
}

export async function addProperty({
  property,
  isAdmin,
  userEmail,
  hostTeamId,
}: {
  userEmail?: string;
  hostTeamId: number;
  isAdmin: boolean;
  property: Omit<
    NewProperty,
    | "id"
    | "hostTeamId"
    | "latLngPoint"
    | "city"
    | "county"
    | "stateName"
    | "stateCode"
    | "country"
    | "countryISO"
    | "bookItNowEnabled"
    | "discountTiers"
  > & {
    latLngPoint?: { x: number; y: number }; // make optional
  };
} & (
  | { isAdmin?: boolean; userEmail: string }
  | { isAdmin: true; userEmail?: undefined }
)) {
  let lat = property.latLngPoint?.y;
  let lng = property.latLngPoint?.x;

  if (!lat || !lng) {
    // get lat lng if not provided
    const { location } = await getCoordinates(property.address);
    if (!location) throw new Error("Could not get coordinates for address");
    lat = location.lat;
    lng = location.lng;
  }

  const { city, country, countryISO, county, stateCode, stateName } =
    await getAddress({ lat, lng });

  const propertyValues = {
    ...property,
    hostTeamId,
    city,
    county,
    stateCode,
    stateName,
    country,
    countryISO,
    latLngPoint: createLatLngGISPoint({ lat, lng }),
  };

  const [insertedProperty] = await db
    .insert(properties)
    .values(propertyValues)
    .returning({ id: properties.id });

  await sendSlackMessage({
    isProductionOnly: true,
    channel: "host-bot",
    text: [
      `*New property added: ${property.name} in ${property.address}*
     by ${isAdmin ? "an Tramona admin" : userEmail}`,
    ].join("\n"),
  });
  return insertedProperty!.id;
}

export async function sendTextToHost({
  matchingProperties,
  request,
}: {
  matchingProperties: { id: number; hostTeamId: number }[];
  request: Pick<Request, "checkIn" | "checkOut" | "maxTotalPrice" | "location">;
}) {
  const uniqueHostTeamIds = Array.from(
    new Set(matchingProperties.map((property) => property.hostTeamId)),
  );
  const numHostPropertiesPerRequest = matchingProperties.reduce(
    (acc, property) => {
      if (property.hostTeamId) {
        acc[property.hostTeamId] = (acc[property.hostTeamId] ?? 0) + 1;
      }
      return acc;
    },
    {} as Record<number, number>,
  );

  waitUntil(
    Promise.all(
      uniqueHostTeamIds.filter(Boolean).map(async (hostTeamId) => {
        const hostTeamOwner = await db.query.hostTeams
          .findFirst({
            where: eq(hostTeams.id, hostTeamId),
            with: {
              owner: {
                columns: { name: true, email: true, phoneNumber: true },
              },
            },
          })
          .then((res) => res?.owner);

        if (!hostTeamOwner?.phoneNumber) return;

        const numberOfNights = getNumNights(request.checkIn, request.checkOut);

        await sendText({
          to: hostTeamOwner.phoneNumber,
          content: `Tramona: There is a request for ${formatCurrency(
            request.maxTotalPrice / numberOfNights,
          )} per night for ${plural(numberOfNights, "night")} in ${
            request.location
          }. You have ${plural(
            numHostPropertiesPerRequest[hostTeamId] ?? 0,
            "eligible property",
            "eligible properties",
          )}. Please click here to make a match: ${env.NEXTAUTH_URL}/host/requests`,
        });

        //TODO SEND WHATSAPP MESSAGE
      }),
    ),
  );
}

export async function getRequestsForProperties(
  hostProperties: Property[],
  //{
  // id: number;
  // propertyStaus: string;
  // latLngPoint: { x: number; y: number };
  // priceRestriction: number | null;
  //}
  //[],
  { tx = db } = {},
) {
  const requestIsNearProperties: SQL[] = [];
  // let priceRestrictionsSQL: SQL[] | undefined[] = [sql`FALSE`];
  const propertyToRequestMap: {
    property: Property & { taxAvailable: boolean };
    request: Request & {
      traveler: Pick<
        User,
        | "firstName"
        | "lastName"
        | "name"
        | "image"
        | "location"
        | "about"
        | "dateOfBirth"
      >;
    };
  }[] = [];

  for (const property of hostProperties) {
    const requestIsNearProperty = sql`
      ST_DWithin(
        ST_Transform(ST_SetSRID(requests.lat_lng_point, 4326), 3857),
        ST_Transform(ST_SetSRID(ST_MakePoint(${property.latLngPoint.x}, ${property.latLngPoint.y}), 4326), 3857),
        requests.radius * 1609.34
      )
    `;
    //  const numberOfNights = sql`DATE_PART('day', requests.check_out::timestamp - requests.check_in::timestamp)`;

    //   const priceRestrictionSQL = sql`
    //     ${property.priceRestriction} IS NULL OR
    //     (
    //       requests.max_total_price IS NOT NULL AND
    //       ${property.priceRestriction} >= (requests.max_total_price / DATE_PART('day', requests.check_out::timestamp - requests.check_in::timestamp)) * 1.15
    //     )
    // `;
    requestIsNearProperties.push(requestIsNearProperty);
    const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);

    const requestsForProperty = await tx.query.requests.findMany({
      where: and(
        requestIsNearProperty,
        gte(requests.checkIn, new Date()),
        gte(requests.createdAt, twentyFourHoursAgo),
        notExists(
          db
            .select()
            .from(offers)
            .where(
              and(
                eq(offers.requestId, requests.id),
                exists(
                  db
                    .select()
                    .from(properties)
                    .where(
                      and(
                        eq(properties.id, offers.propertyId),
                        eq(properties.hostTeamId, property.hostTeamId),
                      ),
                    ),
                ),
              ),
            ),
        ),
        notExists(
          db
            .select()
            .from(rejectedRequests)
            .where(
              and(
                eq(rejectedRequests.requestId, requests.id),
                eq(rejectedRequests.hostTeamId, property.hostTeamId),
              ),
            ),
        ),
      ),
      with: {
        madeByGroup: {
          with: {
            owner: {
              columns: {
                image: true,
                name: true,
                firstName: true,
                lastName: true,
                location: true,
                about: true,
                dateOfBirth: true,
              },
            },
          },
        },
      },
    });

    // Store the matched requests along with the property
    for (const request of requestsForProperty) {
      //here we can  update each of the reque
      const traveler = request.madeByGroup.owner;
      const taxInfo = calculateTotalTax(property);

      propertyToRequestMap.push({
        property: {
          ...property,
          taxAvailable: taxInfo.length > 0, //// come back here
        },
        request: {
          ...request,
          traveler, // Include traveler info
        },
      });
    }
    // priceRestrictionsSQL.push(priceRestrictionSQL);
  }
  return propertyToRequestMap;
}

export async function getPropertiesForRequest(
  req: {
    // lat: number;
    // lng: number;
    radius: number;
    location: string;
    checkIn: Date;
    checkOut: Date;
    maxTotalPrice: number;
    id: number;
    latLngPoint: { x: number; y: number };
    // propertyLatLngPoint?: Property["latLngPoint"];
  },
  { tx = db } = {},
) {
  let propertyIsNearRequest: SQL | undefined = sql`FALSE`;

  //WAITING FOR MAP PIN TO MERGE IN TO TEST THIS
  // if (req.lat != null && req.lng != null && req.radius != null) {
  // Convert radius from miles to degrees (approximate)
  const radiusInDegrees = req.radius * 1609.34;

  propertyIsNearRequest = sql`
    ST_DWithin(
      ST_Transform(ST_SetSRID(properties.lat_lng_point, 4326), 3857),
      ST_Transform(ST_SetSRID(ST_MakePoint(${req.latLngPoint.x}, ${req.latLngPoint.y}), 4326), 3857),
      ${radiusInDegrees}
    )
  `;
  // } else {
  //   const coordinates = await getCoordinates(req.location);
  //   if (coordinates.bounds) {
  //     console.log(
  //       "bounds",
  //       coordinates.bounds,
  //       req.location,
  //       req.maxTotalPrice,
  //     );
  //     const { northeast, southwest } = coordinates.bounds;
  //     propertyIsNearRequest = sql`
  //       ST_Within(
  //         properties.lat_lng_point,
  //         ST_MakeEnvelope(
  //           ${southwest.lng}, ${southwest.lat},
  //           ${northeast.lng}, ${northeast.lat},
  //           4326
  //         )
  //       )
  //     `;
  //   } else if (coordinates.location) {
  //     const radiusInMiles = 10;
  //     const radiusInDegrees = radiusInMiles / 69.0;

  //     propertyIsNearRequest = sql`
  //       ST_DWithin(
  //         properties.lat_lng_point,
  //         ST_SetSRID(ST_MakePoint(${coordinates.location.lng}, ${coordinates.location.lat}), 4326),
  //         ${radiusInDegrees}
  //       )
  //     `;
  //   }
  // }

  const propertyisAvailable = notExists(
    tx
      .select()
      .from(bookedDates)
      .where(
        and(
          eq(bookedDates.propertyId, properties.id),
          between(bookedDates.date, req.checkIn, req.checkOut),
        ),
      ),
  );

  const numberOfNights = getNumNights(req.checkIn, req.checkOut);

  return await tx.query.properties.findMany({
    where: and(
      propertyIsNearRequest,
      propertyisAvailable,
      or(
        isNull(properties.priceRestriction), // Include properties with no price restriction
        and(
          isNotNull(properties.priceRestriction),
          lte(
            properties.priceRestriction,
            Math.round((req.maxTotalPrice / numberOfNights) * 1.15),
          ),
        ),
      ),
    ),
    columns: {
      id: true,
      hostTeamId: true,
      autoOfferEnabled: true,
      discountTiers: true,
      originalListingId: true,
    },
  });
}

export async function getAdminId() {
  return await db.query.users
    .findFirst({ where: eq(users.email, "info@tramona.com") })
    .then((res) => res!.id);
}

type HospitableCalendarResponse = {
  data: {
    dates: {
      date: string;
      price: {
        amount: number;
        currency: string;
      };
      availability: {
        available: boolean;
      };
    }[];
  };
};

type HostawayPriceResponse = {
  result: {
    totalBasePriceBeforeFees: number;
  };
};

export async function getPropertyCalendar(propertyId: string) {
  const now = new Date();
  const firstStartDate = now.toISOString().split("T")[0];
  const firstEndDate = new Date(now);
  firstEndDate.setDate(firstEndDate.getDate() + 365);
  const firstEndDateString = firstEndDate.toISOString().split("T")[0];

  const secondStartDate = new Date(firstEndDate);
  secondStartDate.setDate(secondStartDate.getDate() + 1);
  const secondStartDateString = secondStartDate.toISOString().split("T")[0];

  const secondEndDate = new Date(now);
  secondEndDate.setDate(now.getDate() + 539);
  const secondEndDateString = secondEndDate.toISOString().split("T")[0];

  // Construct the URL with query params for logging
  const firstBatchUrl = `https://connect.hospitable.com/api/v1/listings/${propertyId}/calendar?start_date=${firstStartDate}&end_date=${firstEndDateString}`;
  const secondBatchUrl = `https://connect.hospitable.com/api/v1/listings/${propertyId}/calendar?start_date=${secondStartDateString}&end_date=${secondEndDateString}`;

  // Log the URLs
  console.log("First request URL:", firstBatchUrl);
  console.log("Second request URL:", secondBatchUrl);

  // Make the requests
  const firstBatch = await axios.get<HospitableCalendarResponse>(
    firstBatchUrl,
    {
      headers: {
        Authorization: `Bearer ${process.env.HOSPITABLE_API_KEY}`,
      },
    },
  );

  const secondBatch = await axios.get<HospitableCalendarResponse>(
    secondBatchUrl,
    {
      headers: {
        Authorization: `Bearer ${process.env.HOSPITABLE_API_KEY}`,
      },
    },
  );

  const combinedPricingAndCalendarResponse = [
    ...firstBatch.data.data.dates,
    ...secondBatch.data.data.dates,
  ];
  return combinedPricingAndCalendarResponse;
}

export async function getPropertyOriginalPrice(
  property: Pick<
    Property,
    "hospitableListingId" | "originalListingPlatform" | "originalListingId"
  >,
  params: {
    checkIn: string;
    checkOut: string;
    numGuests: number;
  },
) {
  if (property.originalListingPlatform === "Hospitable") {
    const formattedCheckIn = new Date(params.checkIn)
      .toISOString()
      .split("T")[0];
    const formattedCheckOut = new Date(params.checkOut)
      .toISOString()
      .split("T")[0];
    const { data } = await axios.get<HospitableCalendarResponse>(
      `https://connect.hospitable.com/api/v1/listings/${property.hospitableListingId}/calendar`,
      {
        headers: {
          Authorization: `Bearer ${process.env.HOSPITABLE_API_KEY}`,
        },
        params: {
          start_date: formattedCheckIn,
          end_date: formattedCheckOut,
        },
      },
    );
    const averagePrice =
      data.data.dates.reduce((acc, date) => {
        return acc + date.price.amount;
      }, 0) / data.data.dates.length;
    return averagePrice;
  } else if (property.originalListingPlatform === "Hostaway") {
    const { data } = await axios.get<HostawayPriceResponse>(
      `https://api.hostaway.com/v1/properties/${property.originalListingId}/calendar/priceDetails`,
      {
        headers: {
          Authorization: `Bearer ${process.env.HOSTAWAY_API_KEY}`,
        },
        params,
      },
    );
    const totalBasePriceBeforeFees = data.result.totalBasePriceBeforeFees;
    return totalBasePriceBeforeFees;
  }
  // code for other options
}

export interface SeparatedData {
  normal: HostRequestsPageData[];
  outsidePriceRestriction: HostRequestsPageData[];
}

export interface RequestsPageOfferData {
  sent: HostRequestsPageOfferData[];
}

//update spread on every fetch to keep information updated
export async function updateTravelerandHostMarkup({
  offerTotalBasePriceBeforeFees,
  offerId,
}: {
  offerTotalBasePriceBeforeFees: number;
  offerId: number;
}) {
  console.log("offerTotalBasePriceBeforeFees", offerTotalBasePriceBeforeFees);
  const travelerPrice = Math.ceil(
    offerTotalBasePriceBeforeFees * TRAVELER_MARKUP,
  );
  const hostPay = Math.ceil(offerTotalBasePriceBeforeFees * HOST_MARKUP);
  console.log("travelerPrice", travelerPrice);
  await db
    .update(offers)
    .set({
      travelerOfferedPriceBeforeFees: travelerPrice,
      hostPayout: hostPay,
    })
    .where(and(eq(offers.id, offerId), isNull(offers.acceptedAt)));
}

export async function createHostReferral({
  userId,
  referralCodeUsed,
}: {
  userId: string;
  referralCodeUsed: string | null;
}) {
  console.log("this is the referral code ysed  ", referralCodeUsed);
  if (referralCodeUsed) {
    const isReferralUsed = await db.query.hostReferralDiscounts.findFirst({
      where: eq(hostReferralDiscounts.refereeUserId, userId),
    });
    console.log("about to return ", isReferralUsed);
    if (isReferralUsed) return;
    //find owner of the referral code
    const referrer = await db.query.referralCodes.findFirst({
      where: eq(referralCodes.referralCode, referralCodeUsed),
      columns: { ownerId: true },
    });
    //create host referral discount row
    if (referrer) {
      await db.insert(hostReferralDiscounts).values({
        referralCode: referralCodeUsed,
        ownerId: referrer.ownerId,
        refereeUserId: userId,
      });
    }
    //send an email or notification to the referrer
  }
}

function getRandomNormalDistribution(mean: number, stdDev: number): number {
  let u = 0,
    v = 0;
  while (u === 0) u = Math.random(); // Converting [0,1) to (0,1)
  while (v === 0) v = Math.random();
  let num = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
  num = num * stdDev + mean; // Scale to the desired mean and standard deviation
  return Math.round(num); // Round to nearest integer
}

function stripTimeFromDate(date: Date): Date {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate());
}

export function createNormalDistributionDates(
  numRanges: number,
): { checkIn: Date; checkOut: Date }[] {
  const dateRanges = [];

  for (let i = 0; i < numRanges; i++) {
    const today = new Date();
    const futureDate = new Date(
      today.getTime() + Math.random() * 90 * 24 * 60 * 60 * 1000,
    ); // Random date within next 90 days
    const startDate = stripTimeFromDate(new Date(futureDate));

    // Generate end date using a normal distribution with mean = 3 days and stdDev = 1 day
    let endDateOffset = getRandomNormalDistribution(3, 1);
    // Ensure endDateOffset is at least 1 day
    endDateOffset = Math.max(1, endDateOffset);

    const endDate = stripTimeFromDate(
      new Date(startDate.getTime() + endDateOffset * 24 * 60 * 60 * 1000),
    );

    dateRanges.push({
      checkIn: startDate,
      checkOut: endDate,
    });
  }

  return dateRanges;
}

export function createLatLngGISPoint({
  lat,
  lng,
}: {
  lat: number;
  lng: number;
}) {
  const latLngPoint = sql`ST_SetSRID(ST_MakePoint(${lng}, ${lat}), 4326)`;
  return latLngPoint;
}

/**
 * returns the distance in kilometers between two points
 */
export function haversineDistance(
  lat1: number,
  lon1: number,
  lat2: number,
  lon2: number,
) {
  const toRadians = (degrees: number) => degrees * (Math.PI / 180);

  const R = 3958.8; // Radius of the Earth in kilometers
  const dLat = toRadians(lat2 - lat1);
  const dLon = toRadians(lon2 - lon1);
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRadians(lat1)) *
      Math.cos(toRadians(lat2)) *
      Math.sin(dLon / 2) *
      Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c; // Distance in kilometers
}

export async function checkRequestsWithoutOffers() {
  const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);

  const requestsWithoutOffers = await db.query.requests.findMany({
    where: and(
      lte(requests.createdAt, twentyFourHoursAgo),
      eq(requests.notifiedNoOffers, false),
      notExists(
        db.select().from(offers).where(eq(offers.requestId, requests.id)),
      ),
    ),
    with: {
      madeByGroup: {
        with: {
          owner: {
            columns: {
              phoneNumber: true,
            },
          },
        },
      },
    },
  });

  for (const request of requestsWithoutOffers) {
    const travelerPhoneNumber = request.madeByGroup.owner.phoneNumber;

    if (travelerPhoneNumber) {
      await sendText({
        to: travelerPhoneNumber,
        content: `Tramona: Your request for ${request.location} for ${request.maxTotalPrice} didn't yield any offers in the last 24 hours. Consider submitting a new request with a different price range or a broader location to increase your chances of finding a match.`,
      });
    }

    await db
      .update(requests)
      .set({ notifiedNoOffers: true })
      .where(eq(requests.id, request.id));
  }

  return requestsWithoutOffers.length; // return whatever
}

/**
 * Even though most hosts might not have a team, the simplest way to implement teams is
 * to treat everything as a team, which means treating single hosts as teams of one.
 * This function creates that initial team of one for a host.
 */
export async function createInitialHostTeam(
  user: Pick<User, "id" | "name" | "username" | "email">,
) {
  const teamName = user.name ?? user.username ?? user.email;

  const teamId = await db
    .insert(hostTeams)
    .values({ ownerId: user.id, name: teamName })
    .returning()
    .then((res) => res[0]!.id);

  await db.insert(hostTeamMembers).values({
    hostTeamId: teamId,
    userId: user.id,
    role: "Admin Access",
  });

  return teamId;
}

export async function scrapeAirbnbInitialPageHelper({
  checkIn,
  checkOut,
  location,
  numGuests,
}: {
  checkIn: Date;
  checkOut: Date;
  location: string;
  numGuests: number;
}) {
  const serpUrl = getSerpUrl({
    checkIn: checkIn,
    checkOut: checkOut,
    location: location,
    numGuests: numGuests,
  });

  const numNights = getNumNights(checkIn, checkOut);

  const pageData = await scrapePage(serpUrl).then(async (unparsedData) => {
    return serpPageSchema.parse(unparsedData);
  });
  const searchResults = (
    await Promise.all(
      pageData.staysSearch.results.searchResults.map((searchResult) =>
        transformSearchResult({ searchResult, numNights, numGuests }),
      ),
    )
  ).filter(Boolean);

  // console.log("length of results:", searchResults.length);
  // console.log('result:', searchResults[0]);
  // const results = pageData.flatMap((data) => data.staysSearch.results.searchResults)
  return { data: pageData, res: searchResults };
}

export async function scrapeAirbnbPagesHelper({
  checkIn,
  checkOut,
  location,
  numGuests,
  cursors,
}: {
  checkIn: Date;
  checkOut: Date;
  location: string;
  numGuests: number;
  cursors: string[];
}) {
  const pageUrls = cursors.map((cursor) =>
    getSerpUrl({
      checkIn,
      checkOut,
      location,
      numGuests,
      cursor,
    }),
  );

  const numNights = getNumNights(checkIn, checkOut);

  return (await Promise.all(pageUrls.map(scrapePage)))
    .flatMap((data) => data.staysSearch.results.searchResults)
    .map((searchResult) =>
      transformSearchResult({ searchResult, numNights, numGuests }),
    )
    .filter(Boolean);
}

export async function getRequestsToBookForProperties(
  hostProperties: Property[],
  { user }: { user: Session["user"] },
  { tx = db } = {},
) {
  const propertyToRequestMap: {
    requestToBook: RequestsToBook & {
      traveler: Pick<
        User,
        "firstName" | "lastName" | "name" | "image" | "location" | "about"
      >;
      property: Property & { taxAvailable: boolean };
    };
  }[] = [];

  for (const property of hostProperties) {
    const requestsForProperty = await tx.query.requestsToBook.findMany({
      where: and(
        eq(requestsToBook.propertyId, property.id),
        eq(requestsToBook.userId, user.id),
        gte(requestsToBook.checkIn, new Date()),
      ),
      with: {
        madeByGroup: {
          with: {
            owner: {
              columns: {
                image: true,
                name: true,
                firstName: true,
                lastName: true,
                location: true,
                about: true,
              },
            },
          },
        },
      },
    });

    const { city, stateCode, country } = await getAddress({
      lat: property.latLngPoint.y,
      lng: property.latLngPoint.x,
    });

    const taxInfo = calculateTotalTax({ country, stateCode, city });
    console.log("taxInfo", taxInfo, city);

    for (const requestToBook of requestsForProperty) {
      const traveler = {
        name: requestToBook.madeByGroup.owner.name,
        image: requestToBook.madeByGroup.owner.image,
        firstName: requestToBook.madeByGroup.owner.firstName,
        lastName: requestToBook.madeByGroup.owner.lastName,
        location: requestToBook.madeByGroup.owner.location,
        about: requestToBook.madeByGroup.owner.about,
      };
      propertyToRequestMap.push({
        requestToBook: {
          ...requestToBook,
          traveler,
          property: {
            ...property,
            taxAvailable: taxInfo.length > 0 ? true : false, //// come back here
          },
        },
      });
    }
  }
  return propertyToRequestMap;
}

export async function addHostProfile({
  userId,
  curTeamId,
  hostawayApiKey,
  hostawayAccountId,
  hostawayBearerToken,
}: {
  userId: string;
  curTeamId: number;
  hostawayApiKey?: string;
  hostawayAccountId?: string;
  hostawayBearerToken?: string;
}) {
  const curUser = await db.query.users.findFirst({
    columns: { email: true, firstName: true, lastName: true },
    where: eq(users.id, userId),
  });
  if (curUser) {
    await db.insert(hostProfiles).values({
      userId,
      curTeamId: curTeamId,
      hostawayApiKey,
      hostawayAccountId,
      hostawayBearerToken,
    });

    await createStripeConnectId({ userId, userEmail: curUser.email });

    await sendSlackMessage({
      isProductionOnly: true,
      text: [
        "*Host Profile Created:*",
        `User ${curUser.firstName} ${curUser.lastName} has become a host`,
      ].join("\n"),
      channel: "host-bot",
    });
  }
}
</code></pre>
</div>
<div class='section'>
<h2 class='section-title'>Stripe Integration</h2>
<div class='file'>
<div class='file-name'>./src/utils/payment-utils/paymentBreakdown.ts</div>
<pre><code>
import { SUPERHOG_FEE_CENTS_PER_NIGHT } from "../constants";
import { TripCheckout } from "../../server/db/schema/tables/payments";
import { getTaxPercentage } from "@/utils/payment-utils/calculateTax";
import { Offer, Property } from "@/server/db/schema";
import type {
  PriceBreakdownOutput,
  PropertyAndTripParams,
} from "@/components/checkout/types";
import { getNumNights } from "../utils";

// -------------------------- 2 Different inputs for Breakdown payment  -------------------------
// -----METHOD 1. USING OFFER
export function breakdownPaymentByOffer( ///// USING OFFER
  offer: Pick<
    Offer,
    | "scrapeUrl"
    | "travelerOfferedPriceBeforeFees"
    | "datePriceFromAirbnb"
    | "checkIn"
    | "checkOut"
  > & {
    property: Pick<
      Property,
      | "originalNightlyPrice"
      | "city"
      | "county"
      | "stateName"
      | "stateCode"
      | "country"
    >;
  },
): PriceBreakdownOutput {
  const numNights = getNumNights(offer.checkIn, offer.checkOut);
  const isScraped = offer.scrapeUrl !== null;

  const taxPercentage = isScraped ? 0 : getTaxPercentage(offer.property);
  const superhogFee = isScraped ? 0 : numNights * SUPERHOG_FEE_CENTS_PER_NIGHT;
  const taxesPaid = Math.round(
    (offer.travelerOfferedPriceBeforeFees + superhogFee) * taxPercentage,
  );
  const totalBeforeStripeFee =
    offer.travelerOfferedPriceBeforeFees + superhogFee + taxesPaid;
  const stripeFee = getStripeFee(totalBeforeStripeFee);
  const totalTripAmount = totalBeforeStripeFee + stripeFee;
  console.log(totalTripAmount);

  const { originalNightlyPrice } = offer.property;

  const originalTotalBasePriceBeforeFees =
    offer.datePriceFromAirbnb ??
    (originalNightlyPrice ? originalNightlyPrice * numNights : null);
  let totalSavings = originalTotalBasePriceBeforeFees
    ? originalTotalBasePriceBeforeFees - totalTripAmount
    : 0; //// um hopefully not negative

  //if totalSavings is negative just make it zero dude
  if (totalSavings < 0) {
    console.log(totalSavings);
    totalSavings = 0;
  }

  return {
    totalTripAmount,
    taxesPaid,
    taxPercentage,
    superhogFee,
    stripeTransactionFee: stripeFee,
    totalSavings,
  };
}
//------METHOD 2. Using UnifiedCheckoutData ------------
export function breakdownPaymentByPropertyAndTripParams(
  propertyAndTripParams: PropertyAndTripParams,
): PriceBreakdownOutput {
  console.log(propertyAndTripParams.travelerPriceBeforeFees);
  const numNights = getNumNights(
    propertyAndTripParams.dates.checkIn,
    propertyAndTripParams.dates.checkOut,
  );
  const isScraped = propertyAndTripParams.property.originalListingUrl !== null;

  const taxPercentage = isScraped
    ? 0
    : getTaxPercentage(propertyAndTripParams.property);
  const superhogFee = isScraped ? 0 : numNights * SUPERHOG_FEE_CENTS_PER_NIGHT;
  const taxesPaid = Math.round(
    (propertyAndTripParams.travelerPriceBeforeFees + superhogFee) *
      taxPercentage,
  );

  const totalBeforeStripeFee =
    propertyAndTripParams.travelerPriceBeforeFees + superhogFee + taxesPaid;
  console.log(totalBeforeStripeFee);
  const stripeFee = getStripeFee(totalBeforeStripeFee);
  console.log(stripeFee);
  const totalTripAmount = Math.round(totalBeforeStripeFee + stripeFee);

  const { originalNightlyPrice } = propertyAndTripParams.property;

  const originalTotalBasePriceBeforeFees = originalNightlyPrice
    ? originalNightlyPrice * numNights
    : null;

  let totalSavings = originalTotalBasePriceBeforeFees
    ? originalTotalBasePriceBeforeFees - totalTripAmount
    : 0; //// um hopefully not negative

  //if totalSavings is negative just make it zero dude
  if (totalSavings < 0) {
    console.log(totalSavings);
    totalSavings = 0;
  }
  return {
    totalTripAmount,
    taxesPaid,
    taxPercentage,
    superhogFee,
    stripeTransactionFee: stripeFee,
    totalSavings,
  };
}

export function getServiceFee({
  tripCheckout,
}: {
  tripCheckout: Pick<TripCheckout, "superhogFee" | "stripeTransactionFee">;
}) {
  const serviceFee =
    tripCheckout.superhogFee + tripCheckout.stripeTransactionFee;
  return serviceFee;
}

export function getStripeFee(amount: number) {
  return Math.ceil(amount * 0.029 + 30);
}
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/utils/stripe-utils.ts</div>
<pre><code>
import { db } from "@/server/db";
import { trips, refundedPayments, users } from "@/server/db/schema";
import { eq } from "drizzle-orm";
import { env } from "@/env";
import Stripe from "stripe";

const stripeWithSecretKey = new Stripe(env.STRIPE_SECRET_KEY, {
  typescript: true,
});
const stripe = new Stripe(env.STRIPE_RESTRICTED_KEY_ALL);

//for functions that require alot code to be written after a stripe event
interface CreatePayHostTransfer {
  amount: number;
  destination: string;
  tripId: string;
}

export async function createPayHostTransfer({
  amount,
  destination,
  tripId,
}: CreatePayHostTransfer) {
  //we need to check to see if our balance is enought to pay the host, if not we need to top up the account
  const balance = await stripe.balance.retrieve();
  if (balance.instant_available && balance.instant_available.length > 0) {
    const availableBalance = balance.instant_available[0]!.amount;

    if (availableBalance < amount) {
      //we need to add a top up function here then continue with the transfer
      await stripe.topups.create({
        amount: amount - availableBalance,
        currency: "usd",
        description: "Top-up for week of May 31",
        statement_descriptor: "Weekly top-up",
      });
    }
    const transfer = await stripe.transfers.create({
      amount: amount, // amount in cents
      currency: "usd",
      destination: destination, // connected account ID
      // transfer_group: tripId,
      metadata: {
        trip_id: tripId,
        host_stripe_account_id: destination,
        transered_at: new Date().toISOString(),
      },
    });
    //update the trip to show that the host has been payed
    await db
      .update(trips)
      .set({ hostPayed: new Date() })
      .where(eq(trips.id, parseInt(tripId)));
    console.log("transfer created", transfer);
  }
}

export async function refundTripWithStripe({
  paymentIntentId,
  amount,
  metadata,
}: {
  paymentIntentId: string;
  amount: number;
  metadata: {
    tripId: number;
    propertyId: number;
    groupId: number;
    cancellationRefund: number;
    cancellationId: number;
    description: string;
  };
}) {
  const refund = await stripeWithSecretKey.refunds.create({
    payment_intent: paymentIntentId, // Or use charge: 'ch_123XYZ...'
    amount: amount,
    reason: "requested_by_customer", // Optional: Reason for the refund
    metadata: metadata,
  });

  const refundedPayment = await db.insert(refundedPayments).values({
    tripId: metadata.tripId,
    amountRefunded: amount,
    description: metadata.description,
  });
  console.log(refundedPayment);
  console.log(refund);
  return;
}

export async function createStripeConnectId({
  userId,
  userEmail,
}: {
  userId: string;
  userEmail: string;
}) {
  const res = await db.query.users.findFirst({
    columns: {
      firstName: true,
      lastName: true,
      stripeConnectId: true,
      chargesEnabled: true,
    },
    where: eq(users.id, userId),
  });
  if (!res?.stripeConnectId) {
    const stripeAccount = await stripeWithSecretKey.accounts.create({
      country: "US", //change this to the user country later
      email: userEmail,
      settings: {},
      controller: {
        losses: {
          payments: "application",
        },
        fees: {
          payer: "application",
        },
        stripe_dashboard: {
          type: "express",
        },
      },
      //charges_enabled: true,
      capabilities: {
        card_payments: { requested: true },
        transfers: { requested: true },
        tax_reporting_us_1099_k: { requested: true },
      },
      business_type: "individual",
      business_profile: {
        url: "https://tramona.com",
        mcc: "4722",
        product_description: "Travel and Tourism",
      },
      individual: {
        email: userEmail,
        first_name: res?.firstName ?? "",
      },
    });
    await db
      .update(users)
      .set({ stripeConnectId: stripeAccount.id })
      .where(eq(users.id, userId));

    return stripeAccount;
  } else {
    throw new Error("Stripe account already created");
  }
}
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/utils/webhook-functions/stripe-utils.ts</div>
<pre><code>
import { env } from "@/env";
import { db } from "@/server/db";
import { and, eq, or, sql } from "drizzle-orm";
import {
  groupMembers,
  groups,
  properties,
  requestsToBook,
  offers,
  trips,
  users,
  tripCheckouts,
} from "@/server/db/schema";
import Stripe from "stripe";
import { breakdownPaymentByPropertyAndTripParams } from "../payment-utils/paymentBreakdown";
import {
  captureTripPaymentWithoutSuperhog,
  sendEmailAndWhatsupConfirmation,
  TripWCheckout,
  updateICalAfterBookingTrip,
} from "./trips-utils";
import { createSuperhogReservation } from "./superhog-utils";

import { sendSlackMessage } from "@/server/slack";
import { formatDateMonthDay, removeTravelerMarkup } from "../utils";
import { sendText } from "@/server/server-utils";
import { sendTextToHostTeamMembers } from "@/server/server-utils";

export const stripe = new Stripe(env.STRIPE_RESTRICTED_KEY_ALL);
const stripeWithSecretKey = new Stripe(env.STRIPE_SECRET_KEY, {
  typescript: true,
});

export async function createSetupIntent({
  customerId,
  paymentMethodId,
  userId,
}: {
  customerId: string;
  paymentMethodId: string;
  userId: string;
}) {
  //now we need to update the customer account with the attached payment method
  await stripeWithSecretKey.paymentMethods.attach(paymentMethodId, {
    customer: customerId,
  });

  //first we need to create the setup Inten using information from the booking

  const setupIntent = await stripeWithSecretKey.setupIntents.create({
    customer: customerId,
    payment_method: paymentMethodId,
    metadata: {
      user_id: userId,
    },
  });

  //now we need to update DB to  the setUptIntent to be used for future payments
  await db
    .update(users)
    .set({
      setupIntentId: setupIntent.id,
    })
    .where(eq(users.id, userId));
}

export async function chargeForDamagesOrMisc({
  amount,
  customerId,
  paymentMethodId,
  description,
  currency = "usd",
}: {
  amount: number;
  customerId: string;
  paymentMethodId: string;
  description: string;
  currency?: string;
}) {
  try {
    const paymentIntent = await stripeWithSecretKey.paymentIntents.create({
      amount,
      currency,
      customer: customerId,
      payment_method: paymentMethodId,
      confirm: true, // Tries to confirm immediately
      description,
    });

    // Check the status of the PaymentIntent
    if (paymentIntent.status === "succeeded") {
      console.log("Charge successful:", paymentIntent);
      return paymentIntent; // Payment was completed successfully
    } else if (
      paymentIntent.status === "requires_action" ||
      paymentIntent.status === "requires_confirmation"
    ) {
      console.log("Additional action required for:", paymentIntent);
      // You need to handle the additional action on the client side
      return paymentIntent;
    } else {
      console.error("PaymentIntent status:", paymentIntent.status);
      throw new Error("Failed to complete the charge.");
    }
  } catch (error) {
    console.error("Charge error:", error);
    throw error;
  }
}

//helper functions in stripe webhook
export async function getRequestIdByOfferId(
  offerId: string | number | undefined,
) {
  if (!offerId) return null;

  if (typeof offerId === "string") {
    offerId = parseInt(offerId, 10);
  }
  const curRequest = await db
    .select({ id: offers.requestId })
    .from(offers)
    .where(eq(offers.id, offerId))
    .then((res) => res[0]!);

  return curRequest.id ? curRequest.id : null;
}

export async function finalizeTrip({
  paymentIntentId,
  numOfGuests,
  travelerPriceBeforeFees,
  checkIn,
  checkOut,
  propertyId,
  userId,
  isDirectListingCharge,
  source,
  requestToBookId, // AKA REQUEST TO BID ID
}: {
  paymentIntentId: string;
  travelerPriceBeforeFees: number;
  numOfGuests: number;
  checkIn: Date;
  checkOut: Date;
  propertyId: number;
  userId: string;
  isDirectListingCharge: boolean;
  source: "Book it now" | "Request to book";
  requestToBookId?: number;
}) {
  //1.) create  groupId
  const madeByGroupId = await db
    .insert(groups)
    .values({ ownerId: userId })
    .returning()
    .then((res) => res[0]!.id);

  await db.insert(groupMembers).values({
    userId: userId,
    groupId: madeByGroupId,
  });

  //1.get user for setup
  const user = await db.query.users
    .findFirst({
      where: eq(users.id, userId),
    })
    .then((res) => res!);

  // 2.) create params for breakdown
  const property = await db.query.properties.findFirst({
    where: eq(properties.id, propertyId),
    with: {
      hostTeam: {
        with: {
          owner: {
            columns: {
              image: true,
              firstName: true,
              lastName: true,
              email: true,
              id: true,
              about: true,
              location: true,
            },
            // with: {
            //   hostProfile: {
            //     columns: { curTeamId: true },
            //   },
            // },
          },
        },
      },
      reviews: true,
    },
  });
  if (!property) throw new Error("no property");

  const params = {
    dates: {
      checkIn: checkIn,
      checkOut: checkOut,
    },
    travelerPriceBeforeFees: travelerPriceBeforeFees,
    property: property,
  };

  const priceBreakdown = breakdownPaymentByPropertyAndTripParams(params);
  // 2. Using breakdown create a tripCheckout and trip

  const tripCheckout = await db
    .insert(tripCheckouts)
    .values({
      paymentIntentId,
      travelerOfferedPriceBeforeFees: travelerPriceBeforeFees,
      totalTripAmount: priceBreakdown.totalTripAmount,
      taxesPaid: priceBreakdown.taxesPaid,
      superhogFee: priceBreakdown.superhogFee,
      stripeTransactionFee: priceBreakdown.stripeTransactionFee,
      totalSavings: priceBreakdown.totalSavings,
      securityDeposit: property.currentSecurityDeposit,
    })
    .returning()
    .then((r) => r[0]!);

  console.log();
  const currentTrip = await db
    .insert(trips)
    .values({
      ...(requestToBookId && { requestToBookId: requestToBookId }),
      checkIn: checkIn,
      checkOut: checkOut,
      numGuests: numOfGuests,
      groupId: madeByGroupId,
      tripSource: source,
      propertyId: property.id,
      paymentIntentId,
      totalPriceAfterFees: priceBreakdown.totalTripAmount,
      tripCheckoutId: tripCheckout.id,
    })
    .returning()
    .then((res) => res[0]!);

  const currentTripWCheckout: TripWCheckout = {
    ...currentTrip,
    tripCheckout,
  };

  //create superhog request
  //<___creating a superhog  oreservationnly if does not exist__>

  if (!currentTrip.superhogRequestId && !isDirectListingCharge) {
    //1. create superhog, and update ICAL
    await createSuperhogReservation({
      paymentIntentId,
      propertyId: property.id,
      userId: userId,
      trip: currentTrip,
    }); //creating a superhog reservation

    await updateICalAfterBookingTrip(currentTripWCheckout);
  } else {
    if (isDirectListingCharge) {
      await captureTripPaymentWithoutSuperhog({
        paymentIntentId,
        propertyId: property.id,
        trip: currentTrip,
      });
    } else {
      console.log("Superhog reservation already exists");
    }
  }
  //<<--------------------->>

  //send email and whatsup (whatsup is not implemented yet)
  console.log("Sending email and whatsup");
  await sendEmailAndWhatsupConfirmation({
    trip: currentTripWCheckout,
    user: user,
    property: property,
  });
  // //redeem the traveler and host refferal code
  // if (user?.referralCodeUsed) {
  //   await completeReferral({ user: user, offerId: offer.id });
  // }
  // //validate the host discount referral
  // if (currentProperty?.hostTeam.ownerId) {
  //   await validateHostDiscountReferral({
  //     hostUserId: currentProperty.hostTeam.ownerId,
  //   });
  // }
  // if (paymentIntentSucceeded.metadata.user_id) {
  //   await createConversationWithOfferAfterBooking({
  //     offerId: offer.id.toString(),
  //     offerHostId: currentProperty!.hostTeam.ownerId,
  //     offerPropertyName: currentProperty!.name,
  //     travelerId: paymentIntentSucceeded.metadata.user_id,
  //   });
  // }
  // ------ Send Slack When trip is booked ------
  await sendSlackMessage({
    isProductionOnly: false,
    channel: "tramona-bot",
    text: [
      `*${user.email} just booked a trip: ${property.name}*`,
      `*${property.city}*`,
      `through ${isDirectListingCharge ? "a different platform (direct listing)" : "Tramona"}  ${formatDateMonthDay(checkIn)}-${formatDateMonthDay(checkOut)}`,
      `<https://tramona.com/admin|Go to admin dashboard>`,
    ].join("\n"),
  });

  if (source === "Book it now") {
    //send that there is a new booking to the host TODO
    await sendTextToHostTeamMembers({
      hostTeamId: property.hostTeamId,
      message: `${user.email} just booked your property`,
    });
  } else {
    //send text to traveler
    await sendText({
      to: user.phoneNumber!,
      content: `Your request to book ${property.name} has been accepted by the host. You're going to ${property.city} from ${formatDateMonthDay(checkIn)} to ${formatDateMonthDay(checkOut)}!`,
    });
  }
}

export async function createRequestToBook({
  paymentIntentId,
  numOfGuests,
  travelerPriceBeforeFees,
  checkIn,
  checkOut,
  propertyId,
  userId,
  isDirectListingCharge,
}: {
  paymentIntentId: string;
  travelerPriceBeforeFees: number;
  numOfGuests: number;
  checkIn: Date;
  checkOut: Date;
  propertyId: number;
  userId: string;
  isDirectListingCharge: boolean;
}) {
  const user = await db.query.users
    .findFirst({
      where: eq(users.id, userId),
    })
    .then((res) => res!);

  const property = await db.query.properties
    .findFirst({
      where: eq(properties.id, propertyId),
    })
    .then((res) => res!);

  //create group
  const madeByGroupId = await db
    .insert(groups)
    .values({ ownerId: userId })
    .returning()
    .then((res) => res[0]!.id);

  await db.insert(groupMembers).values({
    userId: userId,
    groupId: madeByGroupId,
  });

  await db.insert(requestsToBook).values({
    hostTeamId: property.hostTeamId,
    createdAt: new Date(),
    propertyId,
    userId: userId,
    madeByGroupId: madeByGroupId,
    paymentIntentId,
    checkIn,
    checkOut,
    numGuests: numOfGuests,
    baseAmountBeforeFees: removeTravelerMarkup(travelerPriceBeforeFees),
    amountAfterTravelerMarkupAndBeforeFees: Math.floor(travelerPriceBeforeFees),
    isDirectListing: isDirectListingCharge,
  });

  //    ------2 CASES: 1.)no direct listing so send to the host 2.) isDirectLIsting send message to us

  // Case 1 : DIRECT LISTING. SEND SLACK
  if (isDirectListingCharge) {
    await sendSlackMessage({
      isProductionOnly: false,
      channel: "tramona-bot",
      text: [
        `*${user.email} just requested to book: ${property.name}*`,
        `*${property.city}*`,
        `through ${"a different platform (direct listing)"}  ${formatDateMonthDay(checkIn)}-${formatDateMonthDay(checkOut)}`,
        `<https://tramona.com/admin|Go to admin dashboard>`,
      ].join("\n"),
    });
  } else {
    // Case 2: Not DirectListing so we need to send the request to the host
    await sendTextToHostTeamMembers({
      hostTeamId: property.hostTeamId,
      message: `${user.email} just requested to book your property`,
    });

    await sendSlackMessage({
      isProductionOnly: true,
      channel: "tramona-bot",
      text: [
        `*${user.email} just requested to book: ${property.name}*`,
        `*${property.city}*`,
        `through one of our properties ${formatDateMonthDay(checkIn)}-${formatDateMonthDay(checkOut)}`,
        `<https://tramona.com/admin|Go to admin dashboard>`,
      ].join("\n"),
    });
  }
  return;
}

export async function withdrawOverlappingOffers({
  propertyId,
  checkIn,
  checkOut,
  excludeOfferId,
}: {
  propertyId: number;
  checkIn: Date;
  checkOut: Date;
  excludeOfferId?: number;
}) {
  // find pending offers for this property that overlap with the date range of accepted offer/book it now
  // an offer overlaps if:
  // 1. check-in date falls between the booked check-in and check-out dates
  // 2. check-out date falls between the booked check-in and check-out dates
  // 3. dates completely encompasses the booked dates
  const checkInStr = checkIn.toISOString();
  const checkOutStr = checkOut.toISOString();

  const overlappingOffersQuery = db
    .update(offers)
    .set({
      status: "Withdrawn",
    })
    .where(
      and(
        eq(offers.propertyId, propertyId),
        eq(offers.status, "Pending"),
        excludeOfferId ? sql`${offers.id} != ${excludeOfferId}` : undefined,
        or(
          // if offer check-in falls within booked period
          and(
            sql`${offers.checkIn}::date >= ${checkInStr}::date`,
            sql`${offers.checkIn}::date < ${checkOutStr}::date`,
          ),
          // if offer check-out falls within booked period
          and(
            sql`${offers.checkOut}::date > ${checkInStr}::date`,
            sql`${offers.checkOut}::date <= ${checkOutStr}::date`,
          ),
          // if offer completely overlaps booked period
          and(
            sql`${offers.checkIn}::date <= ${checkInStr}::date`,
            sql`${offers.checkOut}::date >= ${checkOutStr}::date`,
          ),
        ),
      ),
    )
    .returning();

  const rejectedOffers = await overlappingOffersQuery;
  return rejectedOffers;
}
</code></pre>
</div>
<div class='section'>
<h2 class='section-title'>Host Conversation Feature</h2>
<div class='file'>
<div class='file-name'>./src/components/dashboard/host/requests/requests-to-book/HostRequestsToBook.tsx</div>
<pre><code>
import { api } from "@/utils/api";
import { useRouter } from "next/router";
import HostRequestToBookDialog from "./HostRequestToBookDialog";
import { Button } from "@/components/ui/button";
import { useState } from "react";
import { ChevronLeft } from "lucide-react";
import Link from "next/link";
import { useToast } from "@/components/ui/use-toast";
import { errorToast } from "@/utils/toasts";
import { Home } from "lucide-react";
import { Card, CardContent } from "@/components/ui/card";
import HostRequestToBookCard from "./HostRequestToBookCard";
import { useChatWithUser } from "@/utils/messaging/useChatWithUser";

export default function HostRequestsToBook() {
  const { toast } = useToast();
  const [dialogOpen, setDialogOpen] = useState(false);
  const router = useRouter();
  const propertyId = parseInt(router.query.propertyId as string) || 0; // Default to 0 if parsing fails
  const { data: unusedReferralDiscounts } =
    api.referralCodes.getAllUnusedHostReferralDiscounts.useQuery(undefined, {
      onSuccess: () => {
        if (unusedReferralDiscounts && unusedReferralDiscounts.length > 0) {
          toast({
            title: "Congratulations!  ",
            description:
              "Your referral code has been validated, so your next booking will be completely free of service fees. Enjoy the savings!",
            variant: "default",
            duration: 10000,
          });
        }
      },
    });

  const { data: propertyRequests } =
    api.requestsToBook.getHostRequestsToBookFromId.useQuery(
      { propertyId },
      { enabled: !!router.isReady },
    );
  console.log(propertyRequests);

  const { mutateAsync: rejectRequestToBook } =
    api.stripe.rejectOrCaptureAndFinalizeRequestToBook.useMutation();

  const chatWithUser = useChatWithUser();

  return (
    <div>
      <div className="mb-4 xl:hidden">
        <Link href="/host/requests">
          <ChevronLeft />
        </Link>
      </div>
      {propertyRequests?.activeRequestsToBook ? (
        <div className="grid gap-4 md:grid-cols-2">
          {propertyRequests.activeRequestsToBook.map((data) => (
            <div key={data.id} className="mb-4">
              <HostRequestToBookCard requestToBook={data}>
                <Button
                  variant="secondary"
                  onClick={() => {
                    void chatWithUser(data.userId);
                  }}
                >
                  Message User
                </Button>
                {data.status === "Pending" && (
                  <Button
                    variant="secondary"
                    onClick={async () => {
                      await rejectRequestToBook({
                        isAccepted: false,
                        requestToBookId: data.id,
                      })
                        .then(() => {
                          toast({
                            title: "Successfully rejected request",
                          });
                        })
                        .catch(() => errorToast());
                    }}
                  >
                    Reject
                  </Button>
                )}
                {data.status === "Pending" ? (
                  <Button
                    onClick={() => {
                      setDialogOpen(true);
                    }}
                  >
                    Respond
                  </Button>
                ) : (
                  <Button disabled>{data.status}</Button>
                )}
              </HostRequestToBookCard>
              <HostRequestToBookDialog
                open={dialogOpen}
                setOpen={setDialogOpen}
                requestToBook={data}
              />
            </div>
          ))}
        </div>
      ) : (
        <Card className="flex h-full items-center justify-center">
          <CardContent className="flex flex-col items-center justify-center py-12 text-center">
            <Home className="mb-4 h-12 w-12 text-gray-400" />
            <h3 className="mb-2 text-lg font-semibold text-gray-900">
              No property selected
            </h3>
            <p className="max-w-sm text-sm text-gray-500">
              Please select a property from the list to view its requests and
              details.
            </p>
          </CardContent>
        </Card>
      )}
    </div>
  );
}
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/components/landing-page/search/DesktopSearchTab.tsx</div>
<pre><code>
// DesktopSearchTab.tsx
import { useState, useCallback, useEffect } from "react";
import { useRouter } from "next/router";
import { api } from "@/utils/api";
import { useZodForm } from "@/utils/useZodForm";
import {
  searchSchema,
  defaultSearchOrReqValues,
  SearchFormValues,
} from "./schemas";
import { useAdjustedProperties } from "./AdjustedPropertiesContext";
import { SearchFormBar } from "./SearchFormBar";
import { LocationGallery } from "./LocationGallery";
import {
  Dialog,
  DialogContent,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Filter } from "lucide-react";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Property } from "@/server/db/schema";
import MobileSearchFormBar from "./MobileSearchFormBar";
import { UseFormReturn } from "react-hook-form";

interface DesktopSearchTabProps {
  isCompact?: boolean;
  handleTabChange: (tab: string, scroll?: boolean) => void;
  isLandingPage: boolean;
}

export function DesktopSearchTab({
  isCompact = false,
  handleTabChange,
  isLandingPage,
}: DesktopSearchTabProps) {
  const form = useZodForm({
    schema: searchSchema,
    defaultValues: defaultSearchOrReqValues,
    reValidateMode: "onSubmit",
  });

  type AirbnbSearchResult = {
    description: string | null | undefined;
    imageUrls: string[];
    maxNumGuests: number;
    name: string;
    nightlyPrice: number;
    originalListingId: string;
    originalNightlyPrice: number;
    originalListingPlatform: string;
    ratingStr: string | null | undefined;
  };

  const [allProperties, setAllProperties] = useState<{
    pages: (Property | AirbnbSearchResult)[];
  }>({ pages: [] });

  const [maxPrice, setMaxPrice] = useState("");
  const [minPrice, setMinPrice] = useState("");
  const [priceSort, setPriceSort] = useState("");
  const [open, setOpen] = useState(false);
  const [isLoading, setIsLoading] = useState(false);

  const router = useRouter();
  const utils = api.useUtils();
  const { setAdjustedProperties } = useAdjustedProperties();

  const sortOptions = {
    none: "Select a value",
    leastExpensive: "Least Expensive",
    mostExpensive: "Most Expensive",
  };

  useEffect(() => {
    const data = searchSchema.safeParse(router.query);
    if (data.success) form.reset(data.data);
  }, [form, router.query]);

  const filterProperties = (
    properties: Property[],
    minPrice: string,
    maxPrice: string,
    priceSort: string,
  ) => {
    if (minPrice === "" && maxPrice === "" && priceSort === "") {
      return properties;
    }
    return properties
      .filter((property: Property) => {
        const price = property.originalNightlyPrice!;
        const meetsMinPrice = !minPrice || price >= parseFloat(minPrice);
        const meetsMaxPrice = !maxPrice || price <= parseFloat(maxPrice);
        return meetsMinPrice && meetsMaxPrice;
      })
      .sort((a, b) => {
        if (priceSort === "leastExpensive") {
          return a.originalNightlyPrice! - b.originalNightlyPrice!;
        }
        if (priceSort === "mostExpensive") {
          return b.originalNightlyPrice! - a.originalNightlyPrice!;
        }
        return 0;
      });
  };

  const handleLocationSelect = useCallback(
    (location: string) => {
      form.setValue("location", location);
    },
    [form],
  );

  const handleSearch = async (values: SearchFormValues) => {
    setIsLoading(true);
    const params = new URLSearchParams();
    Object.entries(values).forEach(([key, value]) => {
      if (value) params.set(key, value.toString());
    });
    void router.replace(
      `${window.location.pathname}?${params.toString()}`,
      undefined,
      { shallow: true },
    );

    setAllProperties({ pages: [] });

    if (values.checkIn && values.checkOut) {
      try {
        const propertiesInArea =
          await utils.properties.getBookItNowProperties.fetch({
            checkIn: values.checkIn,
            checkOut: values.checkOut,
            numGuests: values.numGuests,
            location: values.location,
          });

        setAllProperties((prevState) => {
          const updatedProperties = {
            ...prevState,
            pages: [
              ...prevState.pages,
              ...propertiesInArea.hostProperties,
              ...propertiesInArea.scrapedProperties,
            ],
          };

          setAdjustedProperties({
            ...updatedProperties,
            pages: filterProperties(
              updatedProperties.pages as Property[],
              minPrice !== "" ? (Number(minPrice) * 100).toString() : minPrice,
              maxPrice !== "" ? (Number(maxPrice) * 100).toString() : maxPrice,
              priceSort,
            ),
          });

          return updatedProperties;
        });

        const airbnbResultsPromise = utils.misc.scrapeAirbnbInitialPage.fetch({
          checkIn: values.checkIn,
          checkOut: values.checkOut,
          numGuests: values.numGuests,
          location: values.location,
        });
        const airbnbResults = await airbnbResultsPromise;

        setAllProperties((prevState) => {
          const updatedProperties = {
            ...prevState,
            pages: [...prevState.pages, ...airbnbResults.res],
          };

          setAdjustedProperties({
            ...updatedProperties,
            pages: filterProperties(
              updatedProperties.pages as Property[],
              minPrice !== "" ? (Number(minPrice) * 100).toString() : minPrice,
              maxPrice !== "" ? (Number(maxPrice) * 100).toString() : maxPrice,
              priceSort,
            ),
          });
          setIsLoading(false);
          return updatedProperties;

        });
        // setIsLoading(false);

        const cursors =
          airbnbResults.data.staysSearch.results.paginationInfo.pageCursors.slice(
            1,
          );

        const finishAirbnbResultsPromise = utils.misc.scrapeAirbnbPages.fetch({
          checkIn: values.checkIn,
          checkOut: values.checkOut,
          numGuests: values.numGuests,
          location: values.location,
          pageCursors: cursors,
        });

        const finishAirbnbResults = await finishAirbnbResultsPromise;
        setAllProperties((prevState) => {
          const updatedProperties = {
            ...prevState,
            pages: [...prevState.pages, ...finishAirbnbResults],
          };

          setAdjustedProperties({
            ...updatedProperties,
            pages: filterProperties(
              updatedProperties.pages as Property[],
              minPrice !== "" ? (Number(minPrice) * 100).toString() : minPrice,
              maxPrice !== "" ? (Number(maxPrice) * 100).toString() : maxPrice,
              priceSort,
            ),
          });

          return updatedProperties;
        });
      } catch (error) {
        console.error("Error running subscrapers:", error);
      } finally {
        setIsLoading(false);
      }
    } else {
      setIsLoading(false);
    }
  };

  return (
    <div className="mt-4 w-full space-y-8 py-4">
      <div className="">
        <div className="flex justify-center">
          {/* Mobile Search */}
          <div className="w-full lg:hidden">
            <MobileSearchFormBar
              form={form as UseFormReturn<SearchFormValues, unknown, SearchFormValues>}
              onSubmit={handleSearch}
              isLoading={isLoading}
            />
          </div>

          {/* Desktop Search */}
          <div className="hidden items-center lg:flex">
            <div className="flex w-full max-w-[2000px] justify-center gap-4">
              <div
                className={`z-50 transition-all duration-300 ease-in-out ${
                  isCompact ? "w-[600px]" : "w-[800px]"
                }`}
              >
                <SearchFormBar
                  form={form as UseFormReturn<SearchFormValues, unknown, SearchFormValues>}
                  onSubmit={handleSearch}
                  isLoading={isLoading}
                  isCompact={isCompact}
                />
              </div>

              {/* Divider */}
              <div
                className={`flex-shrink-0 flex-col items-center justify-center transition-all duration-300 ease-in-out ${
                  isCompact ? "h-10 text-xs" : "h-14 text-base"
                } ${isLandingPage ? "hidden xl:flex" : "hidden"}`}
              >
                <div className="h-4 w-px bg-slate-700" />
                <span className="my-1 text-sm">or</span>
                <div className="h-4 w-px bg-slate-700" />
              </div>

              {/* Button */}
              <Button
                onClick={() => handleTabChange("name-price", true)}
                variant="primary"
                className={`flex-shrink-0 whitespace-nowrap border border-black ${
                  isCompact ? "h-10 px-3 text-xs" : "h-14 px-6 text-base"
                } ${isLandingPage ? "hidden xl:block" : "hidden"}`}
              >
                Name your own price
              </Button>
            </div>
          </div>
        </div>
      </div>

      {/* LocationGallery container that matches content width */}
      <div className="hidden w-full justify-center lg:flex">
        <div
          className={`w-full max-w-[2000px] px-4 pr-36 transition-all duration-300 ease-in-out`}
        >
          <div className="flex items-center justify-between">
            <LocationGallery
              onLocationSelect={handleLocationSelect}
              isCompact={isCompact}
            />
            <Dialog open={open} onOpenChange={setOpen}>
              <DialogTrigger asChild>
                <Button
                  variant="outline"
                  className="ml-2 rounded-md border-gray-300 text-gray-600 hover:bg-gray-200"
                >
                  <Filter className="mr-1 h-4 w-4" />
                  Filters
                </Button>
              </DialogTrigger>
              <DialogContent>
                <DialogHeader>
                  <DialogTitle>Set Price Filters</DialogTitle>
                </DialogHeader>
                <div className="flex w-full justify-between">
                  <div>
                    <div>Min Price</div>
                    <Input
                      type="number"
                      placeholder="Min Price"
                      value={minPrice}
                      onChange={(e) => setMinPrice(e.target.value)}
                    />
                  </div>
                  <div>
                    <div>Max Price</div>
                    <Input
                      type="number"
                      placeholder="Max Price"
                      value={maxPrice}
                      onChange={(e) => setMaxPrice(e.target.value)}
                    />
                  </div>
                </div>
                <div>Sort by Price</div>
                <Select
                  onValueChange={(value) => setPriceSort(value)}
                  value={priceSort}
                >
                  <SelectTrigger className="w-full border-gray-300 bg-white">
                    <SelectValue
                      className={
                        priceSort === "none" ? "text-gray-400" : "text-black"
                      }
                    >
                      {priceSort === "none"
                        ? "Select a value"
                        : sortOptions[priceSort as keyof typeof sortOptions]}
                    </SelectValue>
                  </SelectTrigger>
                  <SelectContent className="bg-white">
                    {Object.entries(sortOptions).map(([value, label]) => (
                      <SelectItem key={value} value={value}>
                        {label}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                <DialogFooter>
                  <Button
                    variant="outline"
                    onClick={() => {
                      setMinPrice("");
                      setMaxPrice("");
                      setPriceSort("none");
                    }}
                  >
                    Clear Filters
                  </Button>
                  <Button
                    onClick={() => {
                      setAdjustedProperties((prevState) => {
                        if (!prevState) return null;
                        return {
                          ...prevState,
                          pages: filterProperties(
                            allProperties.pages as Property[],
                            minPrice !== ""
                              ? (Number(minPrice) * 100).toString()
                              : minPrice,
                            maxPrice !== ""
                              ? (Number(maxPrice) * 100).toString()
                              : maxPrice,
                            priceSort,
                          ),
                        };
                      });
                      setOpen(false);
                    }}
                  >
                    Apply Filters
                  </Button>
                </DialogFooter>
              </DialogContent>
            </Dialog>
          </div>
        </div>
      </div>
    </div>
  );
}
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/components/my-trips/TripTab.tsx</div>
<pre><code>
import EmptyStateValue from "@/components/_common/EmptyStateSvg/EmptyStateValue";
import MyTripsEmptySvg from "@/components/_common/EmptyStateSvg/MyTripsEmptySvg";
import UpcomingTripCard from "@/components/my-trips/UpcomingTripCard";
import { type TripCardDetails } from "@/pages/my-trips";
import { CalendarClockIcon, SearchIcon } from "lucide-react";
import Link from "next/link";
import { Button } from "../ui/button";
import { Alert, AlertTitle, AlertDescription } from "../ui/alert";

export default function TripsTab({
  trips,
  type,
}: {
  trips: TripCardDetails[];
  type: "upcoming" | "current";
}) {
  return (
    <div className="mt-3 flex flex-col gap-y-3">
      <Link href="/unclaimed-offers">
        <Button variant="primary" className="max-w-fit">
          <SearchIcon className="size-5 -ml-1" />
          Plan Another Trip
        </Button>
      </Link>
      <Alert className="bg-white">
        <CalendarClockIcon className="h-4 w-4" />
        <AlertTitle>
          {type === "upcoming" ? "Upcoming Adventures" : "Active Trips"}
        </AlertTitle>
        <AlertDescription>
          {type === "upcoming"
            ? "Get ready for your future stays. ALL your upcoming bookings appear here."
            : "These are your ongoing trips. Enjoy your stay"}
        </AlertDescription>
      </Alert>
      {trips.length > 0 ? (
        <div className="grid grid-cols-1 gap-4 pt-4 xl:grid-cols-2">
          {trips.map((trip) => (
            <UpcomingTripCard key={trip.id} trip={trip} />
          ))}
        </div>
      ) : (
        <EmptyStateValue
          title="You have no upcoming trips"
          description="Once you've booked a property, your trips will show up here."
          redirectTitle="Start Searching"
          href="/"
        >
          <MyTripsEmptySvg />
        </EmptyStateValue>
      )}
    </div>
  );
}
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/components/my-trips/UpcomingTripCard.tsx</div>
<pre><code>
import { HelpCircleIcon, MessageCircleMore } from "lucide-react";
import Link from "next/link";
import { Badge } from "../ui/badge";
import { Button } from "../ui/button";
import { formatDateRange, getDaysUntilTrip } from "@/utils/utils";
import Image from "next/image";
import UserAvatar from "../_common/UserAvatar";
import { type TripCardDetails } from "@/pages/my-trips";
import ChatOfferButton from "../propertyPages/sections/ChatOfferButton";
import TripCancelDialog from "./TripCancelDialog";
import { useChatWithHost } from "@/utils/messaging/useChatWithHost";

export default function UpcomingTripCard({ trip }: { trip: TripCardDetails }) {
  const chatWithHost = useChatWithHost();
  const hostId = trip.property.hostTeam.ownerId;

  return (
    <div className="w-full">
      <div className="flex flex-col overflow-clip rounded-xl border shadow-md lg:flex-row">
        <div className="flex w-full flex-col gap-4 p-4 pt-12 lg:pt-4">
          <div className="flex w-full flex-col justify-start gap-3 lg:flex-row lg:gap-x-6">
            <div className="flex flex-col gap-4 lg:gap-0">
              <div className="flex justify-center sm:justify-start">
                <Link
                  href={`/my-trips/${trip.id}`}
                  className="relative -mt-8 h-48 w-full sm:h-32 sm:w-52 lg:-mt-0"
                >
                  <Image
                    fill
                    alt=""
                    className="rounded-md object-cover"
                    src={trip.property.imageUrls[0]!}
                  />
                  <Badge variant="lightGray" className="absolute left-2 top-3">
                    Trip in {getDaysUntilTrip(trip.checkIn)} days
                  </Badge>
                </Link>
              </div>
              <div className="mt-4 flex gap-2">
                <UserAvatar
                  name={trip.property.hostTeam.owner.name}
                  image={
                    trip.property.hostTeam.owner.image ??
                    "/assets/images/tramona-logo.jpeg"
                  }
                />
                <div className="flex w-full justify-between">
                  <div>
                    <p className="text-sm text-muted-foreground">Hosted by</p>
                    <p>
                      {trip.property.hostTeam.owner.name ??
                        trip.property.hostTeam.name}
                    </p>
                  </div>
                </div>
              </div>
            </div>
            <div className="mt-4 flex flex-col gap-4">
              <Link
                href={`/my-trips/${trip.id}`}
                className="text-xl font-bold lg:text-2xl"
              >
                {trip.property.name}
              </Link>

              <p className="flex flex-row items-center gap-x-1">
                {trip.property.address}
              </p>

              <div className="">
                <p>{formatDateRange(trip.checkIn, trip.checkOut)}</p>
                <Link
                  href={`/my-trips/${trip.id}`}
                  className="text-sm font-bold underline underline-offset-4"
                >
                  View more
                </Link>
              </div>
            </div>
            <Badge
              variant={
                trip.tripsStatus === "Booked"
                  ? "green"
                  : trip.tripsStatus === "Needs attention"
                    ? "yellow"
                    : "red"
              }
              className="ml-auto"
            >
              {trip.tripsStatus}
            </Badge>
          </div>

          <div className="h-[2px] rounded-full bg-gray-200"></div>

          <div className="flex flex-col justify-center gap-2 px-4 sm:flex-row lg:gap-4">
            {/* {trip.offerId && (
              <ChatOfferButton
                offerId={trip.offerId.toString()}
                offerHostId={trip.property.hostTeam.ownerId}
                offerPropertyName={trip.property.name}
              />
            )} */}
            <Button asChild variant="primary">
              <Link href="/help-center">
                <HelpCircleIcon />
                Help
              </Link>
            </Button>
            {trip.tripsStatus !== "Cancelled" && (
              <TripCancelDialog trip={trip} />
            )}
            <Button onClick={() => chatWithHost({ hostId })}>
              <MessageCircleMore />
              Message Host
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
}
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/components/propertyPages/PropertyPage.tsx</div>
<pre><code>
import { useEffect, useRef, useState } from "react";
import UserAvatar from "@/components/_common/UserAvatar";
import { Button } from "@/components/ui/button";
import ReviewCard from "@/components/_common/ReviewCard";
import {
  DialogNoDrawer,
  DialogContentNoDrawer,
  DialogTriggerNoDrawer,
} from "@/components/ui/dialog-no-drawer";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { api, type RouterOutputs } from "@/utils/api";
import { getOfferDiscountPercentage, plural } from "@/utils/utils";
import { AspectRatio } from "../ui/aspect-ratio";
import {
  ImagesIcon,
  ChevronRight,
  StarIcon,
  BedDoubleIcon,
  ExternalLinkIcon,
  MessageCircleMore,
} from "lucide-react";
import Image from "next/image";
import React from "react";
import PropertyPhotos from "./sections/PropertyPhotos";
import AmenitiesComponent from "./sections/CategorizedAmenities";
import PropertyAmenities from "./sections/PropertyAmenities";
import ShareOfferDialog from "../_common/ShareLink/ShareOfferDialog";
import { Card, CardContent } from "../ui/card";
import { getOriginalListing } from "@/utils/listing-sites";
import { PropertyCompareBtn } from "./sections/PropertyCompareBtn";
import SingleLocationMap from "../_common/GoogleMaps/SingleLocationMap";
import Link from "next/link";
import {
  CheckInTimeRule,
  CheckOutTimeRule,
  PetsRule,
  SmokingRule,
} from "./sections/HouseRules";
import { getCancellationPolicyDescription } from "@/config/getCancellationPolicyDescription";
import { createUserNameAndPic } from "../activity-feed/admin/generationHelper";
import ChatOfferButton from "./sections/ChatOfferButton";
import ReasonsToBook from "./sections/ReasonsToBook";
import UserInfo from "./sections/UserInfo";
import { useChatWithHost } from "@/utils/messaging/useChatWithHost";
import { useChatWithAdmin } from "@/utils/messaging/useChatWithAdmin";
export type OfferWithDetails = RouterOutputs["offers"]["getByIdWithDetails"];
export type PropertyPageData = RouterOutputs["properties"]["getById"];
//export type PropertyPageData = RouterOutputs["properties"]["getById"];

export default function PropertyPage({
  property,
  offer,
  sidebar,
  mobileBottomCard,
}: {
  property: PropertyPageData;
  offer?: OfferWithDetails;
  sidebar?: React.ReactNode;
  mobileBottomCard?: React.ReactNode;
}) {
  const aboutRef = useRef<HTMLDivElement>(null);
  const [isOverflowing, setIsOverflowing] = useState(false);
  const [reviewBackupImages, setReviewBackupImages] = useState<string[]>([]);
  const [openUserInfo, setOpenUserInfo] = useState(false);
  const chatWithHost = useChatWithHost();
  const chatWithAdmin = useChatWithAdmin();

  api.calendar.getAndUpdateHostCalendar.useQuery(
    {
      hospitableListingId: property.hospitableListingId!,
    },
    {
      enabled: Boolean(property.hospitableListingId),
    },
  );

  const isHospitableUser = property.originalListingPlatform === "Hospitable";

  // const { mutateAsync: updateCalender } =
  //   api.calendar.updateHostCalendar.useMutation();

  // useEffect(() => {
  //   const updateCalendarIfNeeded = async () => {
  //     if (property.hospitableListingId === "Hospitable") {
  //       try {
  //         await updateCalender({
  //           hospitableListingId: property.hospitableListingId,
  //         });
  //       } catch (error) {
  //         console.error("Failed to update calendar:", error);
  //       }
  //     }
  //   };

  //   void updateCalendarIfNeeded();
  // }, [property.hospitableListingId, updateCalender]);

  useEffect(() => {
    const aboutElement = aboutRef.current;
    if (aboutElement) {
      setIsOverflowing(aboutElement.scrollHeight > aboutElement.clientHeight);
    }
    async function createReviewBackupImages() {
      const backup = await createUserNameAndPic(property.reviews.length).then(
        (users) => users.map((user) => user.picture),
      );
      setReviewBackupImages(backup);
    }
    void createReviewBackupImages();
  }, [property.reviews.length]);

  const hostName =
    property.hostName ??
    `${property.hostTeam.owner.firstName} ${property.hostTeam.owner.lastName}`;

  const originalListing = getOriginalListing(property);

  const renderSeeMoreButton = property.imageUrls.length > 5;

  const [selectedImageIdx, setSelectedImageIdx] = useState<number>(0);
  const firstImageUrl = property.imageUrls[0]!;

  const discountPercentage = offer ? getOfferDiscountPercentage(offer) : null;

  return (
    <div>
      <div className="relative grid h-[480px] grid-cols-4 grid-rows-2 gap-2 overflow-hidden rounded-xl">
        <DialogNoDrawer>
          <DialogTriggerNoDrawer
            key={0}
            onClick={() => setSelectedImageIdx(0)}
            className="hover:opacity-90 sm:hidden"
          >
            <Image
              src={firstImageUrl}
              alt=""
              fill
              className="object-cover object-center"
            />
          </DialogTriggerNoDrawer>
          <div className="hidden sm:contents">
            {property.imageUrls.slice(0, 5).map((imageUrl, index) => (
              <div
                key={index}
                className={`relative col-span-1 row-span-1 ${
                  index === 0 ? "col-span-2 row-span-2" : ""
                }`}
              >
                <DialogTriggerNoDrawer
                  onClick={() => setSelectedImageIdx(index)}
                  className="hover:opacity-90"
                >
                  <Image
                    src={imageUrl}
                    alt=""
                    fill
                    className="object-cover object-center"
                  />
                </DialogTriggerNoDrawer>
              </div>
            ))}
          </div>
          <DialogContentNoDrawer className="flex w-full items-center justify-center border-none bg-transparent [&>button]:hidden">
            <div className="screen-full flex justify-center">
              <PropertyPhotos
                propertyImages={property.imageUrls}
                indexOfSelectedImage={selectedImageIdx}
              />
            </div>
          </DialogContentNoDrawer>
        </DialogNoDrawer>

        {/* If there are more than 5 images, render the "See more photos" button */}
        {renderSeeMoreButton && (
          <div className="absolute bottom-2 left-2">
            <Dialog>
              <DialogTrigger asChild>
                <Button variant="white" className="rounded-full">
                  <ImagesIcon />
                  See all {property.imageUrls.length} photos
                </Button>
              </DialogTrigger>

              <DialogContent className="max-w-4xl">
                <DialogHeader>
                  <DialogTitle>More Photos</DialogTitle>
                </DialogHeader>
                {/* //dialog within a dialog */}
                <DialogNoDrawer>
                  <div className="grid-row-4 grid min-h-[1000px] grid-cols-2 gap-2 rounded-xl">
                    {property.imageUrls.map((imageUrl, index) => (
                      <DialogTriggerNoDrawer
                        key={index}
                        className={`hover:opacity-90 ${
                          index === 0 || index % 3 === 0
                            ? "col-span-2 row-span-2"
                            : property.imageUrls.length - 1 === index &&
                                index % 4 === 0
                              ? "col-span-2 row-span-2"
                              : "col-span-1 row-span-1"
                        }`}
                      >
                        <div
                          key={index}
                          onClick={() => setSelectedImageIdx(index)}
                        >
                          <AspectRatio ratio={3 / 2}>
                            <Image
                              src={imageUrl}
                              alt=""
                              fill
                              className="h-full w-full object-cover object-center"
                            />
                          </AspectRatio>
                        </div>
                      </DialogTriggerNoDrawer>
                    ))}
                  </div>
                  <DialogContentNoDrawer className="flex items-center justify-center border-none bg-transparent [&>button]:hidden">
                    <div className="screen-full flex justify-center">
                      <PropertyPhotos
                        propertyImages={property.imageUrls}
                        indexOfSelectedImage={selectedImageIdx}
                      />
                    </div>
                  </DialogContentNoDrawer>
                </DialogNoDrawer>
              </DialogContent>
            </Dialog>
          </div>
        )}
      </div>

      <div className="h-2" />

      {discountPercentage && (
        <div className="rounded-xl bg-primaryGreen py-4 text-center text-2xl font-semibold text-white">
          {discountPercentage}% off
        </div>
      )}

      <div className="relative flex gap-8 pt-5">
        <div className="min-w-0 flex-1 space-y-4">
          <section>
            <div className="flex items-center justify-between">
              <h1 className="flex-1 text-xl font-semibold sm:text-2xl">
                {property.name}
              </h1>
              <Button onClick={() => isHospitableUser ? chatWithHost({ hostId: property.hostTeam.ownerId }) : chatWithAdmin()}>
                <MessageCircleMore />
                Message Host
              </Button>
            </div>
            <div className="flex flex-col gap-4 sm:flex-row">
              <div className="flex-1">
                <p className="gap flex flex-wrap items-center gap-x-1 pt-1 text-sm font-medium capitalize">
                  {property.propertyType} in {property.city} {" "}
                  <StarIcon className="size-[1em] inline fill-primaryGreen stroke-primaryGreen" />{" "}
                  {property.numRatings === 0 ? (
                    <>New</>
                  ) : (
                    <>
                      {property.avgRating}{" "}
                      <a href="#reviews" className="underline">
                        ({plural(property.numRatings, "review")})
                      </a>
                    </>
                  )}
                </p>
                <p className="text-sm font-medium">
                  {plural(property.maxNumGuests, "guest")} {" "}
                  {plural(property.numBedrooms, "bedroom")} {" "}
                  {plural(property.numBeds, "bed")}
                  {property.numBathrooms && property.numBathrooms > 0 && (
                    <>  {plural(property.numBathrooms, "bath")}</>
                  )}
                </p>
              </div>
              {originalListing && offer && !property.bookOnAirbnb && (
                <div className="self-end">
                  <PropertyCompareBtn
                    checkIn={offer.checkIn}
                    checkOut={offer.checkOut}
                    numGuests={property.maxNumGuests}
                    originalListing={originalListing}
                  />
                </div>
              )}
            </div>
          </section>

          <section className="flex-justify-between mx-1 flex w-full border-t pt-4">
            <div
              className="flex w-5/6 items-center gap-2"
              onClick={() => setOpenUserInfo(true)}
            >
              <UserAvatar
                name={hostName}
                email={property.hostTeam.owner.email}
                image={property.hostTeam.owner.image}
              />
              <div className="-space-y-1">
                <p className="text-sm text-muted-foreground">Hosted by</p>
                <p className="text-lg font-medium">{hostName}</p>
              </div>
            </div>
            {offer && (
              <ChatOfferButton
                offerId={offer.id.toString()}
                offerHostId={offer.property.hostTeam.ownerId}
                offerPropertyName={offer.property.name}
              />
            )}
          </section>
          <Dialog open={openUserInfo} onOpenChange={setOpenUserInfo}>
            <DialogContent>
              <DialogTitle className="text-lg font-semibold">
                Host Information
              </DialogTitle>
              {/* <div className="flex space-x-2">
                <div className="flex flex-col space-y-2"> */}
              <UserInfo
                hostName={hostName}
                hostPic={property.hostTeam.owner.image}
                hostDesc={property.hostTeam.owner.about}
                hostLocation={property.hostTeam.owner.location}
              />
              {/* <HostVerificationInfo hostName={hostName} /> */}
              {/* </div>
                <div>
                  <div className="text-lg font-bold">About {hostName}</div>{" "}
                  {property.host?.hostProfile?.about}
                </div>
              </div> */}
            </DialogContent>
          </Dialog>
          <section>
            <h2 className="subheading border-t pb-2 pt-4">
              About this property
            </h2>
            <div className="z-20 px-1 text-zinc-700">
              <div ref={aboutRef} className="line-clamp-5 break-words">
                {property.about}
              </div>
              {isOverflowing && (
                <Dialog>
                  <DialogTrigger className="inline-flex items-center justify-center text-foreground underline underline-offset-2">
                    Show more
                    <ChevronRight className="ml-2" />
                  </DialogTrigger>

                  <DialogContent className="max-w-3xl p-8">
                    <DialogHeader>
                      <DialogTitle>About this property</DialogTitle>
                    </DialogHeader>
                    <p className="whitespace-break-spaces break-words text-base">
                      {property.about}
                    </p>
                  </DialogContent>
                </Dialog>
              )}
            </div>
          </section>

          {property.roomsWithBeds && (
            <section>
              <h2 className="subheading border-t pb-2 pt-4">Rooms & Beds</h2>
              <div className="flex gap-4 overflow-x-auto">
                {property.roomsWithBeds.map((room, index) => (
                  <div
                    key={index}
                    className="min-w-56 flex flex-col items-center gap-4 whitespace-pre rounded-lg border p-4"
                  >
                    <BedDoubleIcon />
                    <p className="text-lg font-semibold">{room.name}</p>
                    <p className="text-center text-sm text-muted-foreground">
                      {room.beds
                        .map((bed) => plural(bed.count, bed.type))
                        .join(", ")}
                    </p>
                  </div>
                ))}
              </div>
            </section>
          )}

          <section className="space-y-4">
            <h2 className="subheading border-t pb-2 pt-4">Amenitites</h2>
            <PropertyAmenities amenities={property.amenities} />
            <Dialog>
              <DialogTrigger asChild>
                <Button variant="secondary" className="w-full sm:w-auto">
                  Show all amenities
                </Button>
              </DialogTrigger>
              <DialogContent className="max-w-4xl">
                <DialogHeader>
                  <DialogTitle>Amenities</DialogTitle>
                </DialogHeader>
                <div className="max-h-96 overflow-y-auto">
                  <AmenitiesComponent propertyAmenities={property.amenities} />
                </div>
              </DialogContent>
            </Dialog>
          </section>

          <section className="border-t pb-2 pt-4">
            <ReasonsToBook />
          </section>

          <section>
            <h2 className="subheading border-t pb-2 pt-4">
              Where you&apos;ll be
            </h2>
            <div className="relative mt-4 h-[400px]">
              <div className="absolute inset-0 z-0 overflow-hidden rounded-xl border">
                <SingleLocationMap
                  lng={property.latLngPoint.x}
                  lat={property.latLngPoint.y}
                />
              </div>
            </div>
          </section>

          <section>
            <div className="flex items-start justify-between border-t pb-2 pt-4">
              <div>
                <h2 id="reviews" className="subheading">
                  Guest Reviews
                </h2>
                <div className="flex items-center gap-2 pb-4">
                  <StarIcon className="size-[1em] inline fill-primaryGreen stroke-primaryGreen" />{" "}
                  {property.avgRating}  {plural(property.numRatings, "review")}
                </div>
              </div>
            </div>
            <div className="grid gap-4">
              {property.reviews.map(
                (review, id) =>
                  reviewBackupImages[id] && (
                    <ReviewCard
                      key={review.id}
                      review={review}
                      backupReview={reviewBackupImages[id]}
                    />
                  ),
              )}
            </div>
            {originalListing && offer && (
              <Link
                target="_blank"
                rel="noopener noreferrer"
                className="flex items-center gap-2 font-semibold text-teal-700 underline underline-offset-2"
                href={originalListing.getReviewsUrl({
                  checkIn: offer.checkIn,
                  checkOut: offer.checkOut,
                  numGuests: offer.request?.numGuests ?? 1,
                })}
              >
                See all reviews
                <ExternalLinkIcon className="h-4 w-4" />
              </Link>
            )}
          </section>

          {property.hostNumReviews && property.hostRating && (
            <section>
              <h2 className="subheading border-t pb-2 pt-4">Meet your host</h2>
              <Card className="mt-4 max-w-sm p-8">
                <CardContent className="flex items-center justify-between sm:p-6">
                  <div className="space-y-4">
                    <UserAvatar
                      size="huge"
                      name={hostName}
                      image={
                        property.hostProfilePic ?? property.hostTeam.owner.image
                      }
                    />
                    <p className="text-center text-lg font-bold">{hostName}</p>
                  </div>
                  <div className="*:p-2 divide-y">
                    <div>
                      <p className="text-center text-lg font-bold">
                        {property.hostNumReviews}
                      </p>
                      <p className="text-center">Reviews</p>
                    </div>
                    <div>
                      <p className="text-center text-lg font-bold">
                        {property.hostRating}
                      </p>
                      <p className="text-center">Rating</p>
                    </div>
                  </div>
                </CardContent>
              </Card>
            </section>
          )}

          <section>
            <h2 className="subheading border-t pb-2 pt-4">House rules</h2>
            <div className="overflow-x-auto">
              <div className="flex gap-4">
                {property.checkInTime && (
                  <CheckInTimeRule checkInTime={property.checkInTime} />
                )}
                {property.checkOutTime && (
                  <CheckOutTimeRule checkOutTime={property.checkOutTime} />
                )}
                {property.petsAllowed && (
                  <PetsRule petsAllowed={property.petsAllowed} />
                )}
                {property.smokingAllowed !== null && (
                  <SmokingRule smokingAllowed={property.smokingAllowed} />
                )}
              </div>
            </div>
            {property.cancellationPolicy !== null && (
              <div>
                <h3 className="pb-2 pt-4 font-bold">Cancellation Policy</h3>
                <p>
                  {getCancellationPolicyDescription(
                    property.cancellationPolicy,
                  )}
                </p>
              </div>
            )}
          </section>

          {property.additionalCheckInInfo !== null && (
            <section>
              <h2 className="subheading border-t pb-2 pt-4">
                Check-in information
              </h2>
              <p>
                {property.additionalCheckInInfo === "self"
                  ? "Self check-in"
                  : property.additionalCheckInInfo}
              </p>
            </section>
          )}

          {offer && (
            <div className="flex justify-end">
              <ShareOfferDialog
                id={offer.id}
                isRequest={false}
                propertyName={property.name}
              />
            </div>
          )}
        </div>

        {sidebar && (
          <div className="hidden shrink-0 md:block md:w-5/12 lg:w-96">
            <div className="sticky top-[calc(var(--header-height)+1rem)]">
              {sidebar}
            </div>
          </div>
        )}

        {mobileBottomCard && (
          <div className="fixed inset-x-0 bottom-16 md:hidden">
            {mobileBottomCard}
          </div>
        )}
      </div>
    </div>
  );
}

// function HostVerificationInfo({ hostName }: { hostName: string }) {
//   return (
//     <div className="flex flex-col gap-2  p-4 ">
//       <div className="space-y-1">
//         <p className="text-lg font-semibold">{`${hostName}'s confirmed information`}</p>
//       </div>
//       <div className="flex items-center gap-2">
//         <CheckIcon className="size-5" />
//         <p className="text-md font-semibold">Email Address</p>
//       </div>
//       <div className="flex items-center gap-2">
//         <CheckIcon className="size-5" />
//         <p className="text-md font-semibold">Phone Number</p>
//       </div>
//       <p className="text-sm text-muted-foreground">
//         {hostName} is a verified host
//       </p>
//     </div>
//   );
// }
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/components/propertyPages/sidebars/priceCards/RequestToBookOrBookNowPriceCard.tsx</div>
<pre><code>
import { useState, useEffect } from "react";
import { format } from "date-fns";
import { Calendar } from "@/components/ui/calendar";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { cn, formatCurrency, getNumNights } from "@/utils/utils";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";

import { Input } from "@/components/ui/input";
import { Slider } from "@/components/ui/slider";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import {
  ChevronDown,
  ChevronUp,
  Info,
  Clock,
  CheckCircle,
  Calendar as CalendarIcon,
} from "lucide-react";
import { useRouter } from "next/router";
import PriceBreakdown from "./PriceBreakdown";

import PriceCardInformation from "./PriceCardInformation";
import BookNowBtn from "../actionButtons/BookNowBtn";
import RequestToBookBtn from "../actionButtons/RequestToBookBtn";
import { PropertyPageData } from "../../PropertyPage";
import { api } from "@/utils/api";
import { Skeleton } from "@/components/ui/skeleton";
import { isNumber } from "lodash";
import { useGetOriginalPropertyPricing } from "@/utils/payment-utils/useGetOriginalPropertyPricing";
import Link from "next/link";
import { ZodUndefined } from "zod";

export type RequestToBookDetails = {
  checkIn: Date;
  checkOut: Date;
  numGuests: number;
  travelerOfferedPriceBeforeFees?: number;
};

export default function RequestToBookOrBookNowPriceCard({
  property,
}: {
  property: PropertyPageData;
}) {
  const minDiscount = 0; //where we put host discounts
  const maxDiscount = property.requestToBookMaxDiscountPercentage;

  const router = useRouter();
  const { query } = router;
  const checkIn = query.checkIn
    ? new Date(query.checkIn as string)
    : new Date();
  const checkOut = query.checkOut
    ? new Date(query.checkOut as string)
    : new Date();
  const numGuests = !query.numGuests
    ? property.maxNumGuests
    : parseInt(query.numGuests as string) > property.maxNumGuests
      ? property.maxNumGuests
      : parseInt(query.numGuests as string);

  const { data: bookedDates } = api.calendar.getReservedDates.useQuery({
    propertyId: property.id,
  });

  // <---------------- Calculate the price here  ---------------->
  const numOfNights = getNumNights(checkIn, checkOut);
  const propertyPricing = useGetOriginalPropertyPricing({
    property,
    checkIn,
    checkOut,
    numGuests,
  });

  const propertyPricingPerNightAfterTierDiscount =
    propertyPricing.originalPriceAfterTierDiscount !== undefined
      ? propertyPricing.originalPriceAfterTierDiscount / numOfNights
      : undefined;


  const [error, setError] = useState<React.ReactNode | null>(null);
  const [requestAmount, setRequestAmount] = useState(
    propertyPricingPerNightAfterTierDiscount,
  );
  // Monitor `originalPrice` for errors
  useEffect(() => {
    if (propertyPricingPerNightAfterTierDiscount === undefined) {
      setError(
        <>
          Original price is unavailable.
          <br />
          Please adjust your dates.
        </>,
      );
    } else {
      setError(null); // Clear the error when `originalPrice` is valid
      //setPropertyprice into state
      setRequestAmount(propertyPricingPerNightAfterTierDiscount);
    }
  }, [propertyPricingPerNightAfterTierDiscount]);

  // ----------------

  const initialRequestToBook: RequestToBookDetails = {
    checkIn: checkIn,
    checkOut: checkOut,
    numGuests: numGuests,
  };

  const [date, setDate] = useState({
    from: initialRequestToBook.checkIn,
    to: initialRequestToBook.checkOut,
  });
  const [unsetDate, setUnsetDate] = useState<{
    checkIn?: Date;
    checkOut?: Date;
  }>({
    checkIn: initialRequestToBook.checkIn,
    checkOut: initialRequestToBook.checkOut,
  });
  const [showPriceBreakdown, setShowPriceBreakdown] = useState<boolean>(false);
  const [isCalendarOpen, setIsCalendarOpen] = useState(false);
  const [showRequestInput, setShowRequestInput] = useState(false);

  const [requestPercentage, setRequestPercentage] = useState(0);
  const [selectedPreset, setSelectedPreset] = useState<number | null>(
    propertyPricingPerNightAfterTierDiscount
      ? propertyPricingPerNightAfterTierDiscount
      : null,
  );
  const [requestToBook, setRequestToBook] =
    useState<RequestToBookDetails>(initialRequestToBook);
  const [rawRequestAmount, setRawRequestAmount] = useState(
    propertyPricingPerNightAfterTierDiscount
      ? formatCurrency(propertyPricingPerNightAfterTierDiscount)
      : "",
  ); // Raw input for typing

  useEffect(() => {
    if (query.checkIn && query.checkOut && query.numGuests) {
      const checkIn = new Date(query.checkIn as string);
      const checkOut = new Date(query.checkOut as string);
      const numGuests = !query.numGuests
        ? property.maxNumGuests
        : parseInt(query.numGuests as string) > property.maxNumGuests
          ? property.maxNumGuests
          : parseInt(query.numGuests as string);
      setDate({ from: checkIn, to: checkOut });
      setRequestToBook((prevState) => ({
        ...prevState,
        checkIn,
        checkOut,
        numGuests,
      }));
      console.log(requestAmount);
    }
  }, [
    query.checkIn,
    query.checkOut,
    query.numGuests,
    requestAmount,
    property.maxNumGuests,
  ]);

  const updateRequestToBook = (updates: Partial<RequestToBookDetails>) => {
    setRequestToBook((prevState) => ({
      ...prevState,
      ...updates,
    }));

    // Update URL query params
    void router.push(
      {
        query: {
          ...query,
          ...updates,
          checkIn: updates.checkIn?.toISOString() ?? query.checkIn,
          checkOut: updates.checkOut?.toISOString() ?? query.checkOut,
        },
      },
      undefined,
      { shallow: true },
    );
  };

  const handleGuestChange = (value: string) => {
    const numGuests = parseInt(value);
    updateRequestToBook({ numGuests });
  };
  // Only set presetOptions if randomPrice is available
  const presetOptions = [
    {
      price: propertyPricingPerNightAfterTierDiscount,
      label: "Buy Now",
      percentOff: 0,
    },
    {
      price: propertyPricingPerNightAfterTierDiscount
        ? propertyPricingPerNightAfterTierDiscount * 0.9
        : undefined,
      label: "Better request",
      percentOff: Math.ceil(property.requestToBookMaxDiscountPercentage / 2),
    },
    {
      price:
        propertyPricingPerNightAfterTierDiscount !== undefined
          ? propertyPricingPerNightAfterTierDiscount * 0.8
          : undefined,
      label: "Good request",
      percentOff: property.requestToBookMaxDiscountPercentage,
    },
  ];

  useEffect(() => {
    if (showRequestInput) {
      const newPercentage = Math.round(
        ((propertyPricingPerNightAfterTierDiscount! - requestAmount!) /
          propertyPricingPerNightAfterTierDiscount!) *
          100,
      );
      setRequestPercentage(
        Math.max(minDiscount, Math.min(newPercentage, maxDiscount)),
      );
    }
  }, [
    showRequestInput,
    requestAmount,
    propertyPricingPerNightAfterTierDiscount,
    maxDiscount,
  ]);

  const handleRequestChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const inputValue = e.target.value;

    // Allow only numeric input or empty string
    if (/^\d*$/.test(inputValue)) {
      setRawRequestAmount(inputValue); // Update raw input state
      const parsedValue = inputValue ? parseInt(inputValue, 10) : 0;
      setRequestAmount(parsedValue); // Update parsed value
      setSelectedPreset(null);
    }
  };

  const handleRequestBlur = () => {
    setRawRequestAmount(formatCurrency(requestAmount!)); // Format the value on blur
  };
  const handleSliderChange = (value: number[]) => {
    const newRequestAmount = Math.round(
      propertyPricingPerNightAfterTierDiscount! * (1 - value[0]! / 100),
    );
    setRequestAmount(newRequestAmount);
    setRawRequestAmount(formatCurrency(newRequestAmount));
    setRequestPercentage(value[0]!);
    setSelectedPreset(null);
  };

  const getRequestLikelihood = () => {
    if (
      requestPercentage <=
      property.requestToBookMaxDiscountPercentage * 0.1
    ) {
      return "Good chance of acceptance";
    }
    if (
      requestPercentage <=
      property.requestToBookMaxDiscountPercentage * 0.5
    ) {
      return "Moderate chance of acceptance";
    }
    return "Lower chance of acceptance";
  };

  const handlePresetSelect = (price: number) => {
    setRequestAmount(price);
    setRawRequestAmount(formatCurrency(price)); // Update raw input state

    const newPercentage = Math.round(
      ((propertyPricingPerNightAfterTierDiscount! - price) /
        propertyPricingPerNightAfterTierDiscount!) *
        100,
    );
    setRequestPercentage(
      Math.max(minDiscount, Math.min(newPercentage, maxDiscount)),
    );
    setSelectedPreset(price);
  };

  return (
    <Card className="w-full bg-gray-50 shadow-lg">
      <CardContent className="flex flex-col gap-y-2 rounded-xl md:p-2 xl:p-6">
        <Popover open={isCalendarOpen} onOpenChange={setIsCalendarOpen}>
          <PopoverTrigger asChild>
            <button className="grid w-full grid-cols-2 overflow-hidden rounded-lg border text-left focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2">
              <div className="border-r p-3">
                <div className="text-sm text-muted-foreground">CHECK-IN</div>
                <div className="text-base font-medium">
                  {format(date.from, "MM/dd/yyyy")}
                </div>
              </div>
              <div className="p-3">
                <div className="text-sm text-muted-foreground">CHECK-OUT</div>
                <div className="text-base font-medium">
                  {format(date.to, "MM/dd/yyyy")}
                </div>
              </div>
            </button>
          </PopoverTrigger>
          <PopoverContent className="w-auto p-0" align="start">
            <Calendar
              initialFocus
              mode="range"
              defaultMonth={unsetDate.checkIn}
              selected={{
                from: unsetDate.checkIn,
                to: unsetDate.checkOut,
              }}
              onSelect={(selectedDate) => {
                if (selectedDate?.from && selectedDate.to) {
                  setDate({ from: selectedDate.from, to: selectedDate.to });
                  updateRequestToBook({
                    checkIn: selectedDate.from,
                    checkOut: selectedDate.to,
                  });
                  setIsCalendarOpen(false);
                }
                setUnsetDate({
                  checkIn: selectedDate?.from,
                  checkOut: selectedDate?.to,
                });
              }}
              numberOfMonths={2}
              disabled={(date) =>
                date < new Date() ||
                (bookedDates?.some((bookedDate) => {
                  return (
                    date >= new Date(bookedDate.start) &&
                    date <= new Date(bookedDate.end)
                  );
                }) ??
                  false)
              }
            />
          </PopoverContent>
        </Popover>

        <Popover>
          <PopoverTrigger asChild>
            <button
              className={cn(
                "w-full overflow-hidden rounded-lg border p-4 text-left focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
              )}
            >
              <div className="text-sm text-muted-foreground">GUESTS</div>
              <div className="text-base font-medium">
                {requestToBook.numGuests} guests
              </div>
            </button>
          </PopoverTrigger>
          <PopoverContent className="w-auto p-0" align="start">
            <div className="p-4">
              <div className="w-[200px]">
                {Array.from({ length: property.maxNumGuests }, (_, index) => {
                  const num = index + 1; // Start from 1, not 0
                  return (
                    <div
                      key={num}
                      onClick={() => handleGuestChange(num.toString())} // Handle selection
                      className={cn(
                        "cursor-pointer rounded-lg p-1 hover:bg-gray-200",
                        requestToBook.numGuests === num && "font-semibold",
                      )}
                    >
                      {num} guest{num !== 1 ? "s" : ""}
                    </div>
                  );
                })}
              </div>
            </div>
          </PopoverContent>
        </Popover>

        {showRequestInput ? (
          <div className="space-y-6">
            <div className="flex items-center justify-between">
              <h3 className="text-lg font-semibold">Pricing Options</h3>
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger>
                    <Info className="h-4 w-4 text-muted-foreground" />
                  </TooltipTrigger>
                  <TooltipContent>
                    <p>
                      These options offer estimated chances of request
                      acceptance.
                    </p>
                  </TooltipContent>
                </Tooltip>
              </TooltipProvider>
            </div>
            <div className="grid grid-cols-3 gap-2 lg:gap-4">
              {
                presetOptions.map((option, index) => (
                  <button
                    key={index}
                    onClick={() =>
                      handlePresetSelect(
                        propertyPricingPerNightAfterTierDiscount! *
                          ((100 - option.percentOff) / 100),
                      )
                    }
                    className={cn(
                      "flex flex-col items-center justify-between rounded-lg border py-3 text-center transition-colors lg:p-4",
                      selectedPreset === option.price
                        ? "border-primary bg-primary/10"
                        : "border-gray-200 hover:border-primary/50",
                      option.label === "Book Now" && "font-semibold",
                    )}
                  >
                    <div className="lg:text-md text-sm font-bold">
                      {formatCurrency(
                        propertyPricingPerNightAfterTierDiscount! *
                          ((100 - option.percentOff) / 100),
                      )}
                    </div>
                    <div className="text-xs leading-5 text-muted-foreground lg:text-sm">
                      {option.label}
                    </div>
                    {option.percentOff > 0 && (
                      <div className="w-full text-center text-xs font-medium text-green-600">
                        {option.percentOff}% off
                      </div>
                    )}
                  </button>
                ))}
            </div>

            <div>
              <h3 className="mb-2 text-sm font-medium italic text-muted-foreground">
                Or Name Your Price
              </h3>
              <div className="space-y-4">
                <div className="flex items-center gap-4">
                  <div className="relative flex-1">
                    <div className="flex flex-row items-end gap-x-2">
                      <Input
                        placeholder="Enter request"
                        value={rawRequestAmount}
                        onChange={handleRequestChange}
                        onBlur={handleRequestBlur}
                        className="pl-7"
                      />
                      <p className="text-xs italic leading-tight text-muted-foreground">
                        per night
                      </p>
                    </div>
                  </div>
                  <div className="text-right">
                    <span className="text-lg font-medium text-green-600">
                      {Number.isNaN(requestPercentage)
                        ? ""
                        : `${requestPercentage}% off`}
                    </span>
                  </div>
                </div>

                <div className="space-y-2">
                  <div className="relative">
                    <Slider
                      value={[requestPercentage]}
                      onValueChange={handleSliderChange}
                      max={maxDiscount}
                      min={minDiscount}
                      step={1}
                      className="w-full"
                    />
                    <div
                      className="pointer-events-none absolute inset-0"
                      style={{
                        background:
                          "linear-gradient(to right, #22c55e, #ef4444)",
                        opacity: 0.2,
                      }}
                    />
                  </div>
                  <div className="flex justify-between text-xs text-muted-foreground">
                    <div>High Acceptance Probability</div>
                    <div>Low Acceptance Probability</div>
                  </div>
                </div>

                <div
                  className={cn(
                    "text-center text-sm font-medium",
                    requestPercentage <= 10
                      ? "text-green-600"
                      : requestPercentage <= 15
                        ? "text-yellow-600"
                        : "text-red-600",
                  )}
                >
                  {getRequestLikelihood()}
                </div>

                <div className="space-y-2 text-sm">
                  <div className="flex items-center gap-2">
                    <Clock className="h-4 w-4" />
                    <span>
                      Hosts have 24 hours to accept or reject your request.
                    </span>
                  </div>
                  <div className="flex items-center gap-2">
                    <CheckCircle className="h-4 w-4" />
                    <span>Accepted requests will be automatically booked.</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <Info className="h-5 w-5" />
                    <span>
                      You can place multiple requests. Overlapping requests will
                      be canceled if one is accepted.
                    </span>
                  </div>
                </div>

                <div className="flex items-center justify-between gap-4">
                  <RequestToBookBtn
                    btnSize="sm"
                    requestToBook={requestToBook}
                    property={property}
                    requestPercentage={requestPercentage} // we are getting the request price by using the percentage and saving that in the url for the checkout to get the price
                  />
                  <Button
                    variant="outline"
                    className="flex-1"
                    onClick={() => setShowRequestInput(false)}
                  >
                    Cancel request
                  </Button>
                </div>
              </div>
            </div>
          </div>
        ) : propertyPricing.isLoading ? (
          <div className="space-y-2 p-2">
            <Skeleton className="h-6 w-3/4" />
            <Skeleton className="h-10 w-full" />
            <Skeleton className="h-4 w-1/3" />
            <Skeleton className="h-10 w-full" />
          </div>
        ) : isNumber(propertyPricingPerNightAfterTierDiscount) ? (
          <>
            <div>
              <div className="mb-1 text-2xl font-bold">Book it now for</div>
              <div className="flex items-baseline gap-2">
                <div className="text-4xl font-bold text-primary lg:text-5xl">
                  {propertyPricingPerNightAfterTierDiscount &&
                  propertyPricing.originalPrice &&
                  propertyPricingPerNightAfterTierDiscount <
                    propertyPricing.originalPrice / numOfNights ? (
                    <div className="flex flex-row items-start gap-x-2 text-base">
                      <p className="text-3xl">
                        {formatCurrency(
                          propertyPricingPerNightAfterTierDiscount,
                        )}
                      </p>
                      <p className="text-muted-foreground line-through">
                        {formatCurrency(
                          propertyPricing.originalPrice / numOfNights,
                        )}
                      </p>
                    </div>
                  ) : (
                    <span>
                      {formatCurrency(propertyPricingPerNightAfterTierDiscount)}
                    </span>
                  )}
                </div>
                <span className="text-xl text-muted-foreground">Per Night</span>
              </div>
              <Button
                variant="link"
                className="mt-1 flex items-center gap-1 px-0 text-muted-foreground"
                onClick={() => setShowPriceBreakdown(!showPriceBreakdown)}
              >
                Price Breakdown
                {showPriceBreakdown ? (
                  <ChevronUp className="h-4 w-4" />
                ) : (
                  <ChevronDown className="h-4 w-4" />
                )}
              </Button>
              {showPriceBreakdown && (
                <PriceBreakdown
                  requestToBookDetails={requestToBook}
                  property={property}
                  requestAmount={requestAmount! * numOfNights}
                />
              )}
            </div>

            <div className="grid grid-cols-2 gap-1">
              <Button
                variant="outline"
                className={`col-auto w-full px-2 text-sm tracking-tight lg:text-base ${
                  !property.bookItNowEnabled ? "col-span-2" : ""
                }`}
                onClick={() => setShowRequestInput(true)}
              >
                Place request
              </Button>
              {property.bookItNowEnabled && (
                <BookNowBtn property={property} requestToBook={requestToBook} />
              )}
            </div>
          </>
        // ) : propertyPricing.casamundoPrice === "unavailable" ? (
        //   <div className="flex flex-col items-center justify-center">
        //     <div className="flex items-center gap-2">
        //       <Info className="h-4 w-4 text-red-500" />
        //       <div className="mb-1 text-2xl font-bold text-red-500">
        //         Dates Unavailable
        //       </div>
        //     </div>
        //     <p className="pb-4 text-center text-sm text-muted-foreground">
        //       The selected dates are no longer available. Try adjusting your
        //       search.
        //     </p>
        //     <p className="text-md pb-4 text-center text-muted-foreground">
        //       Pricing will update once new dates are selected.
        //     </p>
        //     <Button
        //       variant="darkPrimary"
        //       className="mt-2 flex min-w-full"
        //       onClick={() => setIsCalendarOpen(true)}
        //     >
        //       <div className="flex items-center gap-2">
        //         <CalendarIcon className="h-4 w-4" />
        //         Change Dates
        //       </div>
        //     </Button>
        //   </div>
        ) : (
          // <>
          //   <div className="flex flex-col items-center justify-center">
          //     <div className="flex items-center gap-2">
          //       <Info className="h-4 w-4 text-red-500" />
          //       <div className="mb-1 text-2xl font-bold text-red-500">
          //         Sorry, an error occured
          //       </div>
          //     </div>
          //     <p className="pb-4 text-center text-sm text-muted-foreground">
          //       Please try again. If the error persists, send us a message using
          //       concierge or choose a new property.
          //     </p>
          //     <Button
          //       variant="darkPrimary"
          //       onClick={() => propertyPricing.refetchCasamundoPrice()}
          //     >
          //       Try Again
          //     </Button>
          //   </div>
          // </>
          <>
            <div>
              <div className="mb-1 text-2xl font-bold">Request to book for</div>
              <div className="flex items-baseline gap-2">
                <div className="text-4xl font-bold text-primary lg:text-5xl">
                  {formatCurrency(propertyPricingPerNightAfterTierDiscount!)}
                </div>
                <span className="text-xl text-muted-foreground">Per Night</span>
              </div>
              <Button
                variant="link"
                className="mt-1 flex items-center gap-1 px-0 text-muted-foreground"
                onClick={() => setShowPriceBreakdown(!showPriceBreakdown)}
              >
                Price Breakdown
                {showPriceBreakdown ? (
                  <ChevronUp className="h-4 w-4" />
                ) : (
                  <ChevronDown className="h-4 w-4" />
                )}
              </Button>
              {showPriceBreakdown && (
                <PriceBreakdown
                  requestToBookDetails={requestToBook}
                  property={property}
                  requestAmount={propertyPricingPerNightAfterTierDiscount! * numOfNights}
                />
              )}
            </div>

            <div className="grid grid-cols-2 gap-1">
              <Button
                variant="outline"
                className={`col-auto w-full px-2 text-sm tracking-tight lg:text-base ${
                  !property.bookItNowEnabled ? "col-span-2" : ""
                }`}
                onClick={() => setShowRequestInput(true)}
              >
                Place request
              </Button>
              {property.bookItNowEnabled && (
                <BookNowBtn property={property} requestToBook={requestToBook} />
              )}
            </div>
          </>
        )}
        <p className="my-1 text-center text-sm text-muted-foreground">
          You won&apos;t be charged yet
        </p>
        <Link
          href="/why-list"
          className="block text-center text-primary hover:underline"
        >
          Have a property? List now 
        </Link>
        <PriceCardInformation />
      </CardContent>
    </Card>
  );
}
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/server/api/routers/messagesRouter.ts</div>
<pre><code>
import { env } from "@/env";
import { createTRPCRouter, publicProcedure } from "@/server/api/trpc";
import { db } from "@/server/db";
import { conversationParticipants, users } from "@/server/db/schema";
import { zodString } from "@/utils/zod-utils";
import { and, eq, inArray, ne } from "drizzle-orm";
import { z } from "zod";
import { conversations, messages } from "./../../db/schema/tables/messages";
import { protectedProcedure } from "./../trpc";
import { sendSlackMessage } from "@/server/slack";
import { TRPCError } from "@trpc/server";

const isProduction = process.env.NODE_ENV === "production";
const baseUrl = isProduction
  ? "https://www.tramona.com"
  : "http://localhost:3000";

const ADMIN_ID = env.TRAMONA_ADMIN_USER_ID;

export async function fetchUsersConversations(userId: string) {
  return await db.query.users.findFirst({
    where: eq(users.id, userId),
    columns: {},
    with: {
      conversations: {
        columns: {},
        with: {
          conversation: {
            with: {
              messages: {
                orderBy: (messages, { desc }) => [desc(messages.createdAt)],
                limit: 1,
              },
              participants: {
                with: {
                  user: {
                    columns: {
                      id: true,
                      name: true,
                      email: true,
                      image: true,
                    },
                  },
                },
              },
            },
          },
        },
      },
    },
  });
}

export async function fetchConversationWithAdmin(userId: string) {
  console.log("calling fetch converasation with admin");
  const result = await db.query.users.findFirst({
    where: eq(users.id, userId),
    with: {
      conversations: {
        with: {
          conversation: {
            with: {
              participants: {
                with: {
                  user: {
                    columns: {
                      id: true,
                      name: true,
                      image: true,
                    },
                  },
                },
              },
            },
          },
        },
      },
    },
  });

  // Check if conversation contains two participants
  // and check if admin id is in there
  const conversationWithAdmin = result?.conversations.find(
    (conv) =>
      conv.conversation.participants.length === 2 &&
      conv.conversation.participants.some(
        (participant) => participant.user.id === ADMIN_ID,
      ),
  );

  return conversationWithAdmin?.conversation.id ?? null;
}

export async function fetchConversationWithHost(
  userId: string,
  hostId: string,
) {
  const result = await db.query.users.findFirst({
    where: eq(users.id, userId),
    with: {
      conversations: {
        with: {
          conversation: {
            with: {
              participants: {
                with: {
                  user: {
                    columns: {
                      id: true,
                      name: true,
                      image: true,
                    },
                  },
                },
              },
            },
          },
        },
      },
    },
  });

  // Check if conversation contains two participants
  // and check if admin id is in there
  const conversationWithHost = result?.conversations.find(
    (conv) =>
      conv.conversation.participants.length === 2 &&
      conv.conversation.participants.some(
        (participant) => participant.user.id === hostId,
      ),
  );

  return conversationWithHost?.conversation.id ?? null;
}

export async function fetchConversationWithOffer(
  userId: string,
  offerId: string,
) {
  const result = await db.query.users.findFirst({
    where: eq(users.id, userId),
    with: {
      conversations: {
        with: {
          conversation: {
            columns: {
              offerId: true,
            },
            with: {
              participants: {
                with: {
                  user: {
                    columns: {
                      id: true,
                      name: true,
                      image: true,
                    },
                  },
                },
              },
            },
          },
        },
      },
    },
  });

  const offerExists = result?.conversations.find(
    (convo) => convo.conversation.offerId === offerId,
  );

  const conversationId = offerExists?.conversationId;

  return conversationId;
}

async function generateConversation(
  conversationName?: string,
  offerId?: string,
) {
  return await db
    .insert(conversations)
    .values({ name: conversationName ? conversationName : null, offerId })
    .returning({ id: conversations.id })
    .then((res) => res[0]!.id);
}

export async function createConversationWithAdmin(userId: string) {
  const conversationId = await generateConversation();

  await db.insert(conversationParticipants).values([
    { conversationId, userId: userId },
    { conversationId, userId: ADMIN_ID },
  ]);

  return conversationId;
}

export async function createConversationWithHost(
  userId: string,
  hostId: string,
) {
  const conversationId = await generateConversation();

  await db.insert(conversationParticipants).values([
    { conversationId, userId: userId },
    { conversationId, userId: hostId },
  ]);

  return conversationId;
}

export async function createConversationWithOfferHelper(
  userId: string,
  offerHostOrAllAdmins: string,
  propertyName: string,
  offerId: string,
) {
  const conversationId = await generateConversation(propertyName, offerId);

  await db.insert(conversationParticipants).values([
    { conversationId, userId: userId },
    { conversationId, userId: offerHostOrAllAdmins },
  ]);

  return conversationId;
}

async function addUserToConversation(userId: string, conversationId: string) {
  await db
    .insert(conversationParticipants)
    .values({ conversationId: conversationId, userId: userId });
}

export async function addTwoUserToConversation(
  user1Id: string,
  user2Id: string,
) {
  const conversationId = await generateConversation();

  await db.insert(conversationParticipants).values([
    { conversationId, userId: user1Id },
    { conversationId, userId: user2Id },
  ]);

  return conversationId;
}

async function verifyConversationExists(conversationId: string) {
  const conversation = await db.query.conversations.findFirst({
    where: eq(conversations.id, conversationId),
  });
  return !!conversation;
}

export const messagesRouter = createTRPCRouter({
  getConversations: protectedProcedure.query(async ({ ctx }) => {
    const result = await fetchUsersConversations(ctx.user.id);

    if (result) {
      const orderedConversations = result.conversations.map(
        ({ conversation }) => ({
          ...conversation,
          participants: conversation.participants
            .filter((p) => p.user.id !== ctx.user.id)
            .map((p) => p.user)
            .filter(Boolean),
        }),
      );

      // Order conversations by the most recent activity (conversation or message creation)
      orderedConversations.sort((a, b) => {
        // Get the conversation's createdAt date
        const aConversationDate = new Date(a.createdAt);
        const bConversationDate = new Date(b.createdAt);

        // Get the latest message's createdAt date, or use the conversation's createdAt date if no messages
        const aLatestMessageDate = a.messages[0]
          ? new Date(a.messages[0].createdAt)
          : aConversationDate;
        const bLatestMessageDate = b.messages[0]
          ? new Date(b.messages[0].createdAt)
          : bConversationDate;

        // Use the most recent of the two dates for comparison
        const aMostRecentDate =
          aLatestMessageDate > aConversationDate
            ? aLatestMessageDate
            : aConversationDate;
        const bMostRecentDate =
          bLatestMessageDate > bConversationDate
            ? bLatestMessageDate
            : bConversationDate;

        // Sort in descending order of the most recent activity
        return bMostRecentDate.getTime() - aMostRecentDate.getTime();
      });

      return orderedConversations;
    }

    return [];
  }),

  createConversationWithAdmin: protectedProcedure.mutation(async ({ ctx }) => {
    const conversationId = await fetchConversationWithAdmin(ctx.user.id);

    // Create conversation with admin if it doesn't exist
    if (!conversationId) {
      return await createConversationWithAdmin(ctx.user.id);
    }

    return conversationId;
  }),

  createConversationHostWithUser: protectedProcedure
    .input(z.object({ userId: zodString() }))
    .mutation(async ({ ctx, input }) => {
      const conversationId = await fetchConversationWithHost(
        input.userId,
        ctx.user.id,
      );

      if (!conversationId) {
        const newConversationId = await createConversationWithHost(
          ctx.user.id,
          input.userId,
        );
        return { id: newConversationId };
      }

      return { id: conversationId };
    }),

  createConversationWithHost: protectedProcedure
    .input(z.object({ hostId: zodString() }))
    .mutation(async ({ ctx, input }) => {
      const conversationId = await fetchConversationWithHost(
        ctx.user.id,
        input.hostId,
      );

      if (!conversationId) {
        return await createConversationWithHost(ctx.user.id, input.hostId);
      }

      return conversationId;
    }),

  // for guest only
  createConversationWithAdminFromGuest: publicProcedure
    .input(
      z.object({
        sessionToken: z.string(),
      }),
    )
    .mutation(async ({ input }) => {
      const tempUser = await db.query.users.findFirst({
        where: eq(users.sessionToken, input.sessionToken),
      });

      if (!tempUser) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Guest Temporary User not found",
        });
      }

      let conversationId = null;
      conversationId = await fetchConversationWithAdmin(tempUser.id);
      // Create conversation with admin if it doesn't exist
      if (!conversationId) {
        conversationId = await createConversationWithAdmin(tempUser.id);
      }

      return { tempUserId: tempUser.id, conversationId: conversationId };
    }),

  createOrFetchConversationWithOffer: protectedProcedure
    .input(
      z.object({
        offerId: z.string(),
        offerHostId: z.union([z.string(), z.null()]),
        offerPropertyName: z.string(),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      const conversationExistId = await fetchConversationWithOffer(
        ctx.user.id,
        input.offerId,
      );
      console.log(conversationExistId, "converation exist");

      //determine if the conversation will be with the host or the admin
      const offerHostOrAllAdmins = input.offerHostId
        ? input.offerHostId
        : ADMIN_ID;

      // Create conversation with host if it doesn't exist
      if (!conversationExistId) {
        return await createConversationWithOfferHelper(
          ctx.user.id,
          offerHostOrAllAdmins,
          input.offerPropertyName,
          input.offerId,
        );
      }
      return conversationExistId;
    }),

  addUserToConversation: publicProcedure
    .input(
      z.object({
        userId: zodString(),
        conversationId: zodString(),
      }),
    )
    .mutation(async ({ input }) => {
      await addUserToConversation(input.userId, input.conversationId);
    }),

  setMessageToRead: protectedProcedure
    .input(
      z.object({
        messageId: zodString(),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      // TODO: add error checking
      return await ctx.db
        .update(messages)
        .set({ read: true })
        .where(eq(messages.id, input.messageId));
    }),
  addTwoUsersToConversation: protectedProcedure
    .input(
      z.object({
        user1Id: zodString(),
        user2Id: zodString(),
      }),
    )
    .mutation(async ({ input }) => {
      const conversationId = await addTwoUserToConversation(
        input.user1Id,
        input.user2Id,
      );
      return conversationId;
    }),

  getParticipantsPhoneNumbers: protectedProcedure
    .input(z.object({ conversationId: zodString() }))
    .query(async ({ ctx, input }) => {
      const participants = await db
        .select({
          id: users.id,
          phoneNumber: users.phoneNumber,
          lastTextAt: users.lastTextAt,
          isWhatsApp: users.isWhatsApp,
        })
        .from(conversationParticipants)
        .innerJoin(users, eq(conversationParticipants.userId, users.id))
        .where(
          and(
            eq(conversationParticipants.conversationId, input.conversationId),
            ne(conversationParticipants.userId, ctx.user.id),
          ),
        );
      return participants;
    }),

  getNumUnreadMessages: protectedProcedure.query(async ({ ctx }) => {
    return await db.query.users
      .findFirst({
        where: eq(users.id, ctx.user.id),
        columns: {},
        with: {
          conversations: {
            columns: {},
            with: {
              conversation: {
                columns: {},
                with: {
                  messages: {
                    columns: { id: true },
                    where: and(
                      eq(messages.read, false),
                      ne(messages.userId, ctx.user.id),
                    ),
                  },
                },
              },
            },
          },
        },
      })
      .then((res) => {
        if (!res) return 0; // No result found, so return 0 unread messages

        // Iterate over conversations and calculate sum of message lengths
        let totalLength = 0;
        res.conversations.forEach((conv) => {
          totalLength += conv.conversation.messages.length;
        });
        return totalLength;
      });
  }),
  setMessagesToRead: protectedProcedure
    .input(
      z.object({
        unreadMessageIds: z.string().array(),
      }),
    )
    .mutation(async ({ input }) => {
      await db
        .update(messages)
        .set({ read: true })
        .where(inArray(messages.id, input.unreadMessageIds));
    }),
  sendAdminSlackMessage: protectedProcedure
    .input(
      z.object({
        message: z.string(),
        conversationId: z.string(),
        senderId: z.string(),
      }),
    )
    .mutation(async ({ input }) => {
      //find the receiver of the message
      const receiver = await db.query.conversationParticipants
        .findFirst({
          where: and(
            eq(conversationParticipants.conversationId, input.conversationId),
            ne(conversationParticipants.userId, input.senderId),
          ),
          with: {
            user: {
              columns: {
                id: true,
                email: true,
                role: true,
              },
            },
          },
        })
        .then((res) => res?.user);
      //check to see if the receipt is the admin
      if (receiver?.role !== "admin") return;
      //if admin then send slack from the to and from
      await sendSlackMessage({
        channel: "admin-messaging",
        isProductionOnly: false,
        text: [
          `*${receiver.email} sent a message to admin*`,
          `${input.message}`,
          `<${baseUrl}/messages?conversationId=${input.conversationId}|Click here to respond>`,
        ].join("\n"),
      });
    }),

  sendChatboxSlackMessage: publicProcedure
    .input(
      z.object({
        message: z.string(),
        conversationId: z.string(),
        senderId: z.string(),
      }),
    )
    .mutation(async ({ input }) => {
      //find the receiver of the message
      const receiver = await db.query.conversationParticipants
        .findFirst({
          where: and(
            eq(conversationParticipants.conversationId, input.conversationId),
            ne(conversationParticipants.userId, input.senderId),
          ),
          with: {
            user: {
              columns: {
                id: true,
                email: true,
                role: true,
              },
            },
          },
        })
        .then((res) => res?.user);

      const sender = await db.query.users.findFirst({
        where: eq(users.id, input.senderId),
      });

      function getSenderName() {
        if (sender) {
          if (sender.firstName === null || sender.lastName === null) {
            return "logged out user";
          } else {
            return sender.firstName + " " + sender.lastName;
          }
        }
      }
      await sendSlackMessage({
        channel: "chatbox",
        isProductionOnly: false,
        text: [
          `*${receiver?.email} received a message from ${getSenderName()}*`,
          `${input.message}`,
          `<${baseUrl}/messages?conversationId=${input.conversationId}|Click here to respond>`,
        ].join("\n"),
      });
    }),

  getConversationsWithAdmin: publicProcedure
    .input(
      z.object({
        userId: z.string().optional(),
        sessionToken: z.string().optional(),
      }),
    )
    .query(async ({ ctx, input }) => {
      let conversationId = null;
      let tempUser = null;
      if (
        ctx.session?.user.role === "admin" ||
        ctx.session?.user.role === "host"
      ) {
        return null;
      }
      if (!input.userId && input.sessionToken) {
        tempUser = await db.query.users.findFirst({
          where: eq(users.sessionToken, input.sessionToken),
        });
        if (tempUser) {
          conversationId = await fetchConversationWithAdmin(tempUser.id);
        } else {
          return null;
          // throw new TRPCError({
          //   code: "NOT_FOUND",
          //   message: "Guest Temporary User not found",
          // });
        }
      } else if (input.userId) {
        // if both userId and sessionToken are provided, userId will be used
        conversationId = await fetchConversationWithAdmin(input.userId);
      } else if (!input.userId && !input.sessionToken) {
        return null; // when the page renders for the first time, the tRPC call will hit here
      }

      if (!conversationId) {
        return null;
        // throw new TRPCError({
        //   code: "NOT_FOUND",
        //   message: "conversationId not found",
        // });
      }

      return { conversationId, tempUserId: tempUser?.id };
    }),

  createMessage: protectedProcedure
    .input(
      z.object({
        conversationId: z.string(),
        message: z.string(),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      const exists = await verifyConversationExists(input.conversationId);
      if (!exists) {
        throw new Error("Conversation not found");
      }
      // proceed with message creation
    }),
});
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/utils/messaging/useChatWithUser.ts</div>
<pre><code>
import { useRouter } from "next/router";
import { api } from "@/utils/api";
import { type TRPCError } from "@trpc/server";

export function useChatWithUser() {
  const router = useRouter();

  const { mutateAsync: createConversation } =
    api.messages.createConversationHostWithUser.useMutation();

  const chatWithUser = async (userId: string) => {
    try {
      const conversation = await createConversation({ userId });

      if (!conversation.id) {
        throw new Error("Failed to create conversation");
      }

      await new Promise((resolve) => setTimeout(resolve, 500));

      await router.push(`/host/messages?conversationId=${conversation.id}`);
    } catch (error) {
      const tRPCError = error as TRPCError;
      console.error("Failed to create conversation:", tRPCError.message);
    }
  };

  return chatWithUser;
}
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/utils/payment-utils/useGetOriginalPropertyPricing.ts</div>
<pre><code>
import { api } from "@/utils/api";
import { getNumNights, getApplicableBookItNowDiscount } from "@/utils/utils";
import { PropertyPageData } from "@/components/propertyPages/PropertyPage";
import { isNumber } from "lodash";
import { TRAVELER_MARKUP } from "../constants";

export const useGetOriginalPropertyPricing = ({
  property,
  checkIn,
  checkOut,
  numGuests,
  requestPercentage,
}: {
  property: PropertyPageData | undefined;
  checkIn: Date;
  checkOut: Date;
  numGuests: number;
  requestPercentage?: number;
}) => {
  // Always define these, even if property is undefined
  const isHospitable = property?.originalListingPlatform === "Hospitable";
  const numNights = getNumNights(checkIn, checkOut);

  // Host price logic
  const { data: hostPricePerNight, isLoading: isHostPriceLoading } =
    api.misc.getAverageHostPropertyPrice.useQuery(
      {
        property: property!,
        checkIn: checkIn.toISOString(),
        checkOut: checkOut.toISOString(),
        numGuests,
      },
      {
        enabled: isHospitable && !!property, // Ensure hooks always run but only fetch when valid
      },
    );
  console.log(hostPricePerNight);

  // Scraped property logic
  // const {
  //   data: casamundoPrice, // is this per night or total???
  //   isLoading: isCasamundoPriceLoading,
  //   refetch: refetchCasamundoPrice,
  // } = api.misc.scrapeAverageCasamundoPrice.useQuery(
  //   {
  //     offerId: property?.originalListingId ?? "", // Fallback for undefined property
  //     checkIn,
  //     numGuests: numGuests || 2,
  //     duration: numNights,
  //   },
  //   {
  //     enabled: !isHospitable && !!property, // Ensure hooks always run but only fetch when valid
  //     refetchOnWindowFocus: false,
  //   },
  // );
  const casamundoPrice = property?.tempCasamundoPrice;
  console.log("casamundoPrice", casamundoPrice);
  const isCasamundoPriceLoading = false;

  // Reserved dates
  const { data: bookedDates } = api.calendar.getReservedDates.useQuery(
    {
      propertyId: property?.id ?? 0, // Fallback for undefined property
    },
    {
      enabled: !!property, // Ensure hooks always run but only fetch when valid
    },
  );

  // Calculate original price
  const originalPricePerNight = isHospitable
    ? hostPricePerNight
    : isNumber(casamundoPrice)
      ? casamundoPrice
      : undefined;

  // Aggregate loading states
  const isLoading = isHospitable ? isHostPriceLoading : isCasamundoPriceLoading;
  const error =
    originalPricePerNight === undefined
      ? "Original price is unavailable."
      : null;

  //Multiply be num of nights becuase original price should be total price ++ MARKUP
  let originalPrice = originalPricePerNight
    ? Math.floor(originalPricePerNight * numNights * TRAVELER_MARKUP)
    : originalPricePerNight;

  // <--------------------------------- DISCOUNTS HERE --------------------------------->

  // 1.) apply traveler requested bid amount if request to book
  if (requestPercentage && originalPrice) {
    originalPrice = originalPrice * (1 - requestPercentage / 100);
  }
  //2.)apply discount tier discounts
  const hostDiscount = isHospitable //hostDiscount = percent off
    ? getApplicableBookItNowDiscount({
        discountTiers: property.discountTiers ?? [],
        checkIn,
      })
    : undefined;

  const originalPriceAfterTierDiscount = originalPrice
    ? originalPrice * (1 - (hostDiscount ?? 0) / 100)
    : undefined;

  // Return everything as undefined or valid values, but ensure hooks are always run
  return {
    originalPrice, //we really only care about this
    originalPriceAfterTierDiscount,
    isLoading,
    error,
    casamundoPrice: isHospitable ? undefined : casamundoPrice, //REVISIT ONCE SCRAPER IS FIXED  note: used if you want prices without modification
    hostPricePerNight: isHospitable ? hostPricePerNight : undefined, // note: used if you want prices without modification
    bookedDates,
    // refetchCasamundoPrice,
    isHostPriceLoading,
    isCasamundoPriceLoading,
  };
};
</code></pre>
</div>
<div class='section'>
<h2 class='section-title'>Messaging Components</h2>
<div class='file'>
<div class='file-name'>./src/components/messages/chat-with-admin-popover/MessagesPopover.tsx</div>
<pre><code>
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import supabase from "@/utils/supabase-client";
import { Button } from "../../ui/button";
import UserAvatar from "../../_common/UserAvatar";
import { Form, FormControl, FormField, FormItem } from "../../ui/form";
import { type ChatMessageType, useMessage } from "@/utils/store/messages";

import { Input } from "../../ui/input";
import { MessageCircleMore, ArrowUp, X } from "lucide-react";

import { useForm } from "react-hook-form";

import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import { PopoverClose } from "@radix-ui/react-popover";
import { api } from "@/utils/api";
import { nanoid } from "nanoid";
import { errorToast } from "@/utils/toasts";
import { useSession } from "next-auth/react";
import ListMessagesWithAdmin from "./ListMessagesWithAdmin";
import { useEffect, useState } from "react";

import { type MessageDbType } from "@/types/supabase.message";

export default function MessagesPopover({ isMobile, isHostOnboarding }: { isMobile: boolean, isHostOnboarding: boolean }) {
  const { data: session } = useSession();
  const [conversationId, setConversationId] = useState<string>("");
  const [tempToken, setTempToken] = useState<string>("");
  const [open, setOpen] = useState(false);

  const { mutateAsync: createOrRetrieveConversation } =
    api.messages.createConversationWithAdmin.useMutation();
  const { mutateAsync: createOrRetrieveConversationFromGuest } =
    api.messages.createConversationWithAdminFromGuest.useMutation();
  const { mutateAsync: createTempUserForGuest } =
    api.auth.createTempUserForGuest.useMutation();
  const { data: conversationIdAndTempUserId } =
    api.messages.getConversationsWithAdmin.useQuery(
      {
        userId: session?.user.id,
        sessionToken: tempToken,
      },
      {
        enabled: Boolean(session?.user.id ?? tempToken),
      },
    );
  const { mutateAsync: sendChatboxSlackMessage } =
    api.messages.sendChatboxSlackMessage.useMutation();
  const { fetchInitialMessages, conversations } = useMessage();
  // const setOptimisticIds = useMessage((state) => state.setOptimisticIds);

  const messages = conversationId
    ? (conversations[conversationId]?.messages ?? [])
    : [];

  const optimisticIds = useMessage((state) => state.optimisticIds);

  useEffect(() => {
    if (!session && typeof window !== "undefined") {
      const storedToken = localStorage.getItem("tempToken");
      if (storedToken) {
        setTempToken(storedToken);
      } else {
        const uuid = crypto.randomUUID();
        setTempToken(uuid);
      }
    }
  }, [session]);

  useEffect(() => {
    if (tempToken && !session) {
      const tempUserExists = localStorage.getItem("tempUserCreated");
      if (!tempUserExists) {
        void createTempUserForGuest({
          email: "temp_user@gmail.com",
          isBurner: true,
          sessionToken: tempToken,
        }).then(() => {
          localStorage.setItem("tempUserCreated", "true");
        });
      }
    }
  }, [tempToken, session, createTempUserForGuest]);

  useEffect(() => {
    // Ensure having a valid user ID before making the call (the session is loaded or guest has tempToken)
    if ((session !== null || tempToken) && conversationIdAndTempUserId) {
      setConversationId(conversationIdAndTempUserId.conversationId);
    }
  }, [conversationIdAndTempUserId, session, tempToken]);

  useEffect(() => {
    const fetchData = async () => {
      if (conversationId) {
        await fetchInitialMessages(conversationId);
      }
    };
    void fetchData();
  }, [conversationId, fetchInitialMessages]);

  useEffect(() => {
    if (!conversationId) return;
    const channel = supabase
      .channel(conversationId)
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "messages",
        },
        (payload: { new: MessageDbType }) => {
          void handlePostgresChange(payload);
        },
      )
      .subscribe();

    return () => {
      void channel.unsubscribe();
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [messages, conversationId]);

  const handlePostgresChange = async (payload: { new: MessageDbType }) => {
    if (!optimisticIds.includes(payload.new.id)) {
      addMessageToConversation(payload.new.conversation_id, {
        id: payload.new.id,
        conversationId: payload.new.conversation_id,
        userId: payload.new.user_id,
        message: payload.new.message,
        isEdit: payload.new.is_edit,
        createdAt: payload.new.created_at,
        read: payload.new.read,
      });
    }
  };

  const addMessageToConversation = useMessage(
    (state) => state.addMessageToConversation,
  );

  const setOptimisticIds = useMessage((state) => state.setOptimisticIds);

  const removeMessageFromConversation = useMessage(
    (state) => state.removeMessageFromConversation,
  );

  const concierge = {
    name: "Blake",
    image:
      "https://lh3.googleusercontent.com/a/ACg8ocJGoxiyA7Dh7_s4C1ftNnkpo4daonbAEClM6bDnZEUyTE-nMmw=s96-c",
  };

  const formSchema = z.object({
    message: z.string(),
  });

  const handleOnSend = async (values: z.infer<typeof formSchema>) => {
    form.reset();
    if (!session) {
      const { tempUserId, conversationId } =
        await createOrRetrieveConversationFromGuest({
          sessionToken: tempToken,
        });
      const newMessage: ChatMessageType = {
        id: nanoid(),
        createdAt: new Date().toISOString().slice(0, -1),
        conversationId: conversationId,
        message: values.message,
        read: false,
        isEdit: false,
        userId: tempUserId,
      };

      const newMessageToDb = {
        id: newMessage.id,
        conversation_id: newMessage.conversationId,
        message: newMessage.message,
        read: newMessage.read,
        is_edit: newMessage.isEdit,
        created_at: newMessage.createdAt,
        user_id: newMessage.userId,
      };

      addMessageToConversation(conversationId, newMessage);
      setOptimisticIds(newMessage.id);
      const { error } = await supabase
        .from("messages")
        .insert(newMessageToDb)
        .select("*")
        .single();

      if (error) {
        removeMessageFromConversation(conversationId, newMessage.id);
        errorToast();
      }
      await sendChatboxSlackMessage({
        message: newMessage.message,
        conversationId: conversationId,
        senderId: newMessage.userId,
      });
    } else {
      const conversationId = await createOrRetrieveConversation();
      const newMessage: ChatMessageType = {
        id: nanoid(),
        createdAt: new Date().toISOString().slice(0, -1),
        conversationId: conversationId,
        userId: session.user.id,
        message: values.message,
        read: false,
        isEdit: false,
      };

      const newMessageToDb = {
        id: newMessage.id,
        conversation_id: conversationId,
        user_id: newMessage.userId,
        message: newMessage.message,
        read: newMessage.read,
        is_edit: newMessage.isEdit,
        created_at: new Date().toISOString(),
      };

      addMessageToConversation(conversationId, newMessage);
      setOptimisticIds(newMessage.id);
      const { error } = await supabase
        .from("messages")
        .insert(newMessageToDb)
        .select("*, user(email, name, image)")
        .single();

      if (error) {
        removeMessageFromConversation(conversationId, newMessage.id);
        errorToast();
      }
      await sendChatboxSlackMessage({
        message: newMessage.message,
        conversationId: conversationId,
        senderId: newMessage.userId,
      });
    }
  };

  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
  });

  useEffect(() => {
    if (isHostOnboarding) {
      // Set a default message if onboarding is true
      form.setValue("message", "I need help with host onboarding. I had an issue logging in with Hospitable.");
    }
  }, [isHostOnboarding, form]);

  return (
    <>
      {!isMobile ? (
        <Popover open={open} onOpenChange={setOpen}>
          <PopoverTrigger asChild>
            <Button className="w-18 h-18 bottom-4 right-4 z-50 m-4 hidden rounded-full border p-4 lg:fixed lg:block">
              <MessageCircleMore />
            </Button>
          </PopoverTrigger>
          <PopoverContent
            side="top"
            className="mr-7 rounded-xl border bg-black p-0"
          >
            <div className="relative bg-zinc-800 py-4 text-center text-xs text-white">
              <div className="absolute left-4">
                <PopoverClose>
                  <X />
                </PopoverClose>
              </div>

              <div className="flex items-center justify-center">
                <UserAvatar image={concierge.image} />
              </div>
              <p>Tramona Concierge</p>
              <p>{concierge.name}</p>
            </div>
            <ListMessagesWithAdmin
              messages={messages}
              tempUserId={conversationIdAndTempUserId?.tempUserId ?? ""}
            />
            <div className="p-2">
              <Form {...form}>
                <form onSubmit={form.handleSubmit(handleOnSend)}>
                  <div className="flex rounded-full border p-2">
                    <FormField
                      control={form.control}
                      name="message"
                      render={({ field }) => {
                        return (
                          <FormItem className="flex-1">
                            <FormControl>
                              <Input
                                placeholder="Type your question here..."
                                className="border-none bg-transparent text-white"
                                {...field}
                              />
                            </FormControl>
                          </FormItem>
                        );
                      }}
                    />
                    <Button
                      size="icon"
                      type="submit"
                      className="rounded-full bg-blue-800"
                    >
                      <ArrowUp />
                    </Button>
                  </div>
                </form>
              </Form>
            </div>
          </PopoverContent>
        </Popover>
      ) : (
        <div className="flex h-screen-minus-header-n-footer flex-col justify-between bg-black">
          <div className="relative bg-zinc-800 py-4 text-center text-xs text-white">
            <div className="flex items-center justify-center">
              <UserAvatar image={concierge.image} />
            </div>
            <p>Tramona Concierge</p>
            <p>{concierge.name}</p>
          </div>
          <ListMessagesWithAdmin
            messages={messages}
            isMobile={isMobile}
            tempUserId={conversationIdAndTempUserId?.tempUserId ?? ""}
          />
          <div className="p-2">
            <Form {...form}>
              <form onSubmit={form.handleSubmit(handleOnSend)}>
                <div className="flex rounded-full border p-2">
                  <FormField
                    control={form.control}
                    name="message"
                    render={({ field }) => {
                      return (
                        <FormItem className="flex-1">
                          <FormControl>
                            <Input
                              placeholder="Type your question here..."
                              className="border-none bg-transparent text-white"
                              {...field}
                            />
                          </FormControl>
                        </FormItem>
                      );
                    }}
                  />
                  <Button
                    size="icon"
                    type="submit"
                    className="rounded-full bg-blue-800"
                  >
                    <ArrowUp />
                  </Button>
                </div>
              </form>
            </Form>
          </div>
        </div>
      )}
    </>
  );
}
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/components/messages/chat-with-admin-popover/ListMessagesWithAdmin.tsx</div>
<pre><code>
import { useSession } from "next-auth/react";
import { cn } from "@/utils/utils";
import { ChatMessageType } from "@/utils/store/messages";

export default function ListMessagesWithAdmin({
  messages,
  isMobile,
  tempUserId,
}: {
  messages: ChatMessageType[];
  isMobile?: boolean;
  tempUserId: string;
}) {
  const { data: session } = useSession();

  return (
    <>
      {messages.length > 0 ? (
        <div
          className={cn(
            "flex w-full flex-1 flex-col-reverse gap-1 overflow-auto p-3",
            !isMobile && "h-96",
          )}
        >
          {messages.map((message) =>
            message.userId === session?.user.id ||
            message.userId === tempUserId ? (
              <div className="m-1 flex flex-row-reverse p-1" key={message.id}>
                <p className="h-max max-w-[15rem] rounded-l-xl rounded-tr-xl border-none bg-[#1A84E5] px-2 py-2 text-sm text-white antialiased">
                  {message.message}
                </p>
              </div>
            ) : (
              <div className="m-1 flex place-items-end p-1" key={message.id}>
                <p className="h-max max-w-[15rem] rounded-r-xl rounded-tl-xl border-none bg-[#2E2E2E] px-2 py-2 text-sm text-background text-white antialiased">
                  {message.message}
                </p>
              </div>
            ),
          )}
        </div>
      ) : (
        <div
          className={cn(
            "flex flex-col items-center justify-center",
            !isMobile && "h-96",
          )}
        >
          <p className="text-muted-foreground">How can we help you?</p>
        </div>
      )}
    </>
  );
}
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/components/messages/SidebarConversation.tsx</div>
<pre><code>
import { api } from "@/utils/api";
import {
  useConversation,
  type Conversation,
} from "@/utils/store/conversations";
import { cn } from "@/utils/utils";
import { useSession } from "next-auth/react";
import UserAvatar from "../_common/UserAvatar";
import { formatRelative } from "date-fns";

export function SidebarConversation({
  conversation,
  isSelected,
  setSelected,
}: {
  conversation: Conversation;
  isSelected: boolean;
  setSelected: (arg0: Conversation) => void;
}) {
  const { participants, messages, name } = conversation;

  const displayParticipants = participants
    .map((participant) => participant.name ?? participant.id)
    .join(", ");

  const { data: session } = useSession();

  const { mutateAsync: setMessageToReadMutate } =
    api.messages.setMessageToRead.useMutation();

  const setConversationReadState = useConversation(
    (state) => state.setConversationReadState,
  );

  function handleSelected() {
    if (
      session?.user.id !== messages[0]?.userId &&
      messages[0]?.id &&
      !messages[0].read
    ) {
      void setMessageToReadMutate({ messageId: messages[0]?.id });
    }
    // Update local state to true
    setConversationReadState(conversation.id);

    setSelected(conversation);
  }

  return (
    <button
      className={cn(
        "relative flex min-h-20 w-full gap-4 p-2 text-left",
        isSelected ? "bg-zinc-100" : "hover:bg-zinc-50",
      )}
      onClick={() => handleSelected()}
    >
      <UserAvatar
        email={participants[0]?.email}
        image={participants[0]?.image}
        name={participants[0]?.name}
      />

      <div className="flex-1">
        <div className="flex">
          <p className="line-clamp-1 flex-1 overflow-clip font-semibold">
            {displayParticipants}
          </p>
          {messages[0] && (
            <p className="text-xs text-muted-foreground">
              {formatRelative(messages[0].createdAt, new Date())}
            </p>
          )}
        </div>
        <p className="text-sm font-semibold">{name}</p>
        <p className="line-clamp-2 text-xs text-muted-foreground">
          {messages[0] &&
            !messages[0].read &&
            messages[0].userId !== session?.user.id && (
              <div className="mr-1 inline-block size-2 rounded-full bg-blue-500" />
            )}
          <span className="font-semibold">
            {messages[0]?.userId === session?.user.id ? "You: " : ""}
          </span>
          {messages[0]?.message ?? ""}
        </p>
        {/* {session?.user.role === "admin" && (
          <p className="line-clamp-1 text-xs uppercase text-muted-foreground">
            Conversation Id: {id}
          </p>
        )} */}
      </div>
    </button>
  );
}
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/components/messages/ChatMessages.tsx</div>
<pre><code>
import { useMessage } from "@/utils/store/messages";
import { useEffect } from "react";
import ListMessages from "./ListMessages";

export const LIMIT_MESSAGE = 20;

export default function ChatMessages({
  conversationId,
}: {
  conversationId: string;
}) {
  const { switchConversation, fetchInitialMessages } = useMessage();

  // Fetch conversation on the client
  useEffect(() => {
    // Update conversation state
    switchConversation(conversationId);

    // Fetch initial messages when the component mounts
    void fetchInitialMessages(conversationId);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [conversationId]);

  return (
    <>
      <ListMessages />
    </>
  );
}
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/components/messages/groupMessages.ts</div>
<pre><code>
import { type MessageType, type User } from "@/server/db/schema";
import { type ChatMessageType } from "@/utils/store/messages";

export type MessageGroup = {
  user: Pick<User, "name" | "email" | "image" | "id"> | null;
  messages: MessageType[];
};

// groups messages made by the same user with <2 mins in between

export function groupMessages(
  messages: {
    message: ChatMessageType;
    user: MessageGroup["user"] | null;
  }[],
) {
  const groups: MessageGroup[] = [];

  messages.forEach(({ message, user }) => {
    const lastGroup = groups[groups.length - 1];

    if (!user || (lastGroup && user.id !== lastGroup.user?.id)) {
      groups.push({
        user,
        messages: [message],
      });
    } else {
      const lastMessage = lastGroup?.messages[lastGroup.messages.length - 1];

      if (
        lastMessage &&
        new Date(message.createdAt).getTime() -
          new Date(lastMessage.createdAt).getTime() <=
          120000
      ) {
        lastGroup.messages.push(message);
      } else {
        groups.push({
          user: user,
          messages: [message],
        });
      }
    }
  });

  return groups;
}
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/components/messages/ChatHeader.tsx</div>
<pre><code>
import { type Conversation } from "@/utils/store/conversations";
import { ChevronLeft } from "lucide-react";
import Link from "next/link";
import UserAvatar from "../_common/UserAvatar";
import { Button, buttonVariants } from "../ui/button";

export type ContentProps = {
  selectedConversation: Conversation;
  setSelected: (arg0: Conversation | null) => void;
};

export default function ChatHeader({
  selectedConversation,
  setSelected,
}: ContentProps) {
  return (
    <div className="flex items-center justify-between border-b bg-white p-4">
      <div className="flex items-center gap-2 lg:gap-3">
        <div className="block md:hidden">
          <Button variant="ghost" size="icon" onClick={() => setSelected(null)}>
            {<ChevronLeft size="2em" />}
          </Button>
        </div>

        <UserAvatar
          email={selectedConversation.participants[0]!.email}
          image={selectedConversation.participants[0]!.image}
          name={selectedConversation.participants[0]!.name}
        />

        <div className="flex flex-col">
          <p className="text-lg font-semibold">
            {selectedConversation.participants[0]?.name}
          </p>
          {/* <p className="text-muted-foreground">Active 19m ago</p> */}
        </div>
      </div>
      {selectedConversation.offerId && (
        <Link
          href={`/offers/${selectedConversation.offerId}`}
          className={buttonVariants({ variant: "darkOutline" })}
        >
          View trip details
        </Link>
      )}
    </div>
  );
}
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/components/messages/MessagesSidebar.tsx</div>
<pre><code>
import { type MessageDbType } from "@/types/supabase.message";
import { api } from "@/utils/api";
import {
  useConversation,
  type Conversation,
} from "@/utils/store/conversations";
import { useMessage } from "@/utils/store/messages";
import supabase from "@/utils/supabase-client";
import { cn, useUpdateUser } from "@/utils/utils";
import { subHours } from "date-fns";
import { useSession } from "next-auth/react";
import { useEffect, useState } from "react";
import Spinner from "../_common/Spinner";
import UserAvatar from "../_common/UserAvatar";
import { ScrollArea } from "../ui/scroll-area";
import { SidebarConversation } from "./SidebarConversation";
import { Button } from "../ui/button";
import { MessageSquare } from "lucide-react";
import { useRouter } from "next/router";

export function MessageConversation({
  conversation,
  isSelected,
  setSelected,
}: {
  conversation: Conversation;
  isSelected: boolean;
  setSelected: (arg0: Conversation) => void;
}) {
  const { participants, messages, id, name } = conversation;

  const displayParticipants = participants
    .map((participant) => participant.name)
    .join(", ");

  const { data: session } = useSession();

  const { mutateAsync: setMessageToReadMutate } =
    api.messages.setMessageToRead.useMutation();

  const { updateUser } = useUpdateUser();

  const setConversationReadState = useConversation(
    (state) => state.setConversationReadState,
  );

  async function handleSelected() {
    if (session?.user.id !== messages[0]?.userId && messages[0]?.id) {
      void setMessageToReadMutate({ messageId: messages[0]?.id });
      if (session) {
        await updateUser({ lastTextAt: subHours(new Date(), 2) });
      }
    }
    // Update local state to true
    setConversationReadState(conversation.id);

    setSelected(conversation);
  }

  return (
    <div
      className={cn(
        "flex items-center justify-start px-4 py-6 hover:cursor-pointer hover:bg-zinc-200",
        isSelected && "bg-zinc-100",
      )}
      onClick={() => handleSelected()}
    >
      <UserAvatar
        email={participants[0]?.email ?? ""}
        image={participants[0]?.image ?? ""}
        name={participants[0]?.name ?? ""}
      />

      <div className="ml-4 md:ml-2">
        <h1 className="font-bold">{displayParticipants}</h1>
        <p>{name}</p>
        <div className="line-clamp-1 flex flex-row items-center gap-1 text-sm text-muted-foreground">
          {messages.length > 0 &&
            !messages[0]?.read &&
            messages[0]?.userId !== session?.user.id && (
              <p className="rounded-full bg-blue-500 p-1" />
            )}
          {messages[0]?.userId === session?.user.id && "You: "}
          {messages[0]?.message ?? ""}
        </div>
        {session?.user.role === "admin" && (
          <p className="line-clamp-1 text-sm uppercase text-muted-foreground">
            Conversation Id: {id}
          </p>
        )}
      </div>
    </div>
  );
}

export type SidebarProps = {
  selectedConversation: Conversation | null;
  setSelected: (arg0: Conversation) => void;
};

export default function MessagesSidebar({
  selectedConversation,
  setSelected,
}: SidebarProps) {
  const [showAllMsgs, setShowAllMsgs] = useState(true);

  // Fetch only once on mount
  const { data: fetchedConversations, isLoading } =
    api.messages.getConversations.useQuery(undefined, {
      refetchOnWindowFocus: false,
      // refetchOnMount: false,
    });

  const conversations = useConversation((state) => state.conversationList);

  const setConversationList = useConversation(
    (state) => state.setConversationList,
  );

  useEffect(() => {
    // Check if data has been fetched and hasn't been processed yet
    if (fetchedConversations) {
      setConversationList(fetchedConversations);
    }

    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [fetchedConversations]);

  const optimisticIds = useMessage((state) => state.optimisticIds);

  const setConversationToTop = useConversation(
    (state) => state.setConversationToTop,
  );

  const { data: session } = useSession();

  // Map and listen to all the connects the user is part of
  useEffect(() => {
    const handlePostgresChange = async (payload: { new: MessageDbType }) => {
      setConversationToTop(payload.new.conversation_id, {
        id: payload.new.id,
        conversationId: payload.new.conversation_id,
        userId: payload.new.user_id,
        message: payload.new.message,
        isEdit: payload.new.is_edit,
        createdAt: payload.new.created_at,
        read: payload.new.read,
      });
    };

    const fetchConversationIds = async () => {
      if (session) {
        const channels = conversations
          .map((conversation) => conversation.id)
          // When channel is selected turn of here so it can listen in the child
          .filter(
            (conversationId) => conversationId !== selectedConversation?.id,
          )
          .map((conversationId) =>
            supabase
              .channel(conversationId)
              .on(
                "postgres_changes",
                {
                  event: "INSERT",
                  schema: "public",
                  table: "messages",
                },
                (payload: { new: MessageDbType }) =>
                  void handlePostgresChange(payload),
              )
              .subscribe(),
          );

        return () => {
          channels.forEach((channel) => void channel.unsubscribe());
        };
      }
    };

    void fetchConversationIds();
  }, [
    conversations,
    optimisticIds,
    selectedConversation?.id,
    session,
    setConversationToTop,
  ]);

  const unreadConversations = conversations.filter((conversation) => {
    return (
      conversation.messages[0] &&
      !conversation.messages[0].read &&
      conversation.messages[0].userId !== session?.user.id
    );
  });

  function MessageEmptyState({ unread = false }: { unread?: boolean }) {
    const router = useRouter();
    const session = useSession();
    const role = session.data?.user.role;

    return (
      <div className="flex h-full flex-col items-center justify-center gap-4 p-4 text-center text-muted-foreground">
        <MessageSquare size={30} />
        <h2 className="font-semibold">
          {unread
            ? "You don't have any unread messages"
            : "You don't have any messages"}
        </h2>
        <p className="text-sm">
          {unread
            ? "When you have an unread message, it will appear here."
            : "When you receive a new message, it will appear here."}
        </p>
        {role === "guest" && (
          <div className="flex w-full flex-col gap-2 px-6">
            <Button
              className="rounded-full"
              onClick={() => router.push("/?tab=name-price")}
            >
              Make a request
            </Button>
            <Button
              className="rounded-full"
              onClick={() => router.push("/?tab=search")}
              variant="outline"
            >
              Book it now
            </Button>
          </div>
        )}
      </div>
    );
  }

  return (
    <div>
      <div className="space-y-4 border-b p-4">
        <h1 className="text-2xl font-semibold">Messages</h1>
        <div className="flex items-center gap-1">
          <Button
            className="rounded-full"
            variant={showAllMsgs ? "primary" : "outline"}
            onClick={() => setShowAllMsgs(true)}
          >
            All
          </Button>
          <Button
            className="rounded-full"
            variant={showAllMsgs ? "outline" : "primary"}
            onClick={() => setShowAllMsgs(false)}
          >
            Unread
          </Button>
        </div>
      </div>
      <ScrollArea className="h-[35rem] border-b py-2">
        {!isLoading ? (
          showAllMsgs ? (
            conversations.length > 0 ? (
              conversations.map((conversation) => (
                <SidebarConversation
                  key={conversation.id}
                  conversation={conversation}
                  isSelected={selectedConversation?.id === conversation.id}
                  setSelected={setSelected}
                />
              ))
            ) : (
              <MessageEmptyState />
            )
          ) : unreadConversations.length > 0 ? (
            unreadConversations.map((conversation) => (
              <SidebarConversation
                key={conversation.id}
                conversation={conversation}
                isSelected={selectedConversation?.id === conversation.id}
                setSelected={setSelected}
              />
            ))
          ) : (
            <MessageEmptyState unread />
          )
        ) : (
          <div className="grid place-items-center text-muted-foreground">
            <Spinner />
          </div>
        )}
      </ScrollArea>
    </div>
  );
}
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/components/messages/HostInitiateChat.tsx</div>
<pre><code>
import { useRouter } from "next/router";
import { api } from "@/utils/api";
import { type TRPCError } from "@trpc/server";

export function HostInitiateChat({ travelerId }: { travelerId: string }) {
  const router = useRouter();
  const { mutateAsync: createConversation } =
    api.messages.createConversationHostWithUser.useMutation();

  const handleClick = async () => {
    try {
      const conversation = await createConversation({ userId: travelerId });
      void router.push(`/host/messages?conversationId=${conversation.id}`);
    } catch (error) {
      const tRPCError = error as TRPCError;
      console.error("Failed to create conversation:", tRPCError.message);
    }
  };

  return <button onClick={() => void handleClick()}>Message Traveler</button>;
}
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/components/messages/ListMessages.tsx</div>
<pre><code>
import { type MessageDbType } from "@/types/supabase.message";
import { useMessage } from "@/utils/store/messages";
import supabase from "@/utils/supabase-client";
import { useEffect, useRef, useState } from "react";
import { Icons } from "../_icons/icons";
import { api } from "@/utils/api";
import { useConversation } from "@/utils/store/conversations";
import { useSession } from "next-auth/react";
import LoadMoreMessages from "./LoadMoreMessages";
import { groupMessages } from "./groupMessages";
import { MessageGroup } from "./MessageGroup";

function NoMessages() {
  return (
    <div className="absolute flex h-full flex-col items-center justify-center text-muted-foreground">
      No messages
    </div>
  );
}

export default function ListMessages() {
  const scrollRef = useRef<HTMLDivElement>(null);
  const [userScrolled, setUserScrolled] = useState(false);
  const [notification, setNotification] = useState(0);
  const { conversations } = useMessage();

  const currentConversationId = useMessage(
    (state) => state.currentConversationId,
  );

  const addMessageToConversation = useMessage(
    (state) => state.addMessageToConversation,
  );

  const messages = currentConversationId
    ? (conversations[currentConversationId]?.messages ?? [])
    : [];

  const { mutateAsync } = api.messages.setMessagesToRead.useMutation();

  const { data: session } = useSession();

  // Set all the messages to read when loaded
  useEffect(() => {
    const unreadMessageIds = messages
      .filter(
        (message) =>
          message.read === false && message.userId !== session?.user.id,
      )
      .map((message) => message.id);

    if (unreadMessageIds.length > 0) {
      void mutateAsync({ unreadMessageIds });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [messages]);

  const hasMore = currentConversationId
    ? (conversations[currentConversationId]?.hasMore ?? false)
    : false;

  const handlePostgresChange = async (payload: { new: MessageDbType }) => {
    if (payload.new.user_id !== session?.user.id) {
      addMessageToConversation(payload.new.conversation_id, {
        id: payload.new.id,
        conversationId: payload.new.conversation_id,
        userId: payload.new.user_id,
        message: payload.new.message,
        isEdit: payload.new.is_edit,
        createdAt: payload.new.created_at,
        read: payload.new.read,
      });
    }

    const scrollContainer = scrollRef.current;
    if (
      scrollContainer &&
      scrollContainer.scrollTop <
        scrollContainer.scrollHeight - scrollContainer.clientHeight - 10
    ) {
      setNotification((current) => current + 1);
    }
  };

  useEffect(() => {
    const channel = supabase
      .channel(`${currentConversationId}`)
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "messages",
        },
        (payload: { new: MessageDbType }) => void handlePostgresChange(payload),
      )
      .subscribe();

    return () => {
      void channel.unsubscribe();
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentConversationId, messages]);

  useEffect(() => {
    const scrollContainer = scrollRef.current;

    if (scrollContainer && !userScrolled) {
      scrollContainer.scrollTop = scrollContainer.scrollHeight;
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [messages]);

  const handleOnScroll = () => {
    const scrollContainer = scrollRef.current;

    // Check if scroll is more than 10 pixels
    if (scrollContainer) {
      const isScroll =
        scrollContainer.scrollTop <
        scrollContainer.scrollHeight - scrollContainer.clientHeight - 10;

      setUserScrolled(isScroll);

      // Set notification to 0 when scroll to bottom
      if (
        scrollContainer.scrollTop ===
        scrollContainer.scrollHeight - scrollContainer.clientHeight
      ) {
        setNotification(0);
      }
    }
  };

  const scrollDown = () => {
    // Clear notification when scorlled down
    setNotification(0);
    if (scrollRef.current) {
      scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
    }
  };

  // Get all participants
  const { conversationList } = useConversation();

  const conversationIndex = conversationList.findIndex(
    (conversation) => conversation.id === currentConversationId,
  );

  const participants = conversationList[conversationIndex]?.participants;

  const messagesWithUser = messages
    .map((message) => {
      if (!participants || !session) return null;

      // Handle current user messages
      if (message.userId === session.user.id) {
        return {
          message,
          user: {
            id: session.user.id,
            name: session.user.name,
            image: session.user.image,
            email: session.user.email,
          },
        };
      }

      // Handle other participants' messages
      const participant = participants.find((p) => p.id === message.userId);
      if (!participant) return null;

      return {
        message,
        user: {
          id: participant.id,
          name: participant.name,
          image: participant.image,
          email: participant.email,
        },
      };
    })
    .filter(Boolean);

  // Messages are now in correct order before grouping
  const messageGroups = groupMessages(messagesWithUser);

  return (
    <>
      <div
        ref={scrollRef}
        onScroll={handleOnScroll}
        className="relative flex flex-1 flex-col overflow-y-auto"
      >
        <div className="flex-1"></div>
        <div className="absolute w-full space-y-8 p-4 pt-12">
          {hasMore && <LoadMoreMessages />}
          {messageGroups.map((messageGroup) => (
            <MessageGroup
              key={messageGroup.messages[0]?.id}
              messageGroup={messageGroup}
            />
          ))}
        </div>
        {messages.length === 0 && (
          <div className="flex h-full w-full items-center justify-center">
            <NoMessages />
          </div>
        )}
      </div>
      {userScrolled && (
        <div
          className="absolute bottom-16 flex w-full items-center justify-center"
          onClick={() => scrollDown()}
        >
          {notification ? (
            <div className="cursor-pointer rounded-xl bg-black px-6 py-1 transition-all hover:scale-110">
              <h1 className="text-white">New {notification} messages</h1>
            </div>
          ) : (
            <div className="cursor-pointer rounded-full bg-black p-2 transition-all hover:scale-110">
              <Icons.arrowDown color="white" />
            </div>
          )}
        </div>
      )}
    </>
  );
}
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/components/messages/ChatInput.tsx</div>
<pre><code>
import { useConversation } from "@/utils/store/conversations";
import { type ChatMessageType, useMessage } from "@/utils/store/messages";
import supabase from "@/utils/supabase-client";
import { errorToast } from "@/utils/toasts";
import { zodResolver } from "@hookform/resolvers/zod";
import { nanoid } from "nanoid";
import { useSession } from "next-auth/react";
import { useForm } from "react-hook-form";
import { z } from "zod";
import { Form, FormControl, FormField, FormItem } from "../ui/form";
import { Input } from "../ui/input";

import { api } from "@/utils/api";
import { sub } from "date-fns";
import { ArrowUp } from "lucide-react";
import { Button } from "../ui/button";
import { useUpdateUser } from "@/utils/utils";

const formSchema = z.object({
  message: z.string().refine((data) => data.trim() !== ""),
});

export default function ChatInput({
  conversationId,
}: {
  conversationId: string;
}) {
  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      message: "",
    },
  });

  const { data: session } = useSession();

  const addMessageToConversation = useMessage(
    (state) => state.addMessageToConversation,
  );

  const setOptimisticIds = useMessage((state) => state.setOptimisticIds);

  const setConversationToTop = useConversation(
    (state) => state.setConversationToTop,
  );

  const removeMessageFromConversation = useMessage(
    (state) => state.removeMessageFromConversation,
  );

  const { updateUser } = useUpdateUser();
  const { mutateAsync: sendSMS } = api.twilio.sendSMS.useMutation();
  const { mutateAsync: sendSlackToAdmin } =
    api.messages.sendAdminSlackMessage.useMutation();
  const { data: participantPhoneNumbers } =
    api.messages.getParticipantsPhoneNumbers.useQuery({ conversationId });

  const twilioWhatsAppMutation = api.twilio.sendWhatsApp.useMutation();

  const { data: _conversationExists } =
    api.messages.getConversations.useQuery();

  const conversationList = useConversation((state) => state.conversationList);

  // Add check before sending message
  if (!conversationId) {
    console.error("No conversation ID available");
    return;
  }

  // Validate conversation ID format if using nanoid
  if (conversationId.length !== 21) {
    console.error("Invalid conversation ID format");
    return;
  }

  const onSubmit = async (values: z.infer<typeof formSchema>) => {
    if (session) {
      console.log("1. Starting message submission...");
      console.log("Current conversation ID:", conversationId);
      console.log("Available conversations:", conversationList);

      // First verify the conversation exists in Supabase
      const { data: dbConversation, error: checkError } = await supabase
        .from("conversations")
        .select("id, created_at, name")
        .eq("id", conversationId)
        .single();

      console.log("2. Database check result:", {
        conversation: dbConversation,
        error: checkError,
      });

      if (checkError ?? !dbConversation) {
        console.error("3. Conversation not found in database:", checkError);
        errorToast("Conversation not found. Please refresh the page.");
        return;
      }

      const newMessage: ChatMessageType = {
        id: nanoid(),
        createdAt: new Date().toISOString(),
        conversationId: conversationId,
        userId: session.user.id,
        message: values.message,
        read: false,
        isEdit: false,
      };

      console.log("4. Created new message object:", newMessage);

      // Add message optimistically
      addMessageToConversation(conversationId, newMessage);
      setOptimisticIds(newMessage.id);
      setConversationToTop(conversationId, {
        id: newMessage.id,
        conversationId: conversationId,
        userId: session.user.id,
        message: newMessage.message,
        createdAt: new Date().toISOString(),
        read: false,
        isEdit: false,
      });
      form.reset();

      console.log("5. Attempting Supabase message insert...");

      // Insert message into database
      const messageData = {
        id: newMessage.id,
        conversation_id: conversationId,
        user_id: newMessage.userId,
        message: newMessage.message,
        read: false,
        is_edit: false,
        created_at: new Date().toISOString(),
      };

      console.log("6. Message data to insert:", messageData);

      const { error } = await supabase.from("messages").insert(messageData);

      if (error) {
        console.error("7. Supabase insert error:", {
          error,
          messageData,
          conversationId,
        });
        removeMessageFromConversation(conversationId, newMessage.id);
        errorToast();
        return;
      }

      console.log("8. Message successfully inserted");

      // Send Slack notification
      await sendSlackToAdmin({
        message: newMessage.message,
        conversationId,
        senderId: newMessage.userId,
      });

      // Only send SMS/WhatsApp if there are unread messages and enough time has passed
      if (participantPhoneNumbers) {
        const unreadParticipants = participantPhoneNumbers.filter(
          ({ lastTextAt }) =>
            !lastTextAt || lastTextAt <= sub(new Date(), { hours: 1 }),
        );

        if (unreadParticipants.length > 0) {
          void Promise.all(
            unreadParticipants.map(async ({ phoneNumber, isWhatsApp }) => {
              if (phoneNumber) {
                if (isWhatsApp) {
                  await twilioWhatsAppMutation.mutateAsync({
                    templateId: "HXae95c5b28aa2f5448a5d63ee454ccb74",
                    to: phoneNumber,
                  });
                } else {
                  await sendSMS({
                    to: phoneNumber,
                    msg: "You have a new unread message in Tramona, visit Tramona.com to view",
                  });
                }
                await updateUser({ lastTextAt: new Date() });
              }
            }),
          );
        }
      }
    }
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="p-2 pt-0">
        <div className="flex items-center overflow-clip rounded-full border-2">
          <div className="flex-1">
            <FormField
              control={form.control}
              name="message"
              render={({ field }) => (
                <FormItem>
                  <FormControl>
                    <Input
                      placeholder="Type a message"
                      className="border-none"
                      autoFocus
                      {...field}
                    />
                  </FormControl>
                  {/* <FormMessage /> */}
                </FormItem>
              )}
            />
          </div>
          <div className="pr-2">
            <Button size="icon" type="submit" className="h-7 w-7 rounded-full">
              <ArrowUp size={20} />
            </Button>
          </div>
        </div>
      </form>
    </Form>
  );
}
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/components/messages/LoadMoreMessages.tsx</div>
<pre><code>
import { useMessage, type ChatMessageType } from "@/utils/store/messages";
import supabase from "@/utils/supabase-client";
import { errorToast } from "@/utils/toasts";
import { getFromAndTo } from "@/utils/utils";
import { Button } from "../ui/button";
import { LIMIT_MESSAGE } from "./ChatMessages";
import { ChevronUpIcon } from "lucide-react";

export default function LoadMoreMessages() {
  const currentConversationId = useMessage(
    (state) => state.currentConversationId,
  );

  const { conversations } = useMessage();
  const page = currentConversationId
    ? conversations[currentConversationId]?.page ?? 1
    : 1;

  const totalMessagesCount = currentConversationId
    ? conversations[currentConversationId]?.messages.length ?? 0
    : 0;

  const setMoreMessagesToConversation = useMessage(
    (state) => state.setMoreMessagesToConversation,
  );

  // Fetch conversation on the client
  const fetchConversation = async () => {
    const { from, to } = getFromAndTo(page, LIMIT_MESSAGE);

    // Case for optimistic ui/ create the new offset
    // for the inital fetch convo with new optimistic ui
    let offset = 0;

    if (totalMessagesCount > 0) {
      offset = totalMessagesCount - page * LIMIT_MESSAGE;
    }

    if (offset < 0) {
      offset = 0;
    }

    if (currentConversationId) {
      const { data, error } = await supabase
        .from("messages")
        .select(
          `
        *,
        user(name, image, email)
      `,
        )
        .range(from + offset, to + offset)
        .eq("conversation_id", currentConversationId)
        .order("created_at", { ascending: false });

      if (error) {
        errorToast();
      } else {
        const loadedMessages: ChatMessageType[] = data.map((message) => ({
          conversationId: message.conversation_id,
          id: message.id,
          createdAt: message.created_at,
          userId: message.user_id,
          message: message.message,
          read: message.read,
          isEdit: message.is_edit,
          user: {
            name: message.user?.name ?? "",
            image: message.user?.image ?? "",
            email: message.user?.email ?? "",
          },
        }));

        setMoreMessagesToConversation(currentConversationId, loadedMessages);
      }
    }
  };

  return (
    <div className="flex items-center justify-center">
      <Button className="rounded-full pl-3" onClick={() => fetchConversation()}>
        <ChevronUpIcon /> Load More
      </Button>
    </div>
  );
}
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/components/messages/MessagesContent.tsx</div>
<pre><code>
import { type Conversation } from "@/utils/store/conversations";
import ChatHeader from "./ChatHeader";
import ChatInput from "./ChatInput";
import ChatMessages from "./ChatMessages";
import EmptyStateValue from "../_common/EmptyStateSvg/EmptyStateValue";
import ConversationsEmptySvg from "../_common/EmptyStateSvg/ConversationsEmptySvg";

export default function MessagesContent({
  selectedConversation,
  setSelected,
}: {
  selectedConversation: Conversation | null;
  setSelected: (arg0: Conversation | null) => void;
}) {
  if (!selectedConversation) {
    return (
      <EmptyStateValue description="Select a conversation to read more">
        <ConversationsEmptySvg />
      </EmptyStateValue>
    );
  }

  return (
    <div className="relative flex h-full w-full flex-col">
      <ChatHeader
        selectedConversation={selectedConversation}
        setSelected={setSelected}
      />
      <ChatMessages conversationId={selectedConversation.id} />
      <ChatInput conversationId={selectedConversation.id} />
    </div>
  );
}
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/components/messages/MessageGroup.tsx</div>
<pre><code>
import { type MessageType } from "@/server/db/schema";
import { formatRelative } from "date-fns";
import { useSession } from "next-auth/react";
import { type MessageGroup } from "./groupMessages";
import { cn } from "@/utils/utils";

export function MessageGroup({ messageGroup }: { messageGroup: MessageGroup }) {
  const { data: session } = useSession();
  const { user, messages } = messageGroup;
  const firstMessage = messages[0];
  if (!firstMessage || !session) return null;

  const me = session.user.id === user?.id;

  return (
    <div
      className={cn(
        "flex items-start gap-2",
        me ? "justify-start" : "justify-end",
      )}
    >
      {/* {user ? <UserAvatar {...user} /> : <AnonymousAvatar />} */}
      <div
        className={cn(
          "max-w-72 rounded-xl px-4 py-2 sm:max-w-96 lg:max-w-prose",
          me ? "bg-teal-900 text-white" : "bg-white",
        )}
      >
        {/* <div className="flex items-baseline gap-2">
          {user ? (
            <p className="font-semibold leading-none">{user.name}</p>
          ) : (
            <p className="leading-none text-muted-foreground">[deleted user]</p>
          )}
        </div> */}

        <div className="space-y-1">
          {messages.map((message) => (
            <Message key={message.id} message={message} />
          ))}
        </div>
        <div className="flex items-center justify-between gap-2 text-xs text-muted-foreground">
          <p>{formatRelative(firstMessage.createdAt, new Date())}</p>
          <p>
            {session.user.id === firstMessage.userId && firstMessage.read && (
              <>Read</>
            )}
          </p>
        </div>
      </div>
    </div>
  );
}

function Message({ message }: { message: MessageType }) {
  return (
    <p>
      {message.message}
      {message.isEdit && (
        <span className="ml-1 text-xs text-muted-foreground">(edited)</span>
      )}
    </p>
  );
}
</code></pre>
</div>
<div class='section'>
<h2 class='section-title'>Core UI and Layout</h2>
<div class='file'>
<div class='file-name'>./src/pages/_app.tsx</div>
<pre><code>
import { type Session } from "next-auth";
import { SessionProvider } from "next-auth/react";
import { type AppType } from "next/app";
import { APIProvider } from "@vis.gl/react-google-maps";
import { env } from "@/env";
import { api } from "@/utils/api";
import "@/styles/globals.css";

import TailwindIndicator from "@/components/_common/TailwindIndicator";
import { Toaster } from "@/components/ui/toaster";
import { TooltipProvider } from "@/components/ui/tooltip";
import StripeConnectSessionProvider from "@/components/providerLayouts/StripeConnectSessionProvider";
import Head from "next/head";
import SEO from "../../next-seo.config";
import { Mulish } from "next/font/google";
import { DefaultSeo } from "next-seo";
import NextTopLoader from "nextjs-toploader";
import { ToastProvider } from "@/components/ui/toast";

export const mulish = Mulish({
  subsets: ["latin"],
  display: "swap",
});

const MyApp: AppType<{ session: Session | null }> = ({
  Component,
  pageProps: { session, ...pageProps },
}) => {
  return (
    <ToastProvider>
      <TooltipProvider delayDuration={50} disableHoverableContent>
        <NextTopLoader showSpinner={false} color="#003546" />
        <DefaultSeo {...SEO} />
        <APIProvider
          apiKey={env.NEXT_PUBLIC_GOOGLE_PLACES_KEY}
          onLoad={() => console.log("Maps API has loaded.")}
        >
          <SessionProvider session={session}>
            <Head>
              <meta
                name="viewport"
                content="width=device-width, initial-scale=1, maximum-scale=1"
              />
            </Head>
            <StripeConnectSessionProvider>
              <Component {...pageProps} />
            </StripeConnectSessionProvider>

            {/* Helps display screen size (Only in developer mode) */}
            <TailwindIndicator />
            <Toaster />
          </SessionProvider>
        </APIProvider>
      </TooltipProvider>
    </ToastProvider>
  );
};

export default api.withTRPC(MyApp);
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/components/_common/UserAvatar.tsx</div>
<pre><code>
import {
  AnonymousAvatar,
  Avatar,
  AvatarFallback,
  AvatarImage,
  type AvatarVariants,
} from "../ui/avatar";

function getInitials(name: string) {
  return name
    .split(" ")
    .map((s) => s[0])
    .slice(0, 2)
    .join("");
}

export default function UserAvatar({
  name,
  email,
  image,
  size = "md",
}: {
  name?: string | null;
  email?: string | null;
  image?: string | null;
} & AvatarVariants) {
  if (!name && !email && !image) return <AnonymousAvatar size={size} />;
  const fallback = name ? getInitials(name) : (email?.[0] ?? "?");
  return (
    <Avatar size={size}>
      {image ? (
        <AvatarImage src={image} alt="" />
      ) : (
        <AvatarFallback>{fallback}</AvatarFallback>
      )}
    </Avatar>
  );
}
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/components/ui/button.tsx</div>
<pre><code>
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import * as React from "react";
import { createContext, useContext, useState } from "react";

import { cn } from "@/utils/utils";
import { Tooltip, TooltipContent, TooltipTrigger } from "./tooltip";
import { useFormContext } from "react-hook-form";

const buttonVariants = cva(
  "inline-flex items-center gap-2 text-center justify-center whitespace-nowrap rounded-md text-sm font-semibold focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
  {
    variants: {
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8 text-base",
        xl: "h-16 rounded-full px-16 text-xl",
        icon: "h-10 w-10",
      },
      variant: {
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90 disabled:bg-zinc-400 disabled:text-secondary-foreground",
        outline:
          "border border-[#c9c9c9] bg-white text-primary font-normal text-base hover:bg-zinc-100 focus-visible:bg-zinc-200",
        secondary:
          "bg-zinc-100 border border-zinc-300 text-secondary-foreground hover:bg-zinc-200",
        ghost:
          "hover:bg-accent text-zinc-600/90 hover:text-zinc-600 data-[state=open]:bg-accent",
        link: "text-primary underline-offset-4 hover:underline",
        emptyInput:
          "w-full bg-accent/70 text-zinc-500 px-3 hover:bg-accent border border-input outline-offset-0 focus-visible:outline-2 focus-visible:outline-ring disabled:opacity-50",
        filledInput:
          "w-full bg-primary-foreground px-3 font-normal text-black hover:bg-accent border border-input outline-offset-0 focus-visible:outline-2 focus-visible:outline-ring disabled:opacity-50",
        darkPrimary: "bg-black text-white hover:bg-black/80",
        darkOutline: "border border-black hover:bg-zinc-200",
        darkOutlineWhite: "border-2 border-white text-white",
        white: "bg-white text-black hover:bg-zinc-200",
        wrapper:
          "hover:bg-accent hover:text-accent-foreground gap-0 -m-1 h-auto rounded-full p-1",
        outlineLight:
          "hover:border-black flex flex-row items-center gap-5 rounded-[12px] border-[2px] p-6 px-7 transition-all",
        outlineMinimal:
          "hover:border-black flex flex-row items-center gap-5 rounded-lg border-[2px] p-2 transition-all",
        increment:
          "rounded-full border-2 flex items-center justify-center hover:border-black transition-all duration-200",
        underline: "hover:bg-accent text-zinc-800 underline",
        primary:
          "bg-primaryGreen hover:opacity-90 text-[#fafafa] disabled:bg-zinc-400 disabled:text-secondary-foreground",
      },
    },
    defaultVariants: {
      size: "default",
      variant: "primary",
    },
  },
);

interface ButtonContextType {
  isLoading: boolean;
}

const ButtonContext = createContext<ButtonContextType | undefined>(undefined);

export const useButtonContext = () => {
  const context = useContext(ButtonContext);
  if (!context) {
    throw new Error("useButtonContext must be used within a Button");
  }
  return context;
};

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
  isLoading?: boolean;
  tooltip?: React.ReactNode;
  tooltipOptions?: React.ComponentProps<typeof TooltipContent>;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  (
    {
      className,
      variant,
      size,
      asChild = false,
      tooltip,
      tooltipOptions = {},
      children,
      onClick,
      ...props
    },
    ref,
  ) => {
    const Comp = asChild ? Slot : "button";
    const [isOnClickLoading, setIsOnClickLoading] = useState(false);
    const form = useFormContext();
    const isSubmitButton = props.type === "submit";

    const isLoading =
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      isOnClickLoading || (isSubmitButton && form?.formState.isSubmitting);

    const handleClick = async (event: React.MouseEvent<HTMLButtonElement>) => {
      setIsOnClickLoading(true);
      if (onClick) await Promise.resolve(onClick(event));
      setIsOnClickLoading(false);
    };

    const button = (
      <ButtonContext.Provider value={{ isLoading }}>
        <Comp
          className={cn(buttonVariants({ variant, size, className }), "group")}
          ref={ref}
          onClick={handleClick}
          {...props}
          disabled={isLoading || props.disabled}
        >
          {children}
        </Comp>
      </ButtonContext.Provider>
    );

    return tooltip ? (
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent {...tooltipOptions}>{tooltip}</TooltipContent>
      </Tooltip>
    ) : (
      button
    );
  },
);
Button.displayName = "Button";

export { Button, buttonVariants };
</code></pre>
</div>
<div class='section'>
<h2 class='section-title'>API Routers</h2>
<div class='file'>
<div class='file-name'>./src/server/api/routers/propertiesRouter.ts</div>
<pre><code>
import {
  createTRPCRouter,
  hostProcedure,
  optionallyAuthedProcedure,
  protectedProcedure,
  publicProcedure,
  roleRestrictedProcedure,
} from "@/server/api/trpc";
import { db } from "@/server/db";
import {
  hostProfiles,
  hostTeamMembers,
  hostTeams,
  propertyInsertSchema,
  propertySelectSchema,
  propertyUpdateSchema,
  reservedDateRanges,
  type Request,
  type RequestsToBook,
  type User,
  Offer,
} from "@/server/db/schema";
import { TRPCError } from "@trpc/server";
import { addDays } from "date-fns";
import {
  and,
  arrayContains,
  asc,
  eq,
  gt,
  gte,
  isNotNull,
  like,
  lte,
  ne,
  notExists,
  or,
  sql,
  notInArray,
} from "drizzle-orm";
import { z } from "zod";
import {
  ALL_PROPERTY_ROOM_TYPES,
  bookedDates,
  discountTierSchema,
  properties,
  type Property,
} from "./../../db/schema/tables/properties";
import {
  addProperty,
  createLatLngGISPoint,
  getPropertyOriginalPrice,
  getRequestsForProperties,
  getRequestsToBookForProperties,
} from "@/server/server-utils";
import { getCoordinates } from "@/server/google-maps";
import { checkAvailabilityForProperties } from "@/server/direct-sites-scraping";
import { scrapeAirbnbSearch } from "@/server/external-listings-scraping/airbnbScraper";
import { capitalize } from "@/utils/utils";

export type HostRequestsPageData = {
  city: string;
  requests: {
    request: Request & {
      traveler: Pick<
        User,
        | "firstName"
        | "lastName"
        | "name"
        | "image"
        | "location"
        | "about"
        | "dateOfBirth"
      >;
    };
    properties: (Property & { taxAvailable: boolean })[];
  }[];
};

export type HostRequestsToBookPageData = {
  requestToBook: (RequestsToBook & {
    traveler: Pick<
      User,
      "firstName" | "lastName" | "name" | "image" | "location" | "about"
    >;
  })[];
  property: Property & { taxAvailable: boolean };
}[];

export type HostRequestsPageOfferData = {
  city: string;
  requests: {
    offer: Offer;
    request: {
      id: number;
      madeByGroupId: number;
      maxTotalPrice: number;
      checkIn: Date;
      checkOut: Date;
      numGuests: number;
      location: string;
      traveler: Pick<
        User,
        "firstName" | "lastName" | "name" | "image" | "location" | "about"
      >;
    };
    property: { city: string; name: string };
  }[];
};

export const propertiesRouter = createTRPCRouter({
  create: protectedProcedure
    .input(
      propertyInsertSchema
        .omit({
          hostTeamId: true,
          countryISO: true,
          latLngPoint: true,
          city: true,
          county: true,
          stateName: true,
          stateCode: true,
          country: true,
        })
        .extend({
          latLngPoint: propertyInsertSchema.shape.latLngPoint.optional(),
        }),
    )
    .mutation(async ({ ctx, input }) => {
      const hostProfile = await db.query.hostProfiles.findFirst({
        where: eq(hostProfiles.userId, ctx.user.id),
        columns: { curTeamId: true },
      });

      if (!hostProfile) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "Host profile not found",
        });
      }

      const id = await addProperty({
        property: input,
        hostTeamId: hostProfile.curTeamId,
        isAdmin: ctx.user.role === "admin",
        userEmail: ctx.user.email,
      });
      return id;
    }),

  // uses the hostTeamId passed in the input instead of the admin's user id
  createForHostTeam: roleRestrictedProcedure(["admin"])
    .input(
      propertyInsertSchema.omit({
        city: true,
        latLngPoint: true,
      }),
    )
    .mutation(async ({ ctx, input }) => {
      const hostTeam = await db.query.hostTeams.findFirst({
        where: eq(hostTeams.id, input.hostTeamId),
      });

      if (!hostTeam) {
        return { status: "host team not found" } as const;
      }

      await addProperty({
        property: input,
        hostTeamId: hostTeam.id,
        isAdmin: true,
        userEmail: ctx.user.email,
      });

      return {
        status: "success",
      } as const;
    }),

  update: roleRestrictedProcedure(["admin", "host"])
    .input(propertyUpdateSchema.omit({ hostTeamId: true, latLngPoint: true }))
    .mutation(async ({ ctx, input }) => {
      // TODO: auth
      if (input.address) {
        const { location } = await getCoordinates(input.address);
        if (!location) throw new Error("Could not get coordinates for address");
        const latLngPoint = createLatLngGISPoint({
          lat: location.lat,
          lng: location.lng,
        });
        await ctx.db
          .update(properties)
          .set({ latLngPoint })
          .where(eq(properties.id, input.id));
      }

      await ctx.db
        .update(properties)
        .set(input)
        .where(eq(properties.id, input.id));
    }),

  delete: roleRestrictedProcedure(["admin", "host"])
    .input(propertySelectSchema.pick({ id: true }))
    .mutation(async ({ ctx, input }) => {
      if (ctx.user.role === "host") {
        const property = await db.query.properties.findFirst({
          where: eq(properties.id, input.id),
          columns: { hostTeamId: true },
        });

        if (!property) {
          throw new TRPCError({
            code: "NOT_FOUND",
            message: "Property not found",
          });
        }

        const hostTeamMember = await db.query.hostTeamMembers.findFirst({
          where: and(
            eq(hostTeamMembers.hostTeamId, property.hostTeamId),
            eq(hostTeamMembers.userId, ctx.user.id),
          ),
        });

        if (!hostTeamMember) {
          throw new TRPCError({ code: "UNAUTHORIZED" });
        }
      }

      await ctx.db.delete(properties).where(eq(properties.id, input.id));
    }),

  getById: publicProcedure
    .input(propertySelectSchema.pick({ id: true }))
    .query(async ({ ctx, input }) => {
      const property = await ctx.db.query.properties.findFirst({
        where: eq(properties.id, input.id),
        with: {
          hostTeam: {
            with: {
              owner: {
                columns: {
                  image: true,
                  firstName: true,
                  lastName: true,
                  email: true,
                  id: true,
                  about: true,
                  location: true,
                },
                // with: {
                //   hostProfile: {
                //     columns: { curTeamId: true },
                //   },
                // },
              },
            },
          },
          reviews: true,
        },
      });
      if (!property) throw new Error("no property");
      return property;
    }),
  getAll: publicProcedure.query(async ({ ctx }) => {
    return await ctx.db.query.properties.findMany();
  }),
  getAllByFilter: publicProcedure.query(async ({ ctx }) => {
    return await ctx.db.query.properties.findMany({
      limit: 100,
      offset: 0,
    });
  }),

  getAllInfiniteScroll: optionallyAuthedProcedure
    .input(
      z.object({
        cursor: z.number().nullish(), // <-- "cursor" needs to exist, but can be any type
        city: z.string().optional(),
        roomType: z.enum(ALL_PROPERTY_ROOM_TYPES).optional(),
        beds: z.number().optional(),
        bedrooms: z.number().optional(),
        bathrooms: z.number().optional(),
        houseRules: z.array(z.string()).optional(),
        guests: z.number().optional(),
        maxNightlyPrice: z.number().optional(),
        avgRating: z.number().optional(),
        numRatings: z.number().optional(),
        latLngPoint: z
          .object({
            lat: z.number(),
            lng: z.number(),
          })
          .optional(),
        radius: z.number().optional(),
        checkIn: z.date().optional(),
        checkOut: z.date().optional(),
        northeastLat: z.number().optional(),
        northeastLng: z.number().optional(),
        southwestLat: z.number().optional(),
        southwestLng: z.number().optional(),
      }),
    )
    .query(async ({ ctx, input }) => {
      const { cursor } = input;

      const lat = input.latLngPoint?.lat ?? 0;
      const lng = input.latLngPoint?.lng ?? 0;
      const radius = input.radius ?? 0;

      const northeastLat = input.northeastLat ?? 0;
      const northeastLng = input.northeastLng ?? 0;
      const southwestLat = input.southwestLat ?? 0;
      const southwestLng = input.southwestLng ?? 0;

      const data = await ctx.db
        .select({
          id: properties.id,
          imageUrls: properties.imageUrls,
          name: properties.name,
          maxNumGuests: properties.maxNumGuests,
          numBedrooms: properties.numBedrooms,
          numBathrooms: properties.numBathrooms,
          numBeds: properties.numBeds,
          avgRating: properties.avgRating,
          numRatings: properties.numRatings,
          originalNightlyPrice: properties.originalNightlyPrice,
          latLngPoint: properties.latLngPoint,
          bookItNowIsEnabled: properties.bookItNowEnabled,
          originalListingId: properties.originalListingId,
          originalListingPlatform: properties.originalListingPlatform,
          // lat: properties.latitude,
          // long: properties.longitude,
          distance: sql`
          6371 * ACOS(
            SIN(${(lat * Math.PI) / 180}) * SIN(radians(ST_Y(${properties.latLngPoint}))) +
            COS(${(lat * Math.PI) / 180}) * COS(radians(ST_Y(${properties.latLngPoint}))) *
            COS(radians(ST_X(${properties.latLngPoint})) - ${(lng * Math.PI) / 180})
          ) AS distance`,
          vacancyCount: sql`
          (SELECT COUNT(booked_dates.property_id)
          FROM booked_dates
          WHERE booked_dates.property_id = properties.id
            AND booked_dates.date >= CURRENT_DATE
            AND booked_dates.date <= CURRENT_DATE + INTERVAL '30 days') AS vacancyCount
        `,
        })
        .from(properties)
        .where(
          and(
            eq(properties.status, "Listed"),
            cursor ? gt(properties.id, cursor) : undefined, // Use property ID as cursor
            input.latLngPoint?.lat &&
              input.latLngPoint.lng &&
              !northeastLat &&
              !northeastLng &&
              !southwestLat &&
              !southwestLng
              ? sql`6371 * ACOS(
                SIN(${(lat * Math.PI) / 180}) * SIN(radians(ST_Y(${properties.latLngPoint}))) +
                COS(${(lat * Math.PI) / 180}) * COS(radians(ST_Y(${properties.latLngPoint}))) *
                COS(radians(ST_X(${properties.latLngPoint})) - ${(lng * Math.PI) / 180})
              ) <= ${radius}`
              : sql`TRUE`,
            input.roomType
              ? eq(properties.roomType, input.roomType)
              : sql`TRUE`,
            input.city && input.city !== "all"
              ? eq(properties.address, input.city)
              : sql`TRUE`,
            input.beds ? gte(properties.numBeds, input.beds) : sql`TRUE`,
            input.bedrooms
              ? gte(properties.numBedrooms, input.bedrooms)
              : sql`TRUE`,
            input.bathrooms
              ? gte(properties.numBathrooms, input.bathrooms)
              : sql`TRUE`,
            input.guests
              ? gte(properties.maxNumGuests, input.guests)
              : sql`TRUE`,
            input.maxNightlyPrice
              ? lte(properties.originalNightlyPrice, input.maxNightlyPrice)
              : sql`TRUE`,
            input.houseRules?.includes("pets allowed")
              ? eq(properties.petsAllowed, true)
              : sql`TRUE`,
            input.houseRules?.includes("smoking allowed")
              ? eq(properties.smokingAllowed, true)
              : sql`TRUE`,
            eq(properties.isPrivate, false),
            notExists(
              db
                .select()
                .from(bookedDates)
                .where(
                  and(
                    eq(bookedDates.propertyId, properties.id),
                    gte(bookedDates.date, new Date()), // today or future
                    lte(bookedDates.date, addDays(new Date(), 30)), // within next 30 days
                  ),
                ),
            ),
            sql`(SELECT COUNT(booked_dates.property_id)
            FROM booked_dates
            WHERE booked_dates.property_id = properties.id
              AND booked_dates.date >= CURRENT_DATE
              AND booked_dates.date <= CURRENT_DATE + INTERVAL '20 days') < 14`,

            northeastLat && northeastLng && southwestLat && southwestLng
              ? sql`
              ST_Y(${properties.latLngPoint}) BETWEEN ${southwestLat} AND ${northeastLat}
              AND ST_X(${properties.latLngPoint}) BETWEEN ${southwestLng} AND ${northeastLng}
            `
              : sql`true`,
          ),
        )
        .limit(15)
        .orderBy(asc(sql`id`), asc(sql`distance`));

      return {
        data,
        nextCursor: data.length ? data[data.length - 1]?.id : null, // Use last property ID as next cursor
      };
    }),

  getByBoundaryInfiniteScroll: optionallyAuthedProcedure
    .input(
      z.object({
        boundaries: z
          .object({
            north: z.number(),
            south: z.number(),
            east: z.number(),
            west: z.number(),
          })
          .nullable(),
        cursor: z.number().nullish(),
        city: z.string().optional(),
        roomType: z.enum(ALL_PROPERTY_ROOM_TYPES).optional(),
        beds: z.number().optional(),
        bedrooms: z.number().optional(),
        bathrooms: z.number().optional(),
        houseRules: z.array(z.string()).optional(),
        guests: z.number().optional(),
        maxNightlyPrice: z.number().optional(),
        latLngPoint: z
          .object({
            lat: z.number(),
            lng: z.number(),
          })
          .optional(),
        radius: z.number().optional(),
        checkIn: z.date().optional(),
        checkOut: z.date().optional(),
      }),
    )
    .query(async ({ ctx, input }) => {
      const { cursor, boundaries } = input;

      const lat = input.latLngPoint?.lat ?? 0;
      const lng = input.latLngPoint?.lng ?? 0;
      const radius = input.radius ?? 0; //just tried to fix a type error

      const data = await ctx.db
        .select({
          id: properties.id,
          imageUrls: properties.imageUrls,
          name: properties.name,
          maxNumGuests: properties.maxNumGuests,
          numBedrooms: properties.numBedrooms,
          numBathrooms: properties.numBathrooms,
          numBeds: properties.numBeds,
          avgRating: properties.avgRating,
          numRatings: properties.numRatings,
          originalNightlyPrice: properties.originalNightlyPrice,
          originalListingPlatform: properties.originalListingPlatform,
          originalListingId: properties.originalListingId,
          latLngPoint: properties.latLngPoint,
          bookItNowIsEnabled: properties.bookItNowEnabled,
          // lat: properties.latitude,
          // long: properties.longitude,
          distance: sql`
            6371 * ACOS(
              SIN(${(lat * Math.PI) / 180}) * SIN(radians(ST_Y(${properties.latLngPoint}))) +
              COS(${(lat * Math.PI) / 180}) * COS(radians(ST_Y(${properties.latLngPoint}))) *
              COS(radians(ST_X(${properties.latLngPoint})) - ${(lng * Math.PI) / 180})
            ) AS distance`,
          vacancyCount: sql`
            (SELECT COUNT(booked_dates.property_id)
            FROM booked_dates
            WHERE booked_dates.property_id = properties.id
              AND booked_dates.date >= CURRENT_DATE
              AND booked_dates.date <= CURRENT_DATE + INTERVAL '30 days') AS vacancyCount
          `,
        })
        .from(properties)
        .where(
          and(
            cursor ? gt(properties.id, cursor) : undefined,
            boundaries
              ? sql`
                ST_Y(${properties.latLngPoint}) BETWEEN ${boundaries.south} AND ${boundaries.north}
                AND ST_X(${properties.latLngPoint}) BETWEEN ${boundaries.west} AND ${boundaries.east}
              `
              : sql`TRUE`,
            input.latLngPoint?.lat && input.latLngPoint.lng && !boundaries
              ? sql`6371 * ACOS(
              SIN(${(lat * Math.PI) / 180}) * SIN(radians(ST_Y(${properties.latLngPoint}))) +
              COS(${(lat * Math.PI) / 180}) * COS(radians(ST_Y(${properties.latLngPoint}))) *
              COS(radians(ST_X(${properties.latLngPoint})) - ${(lng * Math.PI) / 180})
            ) <= ${radius}`
              : sql`TRUE`,
            input.roomType
              ? eq(properties.roomType, input.roomType)
              : sql`TRUE`,
            input.beds ? gte(properties.numBeds, input.beds) : sql`TRUE`,
            input.bedrooms
              ? gte(properties.numBedrooms, input.bedrooms)
              : sql`TRUE`,
            input.bathrooms
              ? gte(properties.numBathrooms, input.bathrooms)
              : sql`TRUE`,
            input.guests
              ? gte(properties.maxNumGuests, input.guests)
              : sql`TRUE`,
            input.maxNightlyPrice
              ? lte(properties.originalNightlyPrice, input.maxNightlyPrice)
              : sql`TRUE`,
            input.houseRules?.includes("pets allowed")
              ? eq(properties.petsAllowed, true)
              : sql`TRUE`,
            input.houseRules?.includes("smoking allowed")
              ? eq(properties.smokingAllowed, true)
              : sql`TRUE`,
            eq(properties.isPrivate, false),
            notExists(
              db
                .select()
                .from(bookedDates)
                .where(
                  and(
                    eq(bookedDates.propertyId, properties.id),
                    gte(bookedDates.date, new Date()),
                    lte(bookedDates.date, addDays(new Date(), 30)),
                  ),
                ),
            ),
            sql`(SELECT COUNT(booked_dates.property_id)
              FROM booked_dates
              WHERE booked_dates.property_id = properties.id
                AND booked_dates.date >= CURRENT_DATE
                AND booked_dates.date <= CURRENT_DATE + INTERVAL '20 days') < 14`,
          ),
        )
        // .limit(12)
        .limit(100)
        .orderBy(asc(sql`id`), asc(sql`distance`));

      return {
        data,
        nextCursor: data.length ? data[data.length - 1]?.id : null,
      };
    }),

  // getCities: publicProcedure.query(async ({ ctx }) => {
  //   const lat = 34.1010307;
  //   const long = -118.3806008;
  //   const radius = 10; // 100km.

  //   const data = await ctx.db
  //     .select({
  //       id: properties.id,
  //       distance: sql`
  //       6371 * ACOS(
  //           SIN(${(lat * Math.PI) / 180}) * SIN(radians(latitude)) + COS(${(lat * Math.PI) / 180}) * COS(radians(latitude)) * COS(radians(longitude) - ${(long * Math.PI) / 180})
  //       ) AS distance`,
  //     })
  //     .from(properties)
  //     .orderBy(sql`distance`)
  //     .where(
  //       sql`6371 * acos(SIN(${(lat * Math.PI) / 180}) * SIN(radians(latitude)) + COS(${(lat * Math.PI) / 180}) * COS(radians(latitude)) * COS(radians(longitude) - ${(long * Math.PI) / 180})) <= ${radius}`,
  //     );
  // }),
  getHostProperties: hostProcedure
    .input(z.object({ limit: z.number().optional() }).optional())
    .query(async ({ ctx, input }) => {
      return await ctx.db.query.properties.findMany({
        where: eq(properties.hostTeamId, ctx.hostProfile.curTeamId),
        limit: input?.limit,
      });
    }),

  updatePropertyDatesLastUpdated: hostProcedure
    .input(z.object({ propertyId: z.number(), datesLastUpdated: z.date() }))
    .mutation(async ({ ctx, input }) => {
      await ctx.db
        .update(properties)
        .set({ datesLastUpdated: input.datesLastUpdated })
        .where(eq(properties.id, input.propertyId));
    }),

  getHostPropertiesWithRequests: hostProcedure.query(async ({ ctx }) => {
    const hostProperties = await db.query.properties.findMany({
      where: and(
        eq(properties.hostTeamId, ctx.hostProfile.curTeamId),
        eq(properties.status, "Listed"),
      ),
    });

    const hostRequests = await getRequestsForProperties(hostProperties);

    const groupedByCity: HostRequestsPageData[] = [];
    const citiesSet = new Set(hostProperties.map((property) => property.city));
    citiesSet.forEach((city) => {
      groupedByCity.push({ city, requests: [] });
    });

    const findOrCreateCityGroup = (city: string) => {
      let cityGroup = groupedByCity.find((group) => group.city === city);
      if (!cityGroup) {
        cityGroup = { city, requests: [] };
        groupedByCity.push(cityGroup);
      }
      return cityGroup;
    };

    const requestsMap = new Map<
      number,
      {
        request: Request & {
          traveler: Pick<
            User,
            | "firstName"
            | "lastName"
            | "name"
            | "image"
            | "location"
            | "about"
            | "dateOfBirth"
          >;
        };
        properties: (Property & { taxAvailable: boolean })[];
      }
    >();

    for (const { property, request } of hostRequests) {
      if (!requestsMap.has(request.id)) {
        requestsMap.set(request.id, {
          request,
          properties: [],
        });
      }
      requestsMap.get(request.id)!.properties.push(property);
    }

    for (const requestWithProperties of requestsMap.values()) {
      const { request, properties } = requestWithProperties;
      for (const property of properties) {
        const cityGroup = findOrCreateCityGroup(property.city);
        const existingRequest = cityGroup.requests.find(
          (item) => item.request.id === request.id,
        );

        if (existingRequest) {
          existingRequest.properties.push(property);
        } else {
          cityGroup.requests.push({
            request,
            properties: [property],
          });
        }
      }
    }

    return groupedByCity;
  }),

  getHostPropertiesWithRequestsToBook: hostProcedure.query(async ({ ctx }) => {
    const hostProperties = await db.query.properties.findMany({
      where: and(
        eq(properties.hostTeamId, ctx.hostProfile.curTeamId),
        eq(properties.status, "Listed"),
      ),
    });

    const hostRequestsToBook = await getRequestsToBookForProperties(
      hostProperties,
      { user: ctx.user },
    );

    const propertiesWithRequestsToBook = hostProperties
      .filter((property) =>
        hostRequestsToBook.some(
          (requestToBook) =>
            requestToBook.requestToBook.propertyId === property.id,
        ),
      )
      .map((property) => ({
        property,
        requestToBook: hostRequestsToBook.filter(
          (requestToBook) =>
            requestToBook.requestToBook.propertyId === property.id,
        ),
      }));

    return propertiesWithRequestsToBook;
  }),

  // hostInsertOnboardingProperty: roleRestrictedProcedure(["host"])
  //   .input(hostPropertyFormSchema)
  //   .mutation(async ({ ctx, input }) => {
  //     return await ctx.db.insert(properties).values({
  //       ...input,
  //       hostId: ctx.user.id,
  //       hostName: ctx.user.name,
  //       imageUrls: input.imageUrls,
  //     });
  //   }),
  getBlockedDates: protectedProcedure
    .input(z.object({ propertyId: z.number() }))
    .query(async ({ ctx, input }) => {
      return await ctx.db.query.bookedDates.findMany({
        where: eq(bookedDates.propertyId, input.propertyId),
        columns: {
          date: true,
        },
      });
    }),

  deleteImage: roleRestrictedProcedure(["admin"])
    .input(z.string())
    .mutation(async ({ input: imageUrl }) => {
      const count = await db.query.properties
        .findMany({
          columns: { id: true, imageUrls: true },
          where: arrayContains(properties.imageUrls, [imageUrl]),
        })
        .then((res) =>
          Promise.all(
            res.map((p) =>
              db
                .update(properties)
                .set({ imageUrls: p.imageUrls.filter((i) => i !== imageUrl) })
                .where(eq(properties.id, p.id)),
            ),
          ).then((res) => res.length),
        );

      return { count };
    }),

  updateRequestToBook: protectedProcedure
    .input(
      z.object({
        propertyId: z.number(),
        requestToBookMaxDiscountPercentage: z.number(),
      }),
    )
    .mutation(async ({ input }) => {
      await db
        .update(properties)
        .set({
          requestToBookMaxDiscountPercentage:
            input.requestToBookMaxDiscountPercentage,
        })
        .where(eq(properties.id, input.propertyId));
      console.log("YAY");
      return;
    }),

  toggleAutoOffer: protectedProcedure
    .input(
      z.object({
        id: z.number(),
        autoOfferEnabled: z.boolean(),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      await ctx.db
        .update(properties)
        .set({
          autoOfferEnabled: input.autoOfferEnabled,
        })
        .where(eq(properties.id, input.id));
    }),

  toggleBookItNow: protectedProcedure
    .input(
      z.object({
        id: z.number(),
        bookItNowEnabled: z.boolean(),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      const [updatedProperty] = await ctx.db
        .update(properties)
        .set({
          bookItNowEnabled: input.bookItNowEnabled,
        })
        .where(eq(properties.id, input.id))
        .returning({ bookItNowEnabled: properties.bookItNowEnabled });

      return updatedProperty?.bookItNowEnabled ? true : false;
    }),

  updateBookItNow: protectedProcedure
    .input(
      z.object({
        id: z.number(),
        bookItNowHostDiscountPercentOffInput: z.number().optional(),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      await ctx.db
        .update(properties)
        .set({
          ...(input.bookItNowHostDiscountPercentOffInput !== undefined && {
            bookItNowHostDiscountPercentOffInput:
              input.bookItNowHostDiscountPercentOffInput,
          }),
        })
        .where(eq(properties.id, input.id));
    }),

  updatePropertyDiscountTiers: protectedProcedure
    .input(
      z.object({
        propertyId: z.number(),
        discountTiers: z.array(discountTierSchema).nullable(),
      }),
    )
    .mutation(async ({ input }) => {
      await db
        .update(properties)
        .set({
          ...(input.discountTiers && {
            discountTiers: input.discountTiers,
          }),
        })
        .where(eq(properties.id, input.propertyId));
    }),

  runSubscrapers: publicProcedure
    .input(
      z.object({
        propertyData: z.array(
          z.object({
            id: z.number(),
            originalListingId: z.string(),
            originalListingPlatform: z.string(),
            maxNumGuests: z.number(),
          }),
        ),
        checkIn: z.date(),
        checkOut: z.date(),
        numGuests: z.number(),
        location: z.string(),
      }),
    )
    .mutation(async ({ input }) => {
      const eligibleProperties = input.propertyData.filter(
        (p) => input.numGuests <= p.maxNumGuests,
      );

      if (eligibleProperties.length === 0) {
        return [];
      }

      const airbnbProperties = await scrapeAirbnbSearch({
        checkIn: input.checkIn,
        checkOut: input.checkOut,
        location: input.location,
        numGuests: input.numGuests,
      });

      const results = await checkAvailabilityForProperties({
        propertyIds: eligibleProperties.map((p) => p.id),
        originalListingIds: eligibleProperties.map((p) => p.originalListingId),
        originalListingPlatforms: eligibleProperties.map(
          (p) => p.originalListingPlatform,
        ),
        checkIn: input.checkIn,
        checkOut: input.checkOut,
        numGuests: input.numGuests,
      });

      // Filter the results to only include available properties with a price
      const filteredResults = results.filter(
        (result) =>
          result.isAvailableOnOriginalSite &&
          result.originalNightlyPrice !== undefined,
      );

      const filteredAirbnbProperties = airbnbProperties; //use to have a filter function removing null values

      const combinedResults = [...filteredAirbnbProperties, ...filteredResults];
      console.log("Combined results:", combinedResults);

      return combinedResults;
    }),

  // getBookItNowProperties: publicProcedure
  //   .input(z.object({
  //     checkIn: z.date(),
  //     checkOut: z.date(),
  //     numGuests: z.number(),
  //     location: z.string(),
  //     firstBatch: z.boolean(),
  //   }),
  //   )
  //   .query(async ({ input }) => {
  //     const { location } = await getCoordinates(input.location);
  //     if (!location) throw new Error("Could not get coordinates for address");
  //     console.log("location", location);

  //     let propertyIsNearRequest: SQL | undefined = sql`FALSE`;

  //     const radiusInMeters = 10 * 1609.34;

  //     propertyIsNearRequest = sql`
  //       ST_DWithin(
  //         ST_Transform(ST_SetSRID(properties.lat_lng_point, 4326), 3857),
  //         ST_Transform(ST_SetSRID(ST_MakePoint(${location.lng}, ${location.lat}), 4326), 3857),
  //         ${radiusInMeters}
  //       )
  //     `;
  //     console.time("Properties query");
  //     console.time("Airbnb search");
  //     console.time("full procedure")

  //     const propsPromise = db.query.properties.findMany({
  //       where: and(isNotNull(properties.originalListingPlatform), propertyIsNearRequest, ne(properties.originalListingPlatform, "Airbnb")),
  //     }).then(result => {
  //       console.timeEnd("Properties query");
  //       return result;
  //     });
  //     // const airbnbPromise = scrapeAirbnbSearch({
  //     //   checkIn: input.checkIn,
  //     //   checkOut: input.checkOut,
  //     //   location: input.location,
  //     //   numGuests: input.numGuests,
  //     // }).then(result => {
  //     //   console.timeEnd("Airbnb search");
  //     //   return result;
  //     // });

  //     const props = await propsPromise;

  //     let eligibleProperties = props.filter(
  //       (p) => input.numGuests <= p.maxNumGuests,
  //     );

  //     console.log("eligibleProperties", eligibleProperties.length);
  //     if (input.firstBatch) {
  //       eligibleProperties = eligibleProperties.slice(0, 30);
  //     } else {
  //       eligibleProperties = eligibleProperties.slice(30);
  //     }

  //     const results = await checkAvailabilityForProperties({
  //       propertyIds: eligibleProperties.map((p) => p.id),
  //       originalListingIds: eligibleProperties.map((p) => p.originalListingId ?? ""),
  //       originalListingPlatforms: eligibleProperties.map(
  //         (p) => p.originalListingPlatform ?? "",
  //       ),
  //       checkIn: input.checkIn,
  //       checkOut: input.checkOut,
  //       numGuests: input.numGuests,
  //     });

  //     console.timeEnd("checkAvailability");
  //     console.log("results", results.length);

  //     const fullPropertyData = await db.query.properties.findMany({
  //       where: inArray(properties.id, results.map((r) => r.propertyId)),
  //     });

  //     const updatedPropertyData = await Promise.all(results.map(async (r) => {
  //       const property = fullPropertyData.find((p) => p.id === r.propertyId);
  //       return { ...property, originalNightlyPrice: r.originalNightlyPrice };
  //     }));

  //     // const airbnbProperties = await airbnbPromise; // Ensures it completes before returning

  //     console.timeEnd("full procedure")

  //     return updatedPropertyData;
  //   }),

  getBookItNowProperties: publicProcedure
    .input(
      z.object({
        checkIn: z.date(),
        checkOut: z.date(),
        numGuests: z.number(),
        location: z.string(),
      }),
    )
    .query(async ({ input }) => {
      const { location } = await getCoordinates(input.location);
      if (!location) throw new Error("Could not get coordinates for address");
      console.log("location", location);

      const radiusInMeters = 20 * 1609.34;

      const propertyIsNearRequest = sql`
      ST_DWithin(
        ST_Transform(ST_SetSRID(properties.lat_lng_point, 4326), 3857),
        ST_Transform(ST_SetSRID(ST_MakePoint(${location.lng}, ${location.lat}), 4326), 3857),
        ${radiusInMeters}
      )
    `;
      const { checkIn, checkOut } = input;

      const checkInDate = checkIn.toISOString();
      const checkOutDate = checkOut.toISOString();

      const conflictingPropertyIds = await db.query.reservedDateRanges.findMany(
        {
          columns: { propertyId: true },
          where: and(
            or(
              and(
                lte(reservedDateRanges.start, checkInDate),
                gte(reservedDateRanges.end, checkInDate),
              ),
              and(
                lte(reservedDateRanges.start, checkOutDate),
                gte(reservedDateRanges.end, checkOutDate),
              ),
              and(
                gte(reservedDateRanges.start, checkInDate),
                lte(reservedDateRanges.end, checkOutDate),
              ),
            ),
          ),
        },
      );

      // Extract conflicting property IDs into an array
      const conflictingIds = conflictingPropertyIds.map(
        (item) => item.propertyId,
      );

      console.log("conflictingIds", conflictingIds.length);

      const hostProperties = await db.query.properties.findMany({
        where: and(
          eq(properties.originalListingPlatform, "Hospitable"),
          propertyIsNearRequest,
          notInArray(properties.id, conflictingIds), // Exclude properties with conflicting reservations
        ),
      });

      console.log("hostProperties", hostProperties.length);

      const checkInNew = new Date(checkInDate).toISOString().split("T")[0];
      const checkOutNew = new Date(checkOutDate).toISOString().split("T")[0];
      const validHostProperties: Property[] = [];
      //set the accurate original nightly price for Hospitable properties
      await Promise.all(
        hostProperties.map(async (property) => {
          try {
            const originalPrice = await getPropertyOriginalPrice(property, {
              checkIn: checkInNew!,
              checkOut: checkOutNew!,
              numGuests: input.numGuests,
            });
            property.originalNightlyPrice = originalPrice ?? null;

            // Push property to validHostProperties if successful
            validHostProperties.push(property);
          } catch (error) {
            console.error(`Failed for property ID ${property.id}:`, error);
          }
        }),
      );

      // Query for scraped properties with non-intersecting dates
      const scrapedProperties = await db.query.properties.findMany({
        where: and(
          ne(properties.originalListingPlatform, "Hospitable"),
          ne(properties.originalListingPlatform, "Airbnb"),
          propertyIsNearRequest,
          ne(properties.originalNightlyPrice, -1),
          isNotNull(properties.originalNightlyPrice),
          notInArray(properties.id, conflictingIds), // Exclude properties with conflicting reservations
        ),
      });
      return { hostProperties: validHostProperties, scrapedProperties };
    }),

  getSearchResults: hostProcedure
    .input(z.object({ searchQuery: z.string() }))
    .query(async ({ ctx, input }) => {
      if (input.searchQuery !== "") {
        return await ctx.db.query.properties.findMany({
          where: and(
            eq(properties.hostTeamId, ctx.hostProfile.curTeamId),
            or(
              like(properties.name, `%${input.searchQuery}%`),
              like(properties.city, `%${capitalize(input.searchQuery)}%`),
            ),
          ),
        });
      }
      return null;
    }),

  updatePropertySecurityDepositAmount: protectedProcedure
    .input(z.object({ propertyId: z.number(), amount: z.number() }))
    .mutation(async ({ input }) => {
      const property = await db
        .update(properties)
        .set({
          currentSecurityDeposit: input.amount,
        })
        .where(eq(properties.id, input.propertyId));

      return property;
    }),
});
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/server/api/routers/authRouter.ts</div>
<pre><code>
import PasswordResetEmailLink from "packages/transactional/emails/PasswordResetEmailLink";
import VerifyEmailLink from "packages/transactional/emails/VerifyEmail";
import { env } from "@/env";
import { CustomPgDrizzleAdapter } from "@/server/adapter";
import { db } from "@/server/db";
import { referralCodes, users, type User } from "@/server/db/schema";
import { addUserToGroups, sendEmail } from "@/server/server-utils";
import { generateReferralCode } from "@/utils/utils";
import { zodEmail, zodPassword } from "@/utils/zod-utils";
import { TRPCError } from "@trpc/server";
import * as bycrypt from "bcrypt";
import { eq } from "drizzle-orm";
import jwt from "jsonwebtoken";
import { z } from "zod";
import { createTRPCRouter, publicProcedure } from "../trpc";
import { waitUntil } from "@vercel/functions";
import { handlePendingInviteMessages } from "./hostTeamsRouter";

async function fetchEmailVerified(email: string) {
  return await db.query.users.findFirst({
    where: eq(users.email, email),
  });
}

async function updateExistingUserAuth(
  // name: string,
  email: string,
  hashedPassword: string,
  userQueriedId: string,
) {
  return await db
    .update(users)
    .set({
      // name: name,
      email: email,
      password: hashedPassword,
    })
    .where(eq(users.id, userQueriedId))
    .returning()
    .then((res) => res[0]!);
}

async function insertUserAuth(
  // name: string,
  email: string,
  hashedPassword: string,
  makeHost = false,
) {
  return await db
    .insert(users)
    .values({
      id: crypto.randomUUID(),
      // name: name,
      email: email,
      password: hashedPassword,
      role: makeHost ? "host" : "guest",
    })
    .returning()
    .then((res) => res[0]!);
}

async function sendVerificationEmail(user: User) {
  const payload = {
    email: user.email,
    id: user.id,
  };

  // Create token
  const token = jwt.sign(payload, env.NEXTAUTH_SECRET, {
    expiresIn: "30m",
  });

  const url = `${env.NEXTAUTH_URL}/auth/verifying-email?id=${user.id}&token=${token}`;

  await sendEmail({
    to: user.email,
    subject: "Verify Email | Tramona",
    content: VerifyEmailLink({ url, name: user.name ?? user.email }),
  });
}

export const authRouter = createTRPCRouter({
  createUser: publicProcedure
    .input(
      z.object({
        // name: zodString({ minLen: 2 }),
        email: zodEmail(),
        password: zodPassword(),
        referralCode: z.string().optional(),
      }),
    )
    .mutation(async ({ input, ctx }) => {
      const userQueriedWEmail = await fetchEmailVerified(input.email);

      if (userQueriedWEmail?.emailVerified) {
        return {
          status: "email taken",
        } as const;
      }

      const hashedPassword: string = await bycrypt.hash(input.password, 10);

      let user: User;

      // Users signed up but didn't verify email
      if (userQueriedWEmail?.emailVerified === null) {
        user = await updateExistingUserAuth(
          // input.name,
          input.email,
          hashedPassword,
          userQueriedWEmail.id,
        );
      } else {
        // Initial sign up insert the user info
        user = await insertUserAuth(input.email, hashedPassword);

        await Promise.all([
          // Create referral code
          ctx.db.insert(referralCodes).values({
            ownerId: user.id,
            referralCode: generateReferralCode(),
          }),

          // Link user account
          CustomPgDrizzleAdapter(ctx.db).linkAccount?.({
            provider: "credentials",
            providerAccountId: user.id,
            userId: user.id,
            type: "email",
          }),

          // add user to groups they were invited to
          addUserToGroups(user),
        ]);
      }
      waitUntil(handlePendingInviteMessages(input.email));

      await sendVerificationEmail(user);

      return {
        status: "success",
      } as const;
    }),

  checkEmailVerification: publicProcedure
    .input(
      z.object({
        email: zodEmail(),
      }),
    )
    .query(async ({ input }) => {
      const user = await fetchEmailVerified(input.email);

      if (!user) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "User with this email does not exist",
        });
      }

      return {
        emailVerified: user.emailVerified !== null,
      };
    }),

  createTempUserForGuest: publicProcedure
    .input(
      z.object({
        email: zodEmail(),
        isBurner: z.boolean(),
        sessionToken: z.string(),
      }),
    )
    .mutation(async ({ input, ctx }) => {
      const existedGuestTempUser = await ctx.db.query.users.findFirst({
        where: eq(users.sessionToken, input.sessionToken),
      });
      if (existedGuestTempUser) {
        return;
      }

      await ctx.db.insert(users).values({
        id: crypto.randomUUID(),
        email: input.email,
        isBurner: input.isBurner,
        sessionToken: input.sessionToken,
      });
    }),

  verifyEmailToken: publicProcedure
    .input(
      z.object({
        id: z.string(),
        token: z.string(),
        date: z.date(),
      }),
    )
    .mutation(async ({ input, ctx }) => {
      const user = await ctx.db.query.users.findFirst({
        where: eq(users.id, input.id),
      });

      // Check if user exist
      if (!user) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "User doesn't exist",
        });
      } else {
        // Verify the token
        try {
          const payload = jwt.verify(input.token, env.NEXTAUTH_SECRET);

          await ctx.db
            .update(users)
            .set({ emailVerified: input.date })
            .where(eq(users.id, input.id));

          return payload;
        } catch (error) {
          throw new TRPCError({
            code: "BAD_REQUEST",
            message: "Invalid token or user does not exist",
          });
        }
      }
    }),
  createUniqueForgotPasswordLink: publicProcedure
    .input(
      z.object({
        email: zodEmail(),
      }),
    )
    .mutation(async ({ input, ctx }) => {
      const user = await ctx.db.query.users.findFirst({
        where: eq(users.email, input.email),
      });

      if (!user)
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "User with this email does not exist",
        });

      if (!user.password)
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "User created with an auth provider (passwordless)",
        });

      const payload = {
        email: user.email,
        id: user.id,
      };

      // Create token
      const token = jwt.sign(payload, env.NEXTAUTH_SECRET, {
        expiresIn: "30m",
      });

      const url = `${env.NEXTAUTH_URL}/auth/reset-password?id=${user.id}&token=${token}`;

      await sendEmail({
        to: input.email,
        subject: "Reset Password | Tramona",
        content: PasswordResetEmailLink({ url, name: user.name ?? user.email }),
      });

      return null;
    }),
  verifyResetPasswordToken: publicProcedure
    .input(
      z.object({
        id: z.string(),
        token: z.string(),
      }),
    )
    .mutation(async ({ input, ctx }) => {
      let user;
      try {
        user = await ctx.db.query.users.findFirst({
          where: eq(users.id, input.id),
        });
      } catch (error) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "Invalid token or user does not exist",
        });
      }

      if (!user) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "Invalid token or user does not exist",
        });
      }

      if (!user.password) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "User created with an auth provider (passwordless)",
        });
      }

      try {
        const payload = jwt.verify(input.token, env.NEXTAUTH_SECRET);
        return payload;
      } catch (error) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "Invalid token or user does not exist",
        });
      }
    }),
  resetPassword: publicProcedure
    .input(
      z.object({
        id: z.string(),
        token: z.string(),
        newPassword: z.string(),
      }),
    )
    .mutation(async ({ input, ctx }) => {
      const user = await ctx.db.query.users.findFirst({
        where: eq(users.id, input.id),
      });

      if (!user) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "Invalid token or user does not exist",
        });
      }

      if (!user.password) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "User created with Google auth",
        });
      }

      try {
        jwt.verify(input.token, env.NEXTAUTH_SECRET);
      } catch (error) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "Invalid token or user does not exist",
        });
      }

      const isPasswordSame = await bycrypt.compare(
        input.newPassword,
        user.password,
      );

      if (isPasswordSame) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "New password cannot be the same as the old password",
        });
      }

      const newHashedPassword = await bycrypt.hash(input.newPassword, 10);

      await ctx.db
        .update(users)
        .set({ password: newHashedPassword })
        .where(eq(users.id, input.id));

      return {
        message: "Password changed successfully",
      };
    }),
});
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/server/api/routers/stripeRouter.ts</div>
<pre><code>
import { env } from "@/env";
import { createTRPCRouter, protectedProcedure } from "@/server/api/trpc";
import { properties, requestsToBook, trips, users } from "@/server/db/schema";
import { TRPCError } from "@trpc/server";
import { and, eq, gte, isNull, lte, ne } from "drizzle-orm";
import Stripe from "stripe";
import { z } from "zod";
import { createPayHostTransfer } from "@/utils/stripe-utils";
import { breakdownPaymentByPropertyAndTripParams } from "@/utils/payment-utils/paymentBreakdown";
import { db } from "@/server/db";
import { finalizeTrip } from "@/utils/webhook-functions/stripe-utils";

export const config = {
  api: {
    bodyParser: false,
  },
};
// these two are the same stripe objects, some stripe require the secret key and some require the restricted key
export const stripe = new Stripe(env.STRIPE_RESTRICTED_KEY_ALL);

export const stripeWithSecretKey = new Stripe(env.STRIPE_SECRET_KEY, {
  typescript: true,
});
// change the apiVersion

export const stripeRouter = createTRPCRouter({
  createStripeCustomer: protectedProcedure
    .input(
      z.object({
        email: z.string(),
        name: z.string().optional(),
        firstName: z.string().optional(),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      const customer = await stripeWithSecretKey.customers.create({
        email: input.email,
        name: input.name ?? input.firstName ?? ctx.user.id,
      });
      await ctx.db
        .update(users)
        .set({
          stripeCustomerId: customer.id,
        })
        .where(eq(users.id, ctx.user.id));
    }),

  createCheckoutSession: protectedProcedure
    .input(
      z.object({
        listingId: z.number(),
        propertyId: z.number(),
        requestId: z.number().nullable(),
        name: z.string(),
        price: z.number(), // Total price included tramona fee
        tramonaServiceFee: z.number(),
        description: z.string(),
        cancelUrl: z.string(),
        images: z.array(z.string().url()),
        userId: z.string(),
        phoneNumber: z.string(),
        totalSavings: z.number(),
        hostStripeId: z.string().nullable(),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      const currentDate = new Date(); // Get the current date and time
      //we need the host Stripe account id to put in webhook
      //get hostID from the property
      // Object that can be access through webhook and client
      const metadata = {
        user_id: ctx.user.id,
        listing_id: input.listingId,
        property_id: input.propertyId,
        request_id: input.requestId,
        price: input.price, // Total price included tramona fee
        tramonaServiceFee: input.tramonaServiceFee,
        total_savings: input.totalSavings,
        confirmed_at: currentDate.toISOString(),
        phone_number: input.phoneNumber,
        host_stripe_id: input.hostStripeId ?? "",
      };
      console.log(metadata.host_stripe_id);
      const paymentIntentData: Stripe.Checkout.SessionCreateParams.PaymentIntentData =
        {
          metadata: metadata, // metadata access for payment intent (webhook access)

          ...(metadata.host_stripe_id
            ? {
                transfer_data: {
                  amount: input.price - input.tramonaServiceFee,
                  destination: metadata.host_stripe_id,
                },
              }
            : {}),
        };

      const session = await stripe.checkout.sessions.create({
        mode: "payment",
        payment_method_types: ["card"],
        submit_type: "book",
        line_items: [
          {
            price_data: {
              currency: "usd",
              unit_amount: input.price,
              product_data: {
                name: input.name,
                description: input.description,
                metadata: metadata,
                images: input.images,
              },
            },
            quantity: 1,
          },
        ],
        // success_url: `${env.NEXTAUTH_URL}/offers/${input.listingId}/?session_id={CHECKOUT_SESSION_ID}`,
        //success_url: `${env.NEXTAUTH_URL}/offers/${input.listingId}`, //remove becuase we are now using embedded
        //cancel_url: `${env.NEXTAUTH_URL}${input.cancelUrl}`,
        return_url: `${env.NEXTAUTH_URL}/my-trips`, //redirect to my-trips page after payment
        metadata: metadata, // metadata access for checkout session
        payment_intent_data: paymentIntentData,
        ui_mode: "embedded",
      });
      console.log("This is the host stripe id ", metadata.host_stripe_id);
      return { clientSecret: session.client_secret };
    }),

  // Get the customer info
  createSetupIntentSession: protectedProcedure
    .input(
      z.object({
        listingId: z.number(),
        propertyId: z.number(),
        requestId: z.number(),
        price: z.number(),
        cancelUrl: z.string(),
        name: z.string(),
        description: z.string(),
        // images: z.array(z.string().url()),
        phoneNumber: z.string(),
        totalSavings: z.number(),
        // hostId: z.string(),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      let stripeCustomerId = await ctx.db.query.users
        .findFirst({
          columns: {
            stripeCustomerId: true,
          },
          where: eq(users.id, ctx.user.id),
        })
        .then((res) => res?.stripeCustomerId);

      // ! UNCOMMENT FOR TESTING PURPOSES
      if (!stripeCustomerId) {
        stripeCustomerId = await stripe.customers
          .create({
            name: ctx.user.name ?? "",
            email: ctx.user.email,
          })
          .then((res) => res.id);
      }

      // const stripeCustomerId = "cus_PwwCgSdIG3rWNx";

      const currentDate = new Date(); // Get the current date and time

      // Object that can be access through webhook and client
      const metadata = {
        user_id: ctx.user.id,
        listing_id: input.listingId,
        property_id: input.propertyId,
        request_id: input.requestId,
        price: input.price,
        total_savings: input.totalSavings,
        confirmed_at: currentDate.toISOString(),
        phone_number: input.phoneNumber,
        // host_id: input.hostId,
      };

      if (stripeCustomerId) {
        return stripe.checkout.sessions.create({
          payment_method_types: ["card"],
          currency: "usd",
          success_url: `${env.NEXTAUTH_URL}/requests/${input.requestId}/?session_id={CHECKOUT_SESSION_ID}`,
          cancel_url: `${env.NEXTAUTH_URL}${input.cancelUrl}`,
          // return_url: `${env.NEXTAUTH_URL}/payment-intent`,
          // redirect_on_completion: "never",
          metadata: metadata, // metadata access for checkout session
          customer: stripeCustomerId,
        });
      }
    }),

  createSetupIntent: protectedProcedure
    .input(
      z.object({
        paymentMethod: z.string(),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      let stripeCustomerId = await ctx.db.query.users
        .findFirst({
          columns: {
            stripeCustomerId: true,
          },
          where: eq(users.id, ctx.user.id),
        })
        .then((res) => res?.stripeCustomerId);

      // Create a customer id if it doesn't exist
      if (!stripeCustomerId) {
        stripeCustomerId = await stripe.customers
          .create({
            name: ctx.user.name ?? "",
            email: ctx.user.email,
          })
          .then((res) => res.id);

        await ctx.db
          .update(users)
          .set({ stripeCustomerId })
          .where(eq(users.id, ctx.user.id));
      }

      if (stripeCustomerId) {
        const options: Stripe.SetupIntentCreateParams = {
          automatic_payment_methods: {
            enabled: true,
          },
          customer: stripeCustomerId,
          payment_method: input.paymentMethod,
          // Set the payment method as default for the customer
          usage: "off_session", // or 'on_session' depending on your use case
        };

        const response = await stripe.setupIntents.create(options);
        return response;
      }
    }),

  // Get the customer info
  authorizePayment: protectedProcedure // this is how will now creat a checkout session using a custom flow
    .input(
      z.object({
        totalAmountPaid: z.number(),
        cancelUrl: z.string(),
        offerId: z.number().nullable(),
        scrapeUrl: z.string().nullable(),
        numOfGuests: z.number().nullable(),
        travelerOfferedPriceBeforeFees: z.number(),
        datePriceFromAirbnb: z.number().nullable(),
        checkIn: z.date(),
        checkOut: z.date(),
        propertyId: z.number(),
        type: z.enum(["bookItNow", "requestToBook", "offer"]),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      const currentDate = new Date(); // Get the current date and time
      //we need the host Stripe account id to put in webhook
      //get hostID from the property
      // Object that can be access through webhook and client
      //check if a customer id exists

      let stripeCustomerId = await ctx.db.query.users
        .findFirst({
          columns: {
            stripeCustomerId: true,
          },
          where: eq(users.id, ctx.user.id),
        })
        .then((res) => res?.stripeCustomerId);
      if (!stripeCustomerId) {
        const customer = await stripeWithSecretKey.customers.create({
          email: ctx.user.email,
          name: ctx.user.name ?? ctx.user.id,
        });
        await ctx.db
          .update(users)
          .set({
            stripeCustomerId: customer.id,
          })
          .where(eq(users.id, ctx.user.id));

        stripeCustomerId = customer.id;
      }

      const curProperty = await db.query.properties
        .findFirst({
          where: eq(properties.id, input.propertyId),
          with: {
            hostTeam: {
              with: {
                owner: true,
              },
            },
            reviews: true,
          },
        })
        .then((res) => res!);

      const paymentBreakdown = breakdownPaymentByPropertyAndTripParams({
        dates: {
          checkIn: input.checkIn,
          checkOut: input.checkOut,
        },
        travelerPriceBeforeFees: input.travelerOfferedPriceBeforeFees,
        property: curProperty,
      });

      const metadata = {
        is_charged_with_setup_intent: "false",
        confirmed_at: currentDate.toISOString(),

        user_email: ctx.user.email,
        user_id: ctx.user.id,
        phone_number: ctx.user.phoneNumber,
        stripe_customer_id: stripeCustomerId,

        offer_id: input.offerId,
        check_in: input.checkIn.toString(),
        check_out: input.checkOut.toString(),
        property_id: input.propertyId,
        host_stripe_id: curProperty.hostTeam.owner.stripeConnectId,
        traveler_offered_price_before_fees:
          input.travelerOfferedPriceBeforeFees,
        price: paymentBreakdown.totalTripAmount, // Total price included tramona fee
        total_savings: paymentBreakdown.totalSavings,
        taxes_paid: paymentBreakdown.taxesPaid,
        tax_percentage: paymentBreakdown.taxPercentage,
        stripe_transaction_fee: paymentBreakdown.stripeTransactionFee,
        superhog_paid: paymentBreakdown.superhogFee,
        is_direct_listing: input.scrapeUrl ? "true" : "false",
        num_of_guests: input.numOfGuests,
        type: input.type,
      };

      const options: Stripe.PaymentIntentCreateParams = {
        metadata: metadata,
        amount: metadata.price,
        capture_method: "manual", // this is saying that we will capture the payment later and not now
        payment_method_options: {
          // this is saying we can charge more after payment is completed if not using card(any method that does not support capture)
          card: {
            capture_method: "manual",
          },
        },
        currency: "usd", //input.currency for now we will use usd
        setup_future_usage: "off_session", // is both of and on session
        // In the latest version of the API, specifying the `automatic_payment_methods` parameter is optional because Stripe enables its functionality by default.
        automatic_payment_methods: { enabled: true },
        // ...(metadata.host_stripe_id
        //   ? {
        //       transfer_data: {
        //         amount: metadata.price - metadata.tramonaServiceFee, // we need to change this too.
        //         destination: metadata.host_stripe_id,
        //       },
        //     }
        //   : {}),
      };

      const response = await stripe.paymentIntents.create(options);

      return response;
    }),

  capturePayment: protectedProcedure // not using rn because the logic is in the stripe-webhook/superhog router.
    .input(z.object({ paymentIntentId: z.string() }))
    .mutation(async ({ ctx, input }) => {
      const intent = await stripe.paymentIntents.capture(input.paymentIntentId); //will capture the authorized amount by default
      // will trigger the payment_intent.amount_capturable_updated
      await ctx.db
        .update(trips)
        .set({ paymentCaptured: new Date() })
        .where(eq(trips.paymentIntentId, input.paymentIntentId));
      return intent;
    }),

  rejectOrCaptureAndFinalizeRequestToBook: protectedProcedure
    .input(
      z.object({
        requestToBookId: z.number(),
        isAccepted: z.boolean(),
      }),
    )
    .mutation(async ({ input }) => {
      //check to make sure user is authorized

      //update results in db.
      const curRequestToBook = await db
        .update(requestsToBook)
        .set({
          resolvedAt: new Date(),
          status: input.isAccepted ? "Accepted" : "Denied",
        })
        .where(eq(requestsToBook.id, input.requestToBookId))
        .returning()
        .then((res) => res[0]!);

      if (!input.isAccepted) {
        return;
      } else {
        //since accepted we need to finilize the trip

        await finalizeTrip({
          //trip and tripcheckout creattion, superhog, and sending notifcations
          paymentIntentId: curRequestToBook.paymentIntentId,
          numOfGuests: curRequestToBook.numGuests,
          travelerPriceBeforeFees:
            curRequestToBook.amountAfterTravelerMarkupAndBeforeFees, //markup already happened
          checkIn: curRequestToBook.checkIn,
          checkOut: curRequestToBook.checkOut,
          propertyId: curRequestToBook.propertyId,
          userId: curRequestToBook.userId,
          isDirectListingCharge: curRequestToBook.isDirectListing,
          source: "Request to book",
          requestToBookId: curRequestToBook.id,
        });

        //now we need to cancel all current request during that same time,
        const activeRequestToBookThatNeedsToBeRemoved = await db
          .update(requestsToBook)
          .set({
            resolvedAt: new Date(),
            status: "Withdrawn",
          })
          .where(
            and(
              isNull(requestsToBook.resolvedAt),
              ne(requestsToBook.id, curRequestToBook.id),
              and(
                lte(requestsToBook.checkIn, curRequestToBook.checkOut),
                gte(requestsToBook.checkOut, curRequestToBook.checkIn),
              ),
            ),
          );
        console.log(activeRequestToBookThatNeedsToBeRemoved);
      }
      return;
    }),

  confirmSetupIntent: protectedProcedure
    .input(
      z.object({
        setupIntent: z.string(),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      const si = await stripe.setupIntents.retrieve(input.setupIntent);

      if (!si.payment_method) {
        throw new Error("Payment method not found");
      }

      let stripeCustomerId = await ctx.db.query.users
        .findFirst({
          columns: {
            stripeCustomerId: true,
          },
          where: eq(users.id, ctx.user.id),
        })
        .then((res) => res?.stripeCustomerId);

      // Create a customer id if it doesn't exist
      if (!stripeCustomerId) {
        stripeCustomerId = await stripe.customers
          .create({
            name: ctx.user.name ?? "",
            email: ctx.user.email,
          })
          .then((res) => res.id);

        await ctx.db
          .update(users)
          .set({ stripeCustomerId })
          .where(eq(users.id, ctx.user.id));
      }

      if (!stripeCustomerId) {
        throw new Error("Customer not found");
      }

      await stripe.paymentMethods.attach(si.payment_method as string, {
        customer: stripeCustomerId,
      });

      await stripe.customers.update(si.customer as string, {
        invoice_settings: {
          default_payment_method: si.payment_method as string,
        },
      });

      await ctx.db
        .update(users)
        .set({ setupIntentId: input.setupIntent })
        .where(eq(users.id, ctx.user.id));
    }),

  getListOfPayments: protectedProcedure.query(async ({ ctx }) => {
    if (ctx.user.stripeCustomerId) {
      const cards = await stripe.paymentMethods.list({
        type: "card",
        customer: ctx.user.stripeCustomerId,
      });

      const customer = await stripe.customers.retrieve(
        ctx.user.stripeCustomerId,
      );

      if (customer.deleted) {
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: "Customer not found",
        });
      }

      return {
        // ! Need to get type of invoice_settings
        defaultPaymentMethod: customer.invoice_settings.default_payment_method,
        cards,
      };
    }
  }),

  getStripeSession: protectedProcedure
    .input(
      z.object({
        sessionId: z.string(),
      }),
    )
    .mutation(async ({ input }) => {
      const session = await stripe.checkout.sessions.retrieve(input.sessionId, {
        expand: ["setup_intent"],
      });

      return {
        metadata: {
          user_id: session.metadata?.user_id,
          stripe_email_used: session.customer_details?.email,
          stripe_phone_used: session.customer_details?.phone,
          price: session.metadata?.price,
          listing_id: session.metadata?.listing_id,
          property_id: session.metadata?.property_id,
          request_id: session.metadata?.request_id,
          checkout_session_id: session.id,
          total_savings: session.metadata?.total_savings,
          confirmed_at: session.metadata?.confirmed_at,
          phoneNumber: session.metadata?.phone_number,
          // host_id: session.metadata?.host_id
          setupIntent: session.setup_intent,
        },
      };
    }),

  //stripe connect account (outdated)
  createStripeConnectAccount: protectedProcedure.mutation(async ({ ctx }) => {
    const res = await ctx.db.query.users.findFirst({
      columns: {
        firstName: true,
        lastName: true,
        stripeConnectId: true,
        chargesEnabled: true,
      },
      where: eq(users.id, ctx.user.id),
    });
    if (!res?.stripeConnectId) {
      const stripeAccount = await stripeWithSecretKey.accounts.create({
        country: "US", //change this to the user country later
        email: ctx.user.email,
        settings: {},
        controller: {
          losses: {
            payments: "application",
          },
          fees: {
            payer: "application",
          },
          stripe_dashboard: {
            type: "express",
          },
        },
        //charges_enabled: true,
        capabilities: {
          card_payments: { requested: true },
          transfers: { requested: true },
          tax_reporting_us_1099_k: { requested: true },
        },
        business_type: "individual",
        business_profile: {
          url: "https://tramona.com",
          mcc: "4722",
          product_description: "Travel and Tourism",
        },
        individual: {
          email: ctx.user.email,
          first_name: res?.firstName ?? "",
        },
      });
      await ctx.db
        .update(users)
        .set({ stripeConnectId: stripeAccount.id })
        .where(eq(users.id, ctx.user.id));

      return stripeAccount;
    } else {
      throw new Error("Stripe account already created");
    }
  }),

  retrieveStripeConnectAccount: protectedProcedure
    .input(z.string())
    .query(async ({ input }) => {
      const account = await stripeWithSecretKey.accounts.retrieve(input);
      return account;
    }),

  //we need this to create embedded connet account
  createStripeAccountSession: protectedProcedure
    .input(z.string())
    .query(async ({ input }) => {
      const accountId = input;
      const accountSession = await stripeWithSecretKey.accountSessions.create({
        account: accountId,
        components: {
          account_onboarding: {
            enabled: true,
            features: {
              external_account_collection: true,
            },
          },
          account_management: {
            enabled: true,
            features: {
              external_account_collection: true,
            },
          },
          payments: {
            enabled: true,
            features: {
              refund_management: true,
              dispute_management: true,
              capture_payments: true,
              destination_on_behalf_of_charge_management: false,
            },
          },
          payouts: {
            enabled: true,
            features: {
              instant_payouts: true,
              standard_payouts: true,
              edit_payout_schedule: true,
            },
          },
          // payouts_list: {
          //   enabled: true,
          // },
          notification_banner: {
            enabled: true,
            features: {
              external_account_collection: true,
            },
          },
          // balances: {
          //   enabled: true,
          //   features: {
          //     instant_payouts: true,
          //     standard_payouts: true,
          //     edit_payout_schedule: true,
          //   },
          // },
        },
      });

      return accountSession;
    }),
  checkStripeConnectAccountBalance: protectedProcedure
    .input(z.string())
    .query(async ({ input }) => {
      const accountId = input;
      const balance = await stripeWithSecretKey.balance.retrieve({
        stripeAccount: accountId,
      });

      return balance;
    }),

  listAllStripePayouts: protectedProcedure
    .input(z.string())
    .query(async ({ input }) => {
      const accountId = input;
      const payout = await stripe.payouts.list({
        stripeAccount: accountId,
      });
      return payout.data;
    }),

  getConnectedExternalBank: protectedProcedure
    .input(z.string())
    .query(async ({ input }) => {
      const accountId = input;
      const externalAccounts = await stripe.accounts.listExternalAccounts(
        accountId,
        {
          object: "bank_account",
        },
      );

      return externalAccounts.data;
    }),

  getAllTransactionPayments: protectedProcedure
    .input(z.string())
    .query(async ({ input }) => {
      let hasMore = true;
      let startingAfter: string | null = null;
      const allTransactions: Stripe.BalanceTransaction[] = [];

      while (hasMore) {
        const params: { limit: number; type: string; starting_after?: string } =
          {
            limit: 100,
            type: "payment",
            ...(startingAfter && { starting_after: startingAfter }),
          };

        const response = await stripe.balanceTransactions.list(params, {
          stripeAccount: input,
        });

        if (response.data.length > 0) {
          allTransactions.push(...response.data);
          hasMore = response.has_more;
          startingAfter = response.data[response.data.length - 1]?.id ?? null;
        } else {
          hasMore = false;
        }
      }

      return allTransactions;
    }),

  getAllTransactionPaymentsWithinInterval: protectedProcedure
    .input(
      z.object({
        stripeAccountId: z.string(),
        startDate: z.number(),
        endDate: z.number(),
      }),
    )
    .query(async ({ input }) => {
      let hasMore = true;
      let startingAfter: string | null = null;
      const allTransactions: Stripe.BalanceTransaction[] = [];

      while (hasMore) {
        const params: {
          limit: number;
          type: string;
          starting_after?: string;
          created: { gte: number; lte: number };
        } = {
          limit: 100,
          type: "payment",
          created: {
            gte: input.startDate, //takes unix timestamps
            lte: input.endDate,
          },
          ...(startingAfter && { starting_after: startingAfter }),
        };

        const response = await stripe.balanceTransactions.list(params, {
          stripeAccount: input.stripeAccountId,
        });

        if (response.data.length > 0) {
          allTransactions.push(...response.data);
          hasMore = response.has_more;
          startingAfter = response.data[response.data.length - 1]?.id ?? null;
        } else {
          hasMore = false;
        }
      }

      return allTransactions;
    }),

  createVerificationSession: protectedProcedure.query(async ({ ctx }) => {
    const verificationSession =
      await stripe.identity.verificationSessions.create({
        type: "document",
        metadata: {
          user_id: ctx.user.id,
        },
      });

    // Return only the client secret to the frontend.
    const clientSecret = verificationSession.client_secret;
    return clientSecret;
  }),

  getVerificationReports: protectedProcedure.query(async () => {
    return await stripe.identity.verificationReports.list({
      limit: 3,
    });
  }),

  getVerificationReportsById: protectedProcedure
    .input(z.object({ verificationId: z.string() }))
    .query(async ({ input }) => {
      const verificationReport =
        await stripe.identity.verificationReports.retrieve(
          input.verificationId,
        );
      return verificationReport;
    }),

  getSetUpIntent: protectedProcedure
    .input(
      z.object({
        setupIntent: z.string(),
      }),
    )
    .mutation(async ({ input }) => {
      const setupIntent = await stripe.setupIntents.retrieve(input.setupIntent);

      return {
        setupIntent: setupIntent,
      };
    }),

  // TODO: create a PaymentIntent for admin/host to accept the bidding based of the user intent

  getVerificationStatus: protectedProcedure.query(({ ctx }) => {
    const result = ctx.db.query.users.findFirst({
      where: eq(users.id, ctx.user.id),
      columns: { isIdentityVerified: true },
    });

    return result;
  }),

  payHostByTransfer: protectedProcedure
    .input(
      z.object({
        amount: z.number(),
        destination: z.string(),
        tripId: z.string(),
      }),
    )
    .mutation(async ({ input }) => {
      //we first need to make sure we have enought balance on the tramona account
      await createPayHostTransfer({
        amount: input.amount,
        destination: input.destination,
        tripId: input.tripId,
      });
      console.log("Payment test successful");
    }),

  stripeTopUp: protectedProcedure //this function is used for topping up for test transactions
    .input(z.object({ amount: z.number() }))
    .query(async ({ input }) => {
      const topup = await stripe.topups.create({
        amount: input.amount, //
        currency: "usd",
        description: "Top-up for week of May 31",
        statement_descriptor: "Weekly top-up",
      });
      return topup;
    }),
  chargeForDamagesOrMisc: protectedProcedure
    .input(
      z.object({
        tripId: z.number(),
        amount: z.number(),
        customerId: z.string(),
        setupIntentId: z.string(),
        description: z.string(),
        currency: z.string().optional(),
        propertyId: z.number(),
      }),
    )
    .mutation(async ({ input }) => {
      try {
        //retreit the setupIntent objext to get the payment method
        const setupIntentObject = await stripe.setupIntents.retrieve(
          input.setupIntentId,
        );
        const paymentMethodId = setupIntentObject.payment_method as string;

        const paymentIntent = await stripeWithSecretKey.paymentIntents.create({
          amount: input.amount,
          customer: input.customerId,
          payment_method: paymentMethodId,
          confirm: true, // Tries to confirm immediately
          description: input.description,
          currency: input.currency ?? "usd",
          metadata: {
            is_charged_with_setup_intent: "true",
            customer_id: input.customerId,
            trip_id: input.tripId,
            description: input.description,
            property_id: input.propertyId,
          },
          automatic_payment_methods: {
            enabled: true,
            allow_redirects: "never",
          },
        });

        // Check the status of the PaymentIntent
        if (paymentIntent.status === "succeeded") {
          // we need to insert it into the database
          //creates the damage record as well
          console.log("Charge successful:", paymentIntent);
          return paymentIntent; // Payment was completed successfully
        } else if (
          paymentIntent.status === "requires_action" ||
          paymentIntent.status === "requires_confirmation"
        ) {
          console.log("Additional action required for:", paymentIntent);
          // You need to handle the additional action on the client side
          return paymentIntent;
        } else {
          console.error("PaymentIntent status:", paymentIntent.status);
          throw new Error("Failed to complete the charge.");
        }
      } catch (error) {
        console.error("Charge error:", error);
        throw error;
      }
    }),
});
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/server/api/routers/miscRouter.ts</div>
<pre><code>
import {
  ALL_LISTING_SITE_NAMES,
  ALL_PROPERTY_PMS,
  requestSelectSchema,
} from "@/server/db/schema";
import { createTRPCRouter, publicProcedure } from "../trpc";
import { env } from "@/env";
import { format } from "date-fns";
import { TRPCError } from "@trpc/server";
import { zodUrl } from "@/utils/zod-utils";
import { getAddress, getCoordinates } from "@/server/google-maps";
import { Airbnb } from "@/utils/listing-sites/Airbnb";
import { z } from "zod";
import {
  scrapeAirbnbInitialPageHelper,
  scrapeAirbnbPagesHelper,
  getPropertyOriginalPrice,
  urlScrape,
} from "@/server/server-utils";
import { scrapeAirbnbPrice } from "@/server/scrapePrice";
import { fetchPriceNoRateLimit } from "@/server/direct-sites-scraping/casamundo-scraper";

type AirbnbListing = {
  id: string;
  url: string;
  deeplink: string;
  position: number;
  name: string;
  bathrooms: number;
  bedrooms: number;
  beds: number;
  city: string;
  images: unknown[];
  hostThumbnail: string;
  isSuperhost: boolean;
  rareFind: boolean;
  lat: number;
  lng: number;
  persons: number;
  reviewsCount: number;
  type: string;
  userId: number;
  address: string;
  amenityIds: unknown[];
  previewAmenities: unknown[];
  cancelPolicy: string;
  price: {
    rate: number;
    currency: string;
    total: number;
  };
};

type ApiResponse = {
  error: boolean;
  headers: unknown;
  results: AirbnbListing[];
};

export const miscRouter = createTRPCRouter({
  getAverageNightlyPrice: publicProcedure
    .input(
      requestSelectSchema.pick({
        location: true,
        checkIn: true,
        checkOut: true,
        numGuests: true,
      }),
    )
    .query(async ({ input }) => {
      const price = (await fetch(
        `https://${env.RAPIDAPI_HOST}/search-location?` +
          new URLSearchParams({
            location: input.location,
            checkin: format(input.checkIn, "yyyy-MM-dd"),
            checkout: format(input.checkOut, "yyyy-MM-dd"),
            adults: input.numGuests.toString(),
          }).toString(),
        {
          method: "GET",
          headers: {
            "X-RapidAPI-Key": env.RAPIDAPI_KEY,
            "X-RapidAPI-Host": env.RAPIDAPI_HOST,
          },
        },
      ).then((res) => res.json())) as ApiResponse;

      if (price.error) {
        throw new TRPCError({ code: "BAD_REQUEST" });
      }

      // Calculate average nightly price
      const averageNightlyPrice =
        Array.isArray(price.results) && price.results.length > 0
          ? price.results.reduce((acc, listing) => {
              return acc + listing.price.rate;
            }, 0) / price.results.length
          : 0;

      return averageNightlyPrice;
    }),

  scrapeAirbnbInitialPage: publicProcedure
    .input(
      z.object({
        checkIn: z.date(),
        checkOut: z.date(),
        location: z.string(),
        numGuests: z.number(),
      }),
    )
    .query(async ({ input }) => {
      const { checkIn, checkOut, location, numGuests } = input;
      return await scrapeAirbnbInitialPageHelper({
        checkIn,
        checkOut,
        location,
        numGuests,
      });
    }),

  scrapeAirbnbPages: publicProcedure
    .input(
      z.object({
        pageCursors: z.string().array(),
        checkIn: z.date(),
        checkOut: z.date(),
        location: z.string(),
        numGuests: z.number(),
      }),
    )
    .query(async ({ input }) => {
      const { checkIn, checkOut, location, numGuests, pageCursors } = input;
      return await scrapeAirbnbPagesHelper({
        checkIn,
        checkOut,
        location,
        numGuests,
        cursors: pageCursors,
      });
    }),

  getAverageHostPropertyPrice: publicProcedure
    .input(
      z.object({
        property: z.object({
          originalListingId: z.string().nullable(),
          originalListingPlatform: z
            .enum([...ALL_LISTING_SITE_NAMES, ...ALL_PROPERTY_PMS])
            .nullable(), //["Hospitable", "Hostaway"]
          hospitableListingId: z.string().nullable(),
        }),
        checkIn: z.string(),
        checkOut: z.string(),
        numGuests: z.number(),
      }),
    )
    .query(async ({ input: { property, checkIn, checkOut, numGuests } }) => {
      //This should only work for properties that are linked to hostinger
      if (!property.originalListingPlatform) throw new Error();

      const averagePrice = await getPropertyOriginalPrice(property, {
        checkIn,
        checkOut,
        numGuests,
      });
      return averagePrice;
    }),

  scrapeAverageCasamundoPrice: publicProcedure
    .input(
      z.object({
        offerId: z.string(),
        checkIn: z.date(),
        numGuests: z.number(),
        duration: z.number(),
      }),
    )
    .query(async ({ input: { offerId, checkIn, numGuests, duration } }) => {
      const price = await fetchPriceNoRateLimit({
        offerId,
        checkIn,
        numGuests,
        duration,
      });

      if (price.status === "success") {
        return price.price / duration;
      }
      return price.status;
    }),

  scrapeAirbnbLink: publicProcedure
    .input(
      z.object({
        url: zodUrl(),
        params: z.object({
          checkIn: z.string(),
          checkOut: z.string(),
          numGuests: z.number(),
        }),
      }),
    )
    .query(async ({ input: { url, params } }) => {
      const airbnbListingId = Airbnb.parseId(url);
      if (!airbnbListingId) return { status: "failed to parse url" } as const;

      const [$, price] = await Promise.all([
        urlScrape(url),
        scrapeAirbnbPrice({ airbnbListingId, params }),
      ]);

      // title is swapped with description because the og:description is actually the property title,
      // and the og:title is more like a description
      const title = $('meta[property="og:description"]').attr("content");
      const description = $('meta[property="og:title"]').attr("content");
      const imageUrl = $('meta[property="og:image"]').attr("content");

      const pageTitle = $("title").text();
      if (!title || !description || !imageUrl || !pageTitle) {
        return { status: "failed to scrape" } as const;
      }

      // refactor to use regex
      const cityName = pageTitle.match(/for Rent in (.*?) - Airbnb/)?.[1];

      console.log(cityName);

      if (!cityName) {
        return { status: "failed to parse title" } as const;
      }

      const coords = await getCoordinates(cityName).then((res) => res.location);

      const locationParts =
        coords && (await getAddress(coords).catch(() => undefined));

      const location = `${locationParts?.city}, ${locationParts?.stateCode}, ${locationParts?.country}`;

      if (!location) {
        return { status: "failed to extract city" } as const;
      }
      console.log(title, description, imageUrl, location, price);
      return {
        status: "success",
        data: { title, description, imageUrl, location, price },
      } as const;
    }),
});
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/server/api/routers/referralCodesRouter.ts</div>
<pre><code>
import {
  createTRPCRouter,
  protectedProcedure,
  publicProcedure,
} from "@/server/api/trpc";
import {
  hostReferralDiscounts,
  referralCodes,
  referralEarnings,
  users,
} from "@/server/db/schema";
import { TRPCError } from "@trpc/server";
import { and, eq, isNotNull, sql } from "drizzle-orm";
import { z } from "zod";

export const referralCodesRouter = createTRPCRouter({
  startUsingCode: protectedProcedure
    .input(z.string())
    .mutation(async ({ ctx, input }) => {
      if (ctx.user.referralCodeUsed) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "You already used a referral code",
        });
      }

      const referralCode = await ctx.db.query.referralCodes.findFirst({
        where: eq(referralCodes.referralCode, input),
        columns: {
          ownerId: true,
        },
      });

      if (!referralCode) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "Invalid referral code",
        });
      }

      if (referralCode.ownerId === ctx.user.id) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "You cannot use your own referral code",
        });
      }

      await ctx.db.transaction(async (tx) => {
        const results = await Promise.allSettled([
          // use the referral code
          tx
            .update(users)
            .set({ referralCodeUsed: input })
            .where(eq(users.id, ctx.user.id)),

          // increment numSignUpsUsingCode
          tx
            .update(referralCodes)
            .set({
              numSignUpsUsingCode: sql`${referralCodes.numSignUpsUsingCode} + 1`,
            })
            .where(eq(referralCodes.referralCode, input)),
        ]);

        if (results.some((result) => result.status === "rejected")) {
          throw new TRPCError({
            code: "INTERNAL_SERVER_ERROR",
          });
        }
      });

      const referralCodeOwner = await ctx.db.query.users.findFirst({
        where: eq(users.id, referralCode.ownerId),
        columns: {
          name: true,
          image: true,
        },
      });

      return {
        owner: {
          name: referralCodeOwner?.name ?? "an anonymous person",
          image: referralCodeOwner?.image ?? null,
        },
      };
    }),

  stopUsingCode: protectedProcedure.mutation(async ({ ctx }) => {
    const userDetails = await ctx.db.query.users.findFirst({
      where: eq(users.id, ctx.user.id),
      columns: {
        referralCodeUsed: true,
      },
    });

    if (!userDetails?.referralCodeUsed) {
      throw new TRPCError({
        code: "BAD_REQUEST",
        message: "You don't have a referral code",
      });
    }

    await ctx.db
      .update(users)
      .set({ referralCodeUsed: null })
      .where(eq(users.id, ctx.user.id));
  }),

  verifyCode: publicProcedure
    .input(z.string())
    .mutation(async ({ ctx, input }) => {
      const code = await ctx.db.query.referralCodes.findFirst({
        where: eq(referralCodes.referralCode, input),
        columns: {
          referralCode: true,
        },
      });
      return !!code;
    }),

  getReferralCodeInfo: protectedProcedure.query(async ({ ctx }) => {
    const userReferralCode = await ctx.db.query.referralCodes.findFirst({
      where: eq(referralCodes.ownerId, ctx.user.id),
    });

    if (userReferralCode) {
      // const earnings = await ctx.db.query.referralEarnings.findMany({
      //   with: {
      //     referee: {
      //       columns: {
      //         name: true,
      //       },
      //     },
      //     offer: {
      //       columns: {
      //         totalBasePriceBeforeFees: true,
      //       },
      //     },
      //   },
      //   where: eq(referralEarnings.referralCode, userReferralCode.referralCode),
      const earnings = await ctx.db.query.referralCodes.findFirst({
        where: eq(referralCodes.referralCode, userReferralCode.referralCode),
      });
      return earnings;
    }
  }),

  getAllEarningsByReferralCode: protectedProcedure.query(async ({ ctx }) => {
    const userReferralCode = await ctx.db.query.referralCodes.findFirst({
      where: eq(referralCodes.ownerId, ctx.user.id),
    });
    if (!userReferralCode?.referralCode) return [];

    const allEarningTransactions = await ctx.db.query.referralEarnings.findMany(
      {
        where: eq(referralEarnings.referralCode, userReferralCode.referralCode),
        with: {
          referee: {
            columns: {
              name: true,
              firstName: true,
            },
          },
          offer: {
            columns: {
              travelerOfferedPriceBeforeFees: true,
            },
          },
        },
      },
    );
    return allEarningTransactions;
  }),

  getAllHostReferralDiscounts: protectedProcedure.query(async ({ ctx }) => {
    const discounts = await ctx.db.query.hostReferralDiscounts.findMany({
      where: eq(hostReferralDiscounts.ownerId, ctx.user.id),
    });
    return discounts;
  }),

  getAllUnusedHostReferralDiscounts: protectedProcedure.query(
    async ({ ctx }) => {
      const discounts = await ctx.db.query.hostReferralDiscounts.findMany({
        where: and(
          isNotNull(hostReferralDiscounts.validatedAt),
          eq(hostReferralDiscounts.ownerId, ctx.user.id),
        ),
      });
      return discounts;
    },
  ),

  getMyReferralCodeData: protectedProcedure.query(async ({ ctx }) => {
    return await ctx.db.query.referralCodes.findFirst({
      where: eq(referralCodes.ownerId, ctx.user.id),
    });
  }),
});
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/server/api/routers/requestsToBookRouter.ts</div>
<pre><code>
import {
  createTRPCRouter,
  hostProcedure,
  protectedProcedure,
} from "@/server/api/trpc";
import { db } from "@/server/db";
import {
  requestsToBook,
  requestsToBookInsertSchema,
  statusEnumArray,
} from "@/server/db/schema";
import { TRPCError } from "@trpc/server";
import { z } from "zod";
import { eq } from "drizzle-orm";
import { properties } from "@/server/db/schema";

export const requestsToBookRouter = createTRPCRouter({
  create: protectedProcedure
    .input(
      requestsToBookInsertSchema.omit({
        id: true,
        createdAt: true,
        userId: true,
      }),
    )
    .mutation(async ({ ctx, input }) => {
      const newRequest = await db
        .insert(requestsToBook)
        .values({
          ...input,
          userId: ctx.user.id,
        })
        .returning();

      if (!newRequest[0]) {
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: "Failed to create request to book",
        });
      }

      return newRequest[0];
    }),

  getMyRequestsToBook: protectedProcedure.query(async ({ ctx }) => {
    console.log("User ID from context:", ctx.user.id); // Log the user ID

    const myRequestsToBook = await ctx.db.query.requestsToBook.findMany({
      where: eq(requestsToBook.userId, ctx.user.id),
      with: {
        property: {
          columns: {
            amenities: true,
            city: true,
            imageUrls: true,
            name: true,
            numBedrooms: true,
            numBathrooms: true,
            bookOnAirbnb: true,
            hostName: true,
            hostProfilePic: true,
          },
        },
      },
    });

    return {
      activeRequestsToBook: myRequestsToBook.filter(
        (requestToBook) => requestToBook.resolvedAt === null,
      ),
      inactiveRequestsToBook: myRequestsToBook.filter(
        (requestToBook) => requestToBook.resolvedAt !== null,
      ),
    };
  }),

  delete: protectedProcedure
    .input(z.object({ id: z.number(), status: z.enum(statusEnumArray) }))
    .mutation(async ({ ctx, input }) => {
      // Only group owner and admin can delete
      // (or anyone if there's no group owner for whatever reason)

      if (ctx.user.role !== "admin") {
        const request = await ctx.db.query.requestsToBook.findFirst({
          where: eq(requestsToBook.id, input.id),
          with: {
            madeByGroup: true,
          },
        });

        if (!request?.madeByGroup) {
          throw new TRPCError({ code: "BAD_REQUEST" });
        }

        if (ctx.user.id !== request.madeByGroup.ownerId) {
          throw new TRPCError({ code: "UNAUTHORIZED" });
        }
      }

      await ctx.db
        .update(requestsToBook)
        .set({
          resolvedAt: new Date(),
          status: input.status,
        })
        .where(eq(requestsToBook.id, input.id));
    }),

  getHostRequestsToBookFromId: hostProcedure
    .input(z.object({ propertyId: z.number() }))
    .query(async ({ ctx, input }) => {
      const property = await ctx.db.query.properties.findFirst({
        where: eq(properties.id, input.propertyId),
        columns: { hostTeamId: true },
      });

      if (!property) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Property not found",
        });
      }

      // Check if user is authorized
      if (
        ctx.user.role !== "admin" &&
        property.hostTeamId !== ctx.hostProfile.curTeamId
      ) {
        throw new TRPCError({
          code: "UNAUTHORIZED",
          message: "You are not authorized to view these requests",
        });
      }

      const propertyRequestsToBook = await ctx.db.query.requestsToBook.findMany(
        {
          where: eq(requestsToBook.propertyId, input.propertyId),
          with: {
            property: {
              columns: {
                name: true,
                imageUrls: true,
                numBedrooms: true,
                numBathrooms: true,
                bookOnAirbnb: true,
                hostName: true,
                hostProfilePic: true,
                city: true,
              },
            },
            madeByGroup: {
              columns: {
                ownerId: true,
              },
              with: {
                owner: {
                  columns: {
                    firstName: true,
                    lastName: true,
                    name: true,
                    image: true,
                    location: true,
                    about: true,
                  },
                },
              },
            },
          },
        },
      );

      const transformedRequestsToBook = propertyRequestsToBook.map(
        (request) => ({
          ...request,
          traveler: request.madeByGroup.owner,
        }),
      );

      return {
        activeRequestsToBook: transformedRequestsToBook.filter(
          (requestToBook) => requestToBook.resolvedAt === null,
        ),
        inactiveRequestsToBook: transformedRequestsToBook.filter(
          (requestToBook) => requestToBook.resolvedAt !== null,
        ),
      };
    }),

  getAllRequestToBookProperties: hostProcedure.query(async ({ ctx }) => {
    const allPropertiesWithRequestToBook = await db.query.properties.findMany({
      where: eq(properties.hostTeamId, ctx.hostProfile.curTeamId),
      with: {
        requestsToBook: {
          with: {
            madeByGroup: {
              with: {
                owner: true,
              },
            },
          },
        },
      },
    });

    return allPropertiesWithRequestToBook;
  }),
});
</code></pre>
</div>
<div class='section'>
<h2 class='section-title'>Utilities and Helpers</h2>
<div class='file'>
<div class='file-name'>./src/utils/utils.ts</div>
<pre><code>
import { Offer, REFERRAL_CODE_LENGTH } from "@/server/db/schema";
import { RequestsPageOfferData, SeparatedData } from "@/server/server-utils";
import { useWindowSize } from "@uidotdev/usehooks";
import { clsx, type ClassValue } from "clsx";
import {
  differenceInDays,
  differenceInYears,
  formatDate,
  type FormatOptions,
  isSameDay,
  isSameMonth,
  isSameYear,
} from "date-fns";
import { type RefObject, useEffect, useState } from "react";
import { twMerge } from "tailwind-merge";
import dayjs from "dayjs";
import relativeTime from "dayjs/plugin/relativeTime";
import duration from "dayjs/plugin/duration";
import {
  HostRequestsPageData,
  HostRequestsPageOfferData,
} from "@/server/api/routers/propertiesRouter";
import * as cheerio from "cheerio";
import { useSession } from "next-auth/react";
import { api } from "./api";
import { HOST_MARKUP, TRAVELER_MARKUP } from "./constants";
import { InferQueryModel } from "@/server/db";
import {
  TripWithDetails,
  TripWithDetailsConfirmation,
} from "@/components/my-trips/TripPage";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export function generateReferralCode() {
  const characters = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  let randomString = "";

  for (let i = 0; i < REFERRAL_CODE_LENGTH; i++) {
    const randomIndex = Math.floor(Math.random() * characters.length);
    randomString += characters.charAt(randomIndex);
  }

  return randomString;
}

export function generatePhoneNumberOTP() {
  return Math.floor(100000 + Math.random() * 900000).toString();
}

export async function sleep(ms: number) {
  return new Promise((res) => setTimeout(res, ms));
}

/**
 * Examples:
 * ```js
 * plural(1, "apple") => "1 apple"
 * plural(2, "apple") => "2 apples"
 * plural(2, "octopus", "octopi") => "2 octopi"
 * ```
 */
export function plural(count: number, noun: string, pluralNoun?: string) {
  if (count === 1) return `1 ${noun}`;
  return `${count} ${pluralNoun ? pluralNoun : noun + "s"}`;
}

/**
 * formats the price IN CENTS
 *
 * Examples:
 * ```js
 * formatCurrency(10) => "$0.10"
 * formatCurrency(2000) => "$20.00"
 * ```
 */
export function formatCurrency(cents: number, { round = false } = {}) {
  const dollars = round ? Math.round(cents / 100) : cents / 100;
  return dollars.toLocaleString("en-US", {
    style: "currency",
    currency: "USD",
  });
}

/**
 * does the inverse of `formatCurrency`
 */
export function parseCurrency(str: string) {
  const dollars = parseFloat(str.replace(/[^0-9.-]+/g, ""));
  return Math.round(dollars * 100);
}

/**
 * Examples:
 * ```js
 * capitalize("apple") => "Apple"
 * capitalize("ASDF") => "ASDF"
 * ```
 */
export function capitalize(str: string) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Example outputs:
 * ```js
 * "Jan 1, 2021"
 * "Jan 1  2, 2021"
 * "Jan 1  Feb 2, 2021"
 * "Jan 1, 2021  Feb 2, 2022"
 * ```
 */

export function formatDateRange(
  fromDate: Date,
  toDate?: Date,
  { withWeekday = false } = {},
) {
  const from = removeTimezoneFromDate(fromDate);
  const to = toDate ? removeTimezoneFromDate(toDate) : "";

  const isCurYear = isSameYear(from, new Date());
  const sameMonth = isSameMonth(from, to);
  const sameYear = isSameYear(from, to);

  if (withWeekday) {
    if (!to || isSameDay(from, to)) {
      return formatDate(from, "EEE, MMM d, yyyy");
    }

    if (sameYear) {
      return `${formatDate(from, "EEE, MMM d")}  ${formatDate(
        to,
        isCurYear ? "EEE, MMM d" : "EEE, MMM d, yyyy",
      )}`;
    }
  }

  if (!to || isSameDay(from, to)) {
    const format = isCurYear ? "MMM d" : "MMM d, yyyy";
    return formatDate(from, format);
  }

  if (sameMonth && sameYear) {
    return `${formatDate(from, "MMM d")}  ${formatDate(
      to,
      isCurYear ? "d" : "d, yyyy",
    )}`;
  }
  if (sameYear) {
    return `${formatDate(from, "MMM d")}  ${formatDate(
      to,
      isCurYear ? "MMM d" : "MMM d, yyyy",
    )}`;
  }
  return `${formatDate(from, "MMM d, yyyy")}  ${formatDate(to, "MMM d, yyyy")}`;
}

/**
 * wrapper for formatDate for YYYY-MM-DD strings only that adds a T00:00
 * to the end of the date string to prevent the timezone from getting converted
 * to UTC and the formatted date being 1 day off.
 *
 * @example
 * ```js
 * formatDateString("2023-03-01", "MMM d, yyyy"); // Mar 1, 2023
 * ```
 */
export function formatDateString(
  date: string,
  formatStr: string,
  options: FormatOptions = {},
) {
  if (!date.match(/^\d{4}-\d{2}-\d{2}$/)) {
    throw new Error("Invalid date format, must be YYYY-MM-DD");
  }
  return formatDate(`${date}T00:00`, formatStr, options);
}

// TODO: clean this all up (make it for strings only)

export function removeTimezoneFromDate(date: Date | string) {
  if (typeof date === "string") return date;
  return new Date(date).toISOString().split("Z")[0]!;
}

export function getDaysUntilTrip(checkIn: Date) {
  dayjs.extend(relativeTime);
  dayjs.extend(duration);

  const now = dayjs();

  const fmtdCheckIn = dayjs(checkIn).startOf("day");

  const daysToGo = Math.ceil(
    dayjs.duration(fmtdCheckIn.diff(now)).asDays() + 1,
  );

  return daysToGo;
}

//converts date string to a formatted date string with day name
//ex out put Mon, Aug 19
export function formatDateStringWithDayName(dateStr: string): string {
  // Convert the string to a Date object
  const dateObj = new Date(dateStr);

  // Define the format options
  const options: Intl.DateTimeFormatOptions = {
    weekday: "short",
    month: "short",
    day: "numeric",
  };

  // Format the Date object to the desired string format
  return dateObj.toLocaleDateString("en-US", options);
}
export function formatDateMonthDay(date: Date | string) {
  if (typeof date === "string") return formatDateString(date, "MMMM d");
  return formatDate(removeTimezoneFromDate(date), "MMMM d");
}

export function formatDateWeekMonthDay(date: Date | string) {
  if (typeof date === "string") return formatDateString(date, "EEE, MMM d");
  return formatDate(removeTimezoneFromDate(date), "EEE, MMM d");
}

export function formatDateMonthDayYear(date: Date | string) {
  if (typeof date === "string") return formatDateString(date, "MMMM d, yyyy");
  return formatDate(removeTimezoneFromDate(date), "MMMM d, yyyy");
}

export function formatDateYearMonthDay(date: Date | string) {
  if (typeof date === "string") return formatDateString(date, "yyyy-MM-dd");
  return formatDate(removeTimezoneFromDate(date), "yyyy-MM-dd"); //ex 2021-12-31
}

export function formatShortDate(date: Date | string) {
  if (typeof date === "string") return formatDateString(date, "M/d/yyyy");
  return formatDate(removeTimezoneFromDate(date), "M/d/yyyy"); //ex 8/20/2024
}

export function convertDateFormat(dateString: string) {
  const [year, month, day] = dateString.split("-");
  return `${month}/${day}/${year}`;
}

export function addDays(date: Date, days: number): Date {
  //add days to a date object
  const result = new Date(date);
  result.setDate(result.getDate() + days);
  return result;
}

export function getElapsedTime(createdAt: Date): string {
  const now = new Date();
  const diffInSeconds = Math.floor(
    (now.getTime() - createdAt.getTime()) / 1000,
  );

  if (diffInSeconds < 60) {
    return `${diffInSeconds} second${diffInSeconds !== 1 ? "s" : ""} ago`;
  }

  const diffInMinutes = Math.floor(diffInSeconds / 60);
  if (diffInMinutes < 60) {
    return `${diffInMinutes} minute${diffInMinutes !== 1 ? "s" : ""} ago`;
  }

  const diffInHours = Math.floor(diffInMinutes / 60);
  if (diffInHours < 24) {
    return `${diffInHours} hour${diffInHours !== 1 ? "s" : ""} ago`;
  }

  const diffInDays = Math.floor(diffInHours / 24);
  return `${diffInDays} day${diffInDays !== 1 ? "s" : ""} ago`;
}

export function getDisplayedName(realname: string | null): string {
  const userFirstName = realname?.split(" ")[0];
  const userLastName = realname?.split(" ")[1];
  const userLastNameInitial = userLastName
    ? userLastName[0]?.toUpperCase() + "."
    : "";
  const displayedName = userFirstName + " " + userLastNameInitial;
  return displayedName;
}
// not used right now and probably will never have to:

// export function formatDateRangeFromStrs(from: string, to?: string) {
//   const fromDate = new Date(from + "T00:00:00");
//   const toDate = to ? new Date(to + "T00:00:00") : undefined;

//   return formatDateRange(fromDate, toDate);
// }

// TODO: fix hacky

export function getNumNights(from: Date | string, to: Date | string) {
  return Math.round(
    (new Date(to).getTime() - new Date(from).getTime()) / (1000 * 60 * 60 * 24),
  );
}

export function getHostPayout(totalBasePriceBeforeFees: number) {
  return Math.floor(totalBasePriceBeforeFees * HOST_MARKUP);
}

export function getTravelerOfferedPrice({
  totalBasePriceBeforeFees,
  travelerMarkup, //we need this because can be traveler or direct listing markup
}: {
  totalBasePriceBeforeFees: number;
  travelerMarkup: number;
}) {
  return Math.ceil(totalBasePriceBeforeFees * travelerMarkup);
}

export function removeTravelerMarkup(amountWithTravelerMarkup: number) {
  const basePrice = amountWithTravelerMarkup / TRAVELER_MARKUP;
  return Math.round(basePrice);
}

export function getPropertyId(url: string): number | null {
  const parsedUrl = new URL(url);
  const pathSegments = parsedUrl.pathname.split("/");
  const propertyId = pathSegments[pathSegments.length - 1];
  if (propertyId) {
    return parseInt(propertyId);
  } else {
    return null;
  }
}

/**
 * @returns `now`, `10 minutes`, `5 hours`, `2 days`, `1 week`, `10 weeks`, etc
 */
export function formatInterval(ms: number) {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);
  const weeks = Math.floor(days / 7);

  if (weeks) return plural(weeks, "week");
  if (days) return plural(days, "day");
  if (hours > 18) return "1 day";
  if (hours) return plural(hours, "hr");
  if (minutes) return plural(minutes, "minute");
  return "now";
}

export function formatArrayToString(
  arr: string[],
  { junction }: { junction: "and" | "or" } = { junction: "and" },
) {
  if (arr.length === 0) {
    return "";
  } else if (arr.length === 1) {
    return arr[0]!;
  } else if (arr.length === 2) {
    return `${arr[0]} ${junction} ${arr[1]}`;
  } else {
    const lastItem = arr.pop();
    const joinedItems = arr.join(", ");
    return `${joinedItems}, ${junction} ${lastItem}`;
  }
}

export async function retry<T>(f: Promise<T>, numRetries: number) {
  for (let i = 0; i < numRetries; i++) {
    try {
      return await f.catch(() => {
        throw new Error();
      });
    } catch (err) {}
  }
}

export function getDiscountPercentage(
  originalPrice: number,
  discountPrice: number,
) {
  return Math.round((1 - discountPrice / originalPrice) * 100);
}

// functions for when css doesnt cut it for showing/hiding stuff on screens
// use these as a last resort cuz it can cause jank with ssr (unless the element isnt
// visible on the first render in which case it doesnt matter for ssr)

// these will need to be kept in sync with
// https://tailwindcss.com/docs/screens and ./tailwind.config.ts

const useScreenWidth = () => useWindowSize().width ?? 0;

/**
 * screen width >= 640 (same as tailwind `sm:`)
 */
export const useIsSm = () => useScreenWidth() >= 640;

/**
 * screen width >= 768 (same as tailwind `md:`)
 */
export const useIsMd = () => useScreenWidth() >= 768;

/**
 * screen width >= 1024 (same as tailwind `lg:`))
 */
export const useIsLg = () => useScreenWidth() >= 1024;

/**
 * screen width >= 1280 (same as tailwind `xl:`))
 */
export const useIsXl = () => useScreenWidth() >= 1280;

export function getFromAndTo(page: number, itemPerPage: number) {
  let from = page * itemPerPage;

  const to = from + itemPerPage;

  if (page > 0) {
    from += 1;
  }

  return { from, to };
}

// hopefully we wont need this
export function convertUTCDateToLocalDate(date: Date) {
  const newDate = new Date(
    date.getTime() + date.getTimezoneOffset() * 60 * 1000,
  );

  const offset = date.getTimezoneOffset() / 60;
  const hours = date.getHours();

  newDate.setHours(hours - offset);

  return newDate;
}

export function checkDuplicates(nums: number[]) {
  const set = new Set();

  for (const num of nums) {
    if (set.has(num)) {
      return true;
    }

    set.add(num);
  }

  return false;
}

export const generateTimeStamp = () => {
  const date = new Date();
  const milliseconds = Math.round(date.getMilliseconds() / 10); // Round to 2 decimal places
  const formattedMilliseconds = milliseconds.toString().padStart(2, "0"); // Ensure 2 digits

  const formattedTimestamp: string =
    date.toISOString().slice(0, -5) + "." + formattedMilliseconds;

  return formattedTimestamp;
};

export function convertTo12HourFormat(time24: string) {
  // Split the input time into hours and minutes
  const [hourStr, minuteStr] = time24.split(":");
  let hours = parseInt(hourStr ?? "", 10);
  const minutes = parseInt(minuteStr ?? "", 10);

  // Determine the period (AM/PM)
  const period = hours >= 12 ? "PM" : "AM";

  // Convert hours from 24-hour format to 12-hour format
  hours = hours % 12;
  hours = hours ? hours : 12; // the hour '0' should be '12'

  // Format the minutes to always be two digits
  const formattedMinutes = minutes < 10 ? `0${minutes}` : minutes;

  // Combine the hours, minutes, and period
  const time12 = `${hours}:${formattedMinutes} ${period}`;

  return time12;
}

export function convertTo24HourFormat(time: string): string {
  // Assuming input format is HH:mm:ss
  const [hour, minute] = time.split(":");
  const formattedHour = (hour ?? "").padStart(2, "0");
  const formattedMinute = (minute ?? "").padStart(2, "0");
  return `${formattedHour}:${formattedMinute}`;
}

export function useOverflow(ref: RefObject<HTMLDivElement>): boolean {
  const [isOverflowing, setIsOverflowing] = useState<boolean>(false);

  useEffect(() => {
    const element = ref.current;
    if (element) {
      const handleResize = () => {
        setIsOverflowing(element.scrollWidth > element.clientWidth);
      };

      handleResize();

      window.addEventListener("resize", handleResize);
      return () => window.removeEventListener("resize", handleResize);
    }
  }, [ref]);

  return isOverflowing;
}

export function getAge(birthdate: string) {
  return differenceInYears(new Date(), new Date(birthdate));
}

export function formatTime(time: string) {
  const [hour, minute] = time.split(":").map(Number);
  if (hour === undefined || minute === undefined) return time;
  const fmtdMinutes = minute < 10 ? `0${minute}` : minute;
  return hour > 12
    ? `${hour - 12}:${fmtdMinutes} PM`
    : `${hour}:${fmtdMinutes} AM`;
}

export function scrollToTop() {
  window.scrollTo({ top: 0, behavior: "smooth" });
}

export function separateByPriceAndAgeRestriction(
  organizedData: HostRequestsPageData[],
): SeparatedData {
  const processedData = organizedData.map((cityData) => {
    const processedRequests = cityData.requests.map((requestData) => {
      const nightlyPrice =
        requestData.request.maxTotalPrice /
        getNumNights(requestData.request.checkIn, requestData.request.checkOut);

      const travelerAge = requestData.request.traveler.dateOfBirth
        ? getAge(requestData.request.traveler.dateOfBirth)
        : null;

      const normalProperties = requestData.properties.filter((property) => {
        if (property.city === "Seattle, WA, US") {
          console.log(property.priceRestriction, nightlyPrice);
        }
        return (
          (property.priceRestriction == null ||
            property.priceRestriction <= nightlyPrice) &&
          (property.ageRestriction == null ||
            (travelerAge !== null && travelerAge >= property.ageRestriction))
        );
      });

      const outsideProperties = requestData.properties.filter(
        (property) =>
          property.priceRestriction != null &&
          property.priceRestriction >= nightlyPrice * 1.15 &&
          property.ageRestriction != null &&
          (travelerAge === null || travelerAge < property.ageRestriction),
      );

      return {
        normal:
          normalProperties.length > 0
            ? { ...requestData, properties: normalProperties }
            : null,
        outside:
          outsideProperties.length > 0
            ? { ...requestData, properties: outsideProperties }
            : null,
      };
    });

    const normalRequests = processedRequests
      .map((req) => req.normal)
      .filter(
        (req): req is HostRequestsPageData["requests"][number] => req !== null,
      );
    const outsideRequests = processedRequests
      .map((req) => req.outside)
      .filter(
        (req): req is HostRequestsPageData["requests"][number] => req !== null,
      );

    return {
      normal: {
        city: cityData.city,
        requests: normalRequests,
      },
      outsidePriceRestriction: {
        city: cityData.city,
        requests: outsideRequests,
      },
    };
  });

  return {
    normal: processedData.map((data) => data.normal),
    outsidePriceRestriction: processedData.map(
      (data) => data.outsidePriceRestriction,
    ),
  };
}

export function formatOfferData(
  organizedData: HostRequestsPageOfferData[],
): RequestsPageOfferData {
  return {
    sent: organizedData,
  };
}

export function containsHTML(str: string) {
  const tags = [
    "<br />",
    "<br>",
    "<br/>",
    "<p>",
    "</p>",
    "<div>",
    "</div>",
    "<b>",
    "</b>",
    "<i>",
    "</i>",
    "<u>",
    "</u>",
    "<span>",
    "</span>",
    "<h1>",
    "</h1>",
    "<h2>",
    "</h2>",
    "<h3>",
    "</h3>",
    "<h4>",
    "</h4>",
  ];

  return tags.filter((tag) => str.includes(tag)).length >= 2;
}

export function mulberry32(seed: number) {
  let t = seed + 0x6d2b79f5;
  t = Math.imul(t ^ (t >>> 15), t | 1);
  t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
  return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
}

export function originalListingIdToRandomDiscount(input: string): number {
  let hash = 0;
  for (let i = 0; i < input.length; i++) {
    hash = (hash << 5) - hash + input.charCodeAt(i); // hash * 31 + charCode
    hash |= 0; // convert to 32bit integer
  }
  // normalize hash to a float
  const normalizedValue = (hash >>> 0) / 4294967296;
  // scale to range [8, 14]
  return 8 + normalizedValue * (14 - 8);
}

// falls back to a random discount between 8% and 12% if the original nightly price is not available
export function getOfferDiscountPercentage(
  offer: Pick<
    Offer,
    | "createdAt"
    | "travelerOfferedPriceBeforeFees"
    | "checkIn"
    | "checkOut"
    | "scrapeUrl"
    | "datePriceFromAirbnb"
    | "randomDirectListingDiscount"
  >,
) {
  //1.)check to see if scraped property(directListing) and the randomDirectListingDiscount is not null
  if (offer.randomDirectListingDiscount) {
    return offer.randomDirectListingDiscount;
  }

  //2.) check if the property is going to be booked directly on airbnb TODO

  //3.) check the if the offer is by a real host and is listed on airbnb
  if (offer.datePriceFromAirbnb) {
    console.log(
      offer.datePriceFromAirbnb,
      offer.travelerOfferedPriceBeforeFees,
    );
    return getDiscountPercentage(
      offer.datePriceFromAirbnb,
      offer.travelerOfferedPriceBeforeFees,
    );
  }
  //4.)for other cases random number
  else return Math.round(8 + 4 * mulberry32(offer.createdAt.getTime())); // random number between 8 and 12, deterministic based on offer creation time
}

// export function getrequestToBookMaxDiscountPercentage(offer: {
//   createdAt: Date;
//   travelerOfferedPriceBeforeFees: number;
//   checkIn: Date;
//   checkOut: Date;
//   scrapeUrl?: number | null;
//   datePriceFromAirbnb: number | null;
//   randomDirectListingDiscount?: number | null;
// }) {
//   const numNights = getNumNights(offer.checkIn, offer.checkOut);
//   const offerNightlyPrice = offer.travelerOfferedPriceBeforeFees / numNights;
//   //1.)check to see if scraped property(directListing) and the randomDirectListingDiscount is not null
//   if (offer.randomDirectListingDiscount) {
//     return offer.randomDirectListingDiscount;
//   }

//   //2.) check if the property is going to be booked directly on airbnb TODO

//   //3.) check the if the offer is by a real host and is listed on airbnb
//   if (offer.datePriceFromAirbnb) {
//     console.log(
//       offer.datePriceFromAirbnb,
//       offer.travelerOfferedPriceBeforeFees,
//     );
//     return getDiscountPercentage(
//       offer.datePriceFromAirbnb,
//       offer.travelerOfferedPriceBeforeFees,
//     );
//   }
//   //4.)for other cases random number
//   else return Math.round(8 + 4 * mulberry32(offer.createdAt.getTime())); // random number between 8 and 12, deterministic based on offer creation time
// }

export function createRandomMarkupEightToFourteenPercent() {
  return Math.floor(Math.random() * 7 + 8);
}

export function parseHTML(str: string) {
  const ret = cheerio
    .load(
      str
        .replaceAll("<br />", "\n")
        .replaceAll("<br/>", "\n")
        .replaceAll("<br>", "\n"),
    )(":root")
    .prop("innerText");

  if (ret === null) throw new Error("Failed to parse HTML");
  return ret;
}

export function censorEmail(email: string) {
  const [name, domain] = email.split("@");

  if (!domain) {
    return "Invalid email format";
  }

  const censoredName = name![0] + "*".repeat(name!.length - 1);

  return censoredName + "@" + domain;
}

export function censorPhoneNumber(phoneNumber: string) {
  // Regex to match the area code
  const regex = /^(\+\d{1,3})(\d{3})\d{7}$/;

  if (regex.test(phoneNumber)) {
    // Replace the parts of the number that are not in the area code
    return phoneNumber.replace(/(^\+\d{1,3})(\d{3})(\d{7})$/, "$1$2*** - ****");
  }

  return "Invalid phone number format";
}

export function censorTravelerFullName(name: string) {
  return name;
}

export function logAndFilterSettledResults<T>(
  results: PromiseSettledResult<T>[],
) {
  return results
    .filter((r) => {
      if (r.status === "rejected") console.error(r.reason);
      return r.status === "fulfilled";
    })
    .map((r) => r.value);
}

export function useUpdateUser() {
  const { mutateAsync: updateProfile } = api.users.updateProfile.useMutation();
  const { update } = useSession();

  return {
    updateUser: async (updates: Parameters<typeof updateProfile>[0]) => {
      await updateProfile(updates);
      await update();
    },
  };
}

export function removeTax(total: number, taxRate: number): number {
  if (taxRate < 0 || taxRate >= 1) {
    throw new Error("Tax rate must be between 0 and 1");
  }
  const amountWithoutTax = Math.round(total / (1 + taxRate));
  return amountWithoutTax;
}

export const getApplicableBookItNowDiscount = ({
  discountTiers,
  checkIn,
}: {
  discountTiers: { days: number; percentOff: number }[] | null | undefined;
  checkIn: Date;
}): number | null => {
  if (!discountTiers || discountTiers.length === 0) {
    return null;
  }

  const daysUntilCheckIn = differenceInDays(checkIn, new Date());

  const sortedTiers = [...discountTiers].sort((a, b) => b.days - a.days);

  const applicableDiscount = sortedTiers.find(
    (tier) => daysUntilCheckIn >= tier.days,
  );

  return applicableDiscount?.percentOff ?? null;
};

export const capitalizeFirstLetter = (string: string): string => {
  return string.charAt(0).toUpperCase() + string.slice(1);
};

// Function to lowercase the first letter

export const lowerCase = (str: string): string => {
  return str.charAt(0).toLowerCase() + str.slice(1).toLowerCase();
};

export const titleCase = (str: string): string => {
  return str
    .toLowerCase()
    .split(" ")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(" ");
};

export function getHostNameAndImage(
  property: InferQueryModel<
    "properties",
    {
      columns: {
        id: true;
        hostName: true;
        hostProfilePic: true;
      };
      with: {
        hostTeam: {
          with: {
            owner: {
              columns: {
                firstName: true;
                lastName: true;
                name: true;
                image: true;
              };
            };
          };
        };
      };
    }
  >,
) {
  let teamOwner;

  teamOwner = property.hostTeam.owner;

  const ownerName =
    teamOwner.firstName && teamOwner.lastName
      ? `${teamOwner.firstName} ${teamOwner.lastName}`
      : teamOwner.name;

  if (!ownerName) {
    throw new Error(`Host name not found for property ${property.id}`);
  }

  // since we will be hosting scraped properties from a tramona host team, we want
  // to use the hostName and hostProfilePic if they exist, otherwise we use the
  // team owner's name and image. Hopefully hostName and hostProfilePic will be
  // available for scraped properties, but if they're not, it will fall back to
  // saying "hosted by Tramona". And for non-scraped properties, hostName and
  // hostProfilePic will be null, so this will return the team owner's name and
  // image as intended.
  return {
    name: property.hostName ?? ownerName,
    image: property.hostProfilePic ?? teamOwner.image,
  };
}

type InteractionPreferences =
  | "not available"
  | "say hello"
  | "socialize"
  | "no preference"
  | null;

export function convertInteractionPreference(pref: InteractionPreferences) {
  let modifiedPref = null;
  switch (pref) {
    case "not available":
      modifiedPref =
        "I won't be available in person, and prefer communicating through the app.";
      break;
    case "say hello":
      modifiedPref =
        "I like to say hello in person, but keep to myself otherwise.";
      break;
    case "socialize":
      modifiedPref = "I like socializing and spending time with guests.";
      break;
    case "no preference":
      modifiedPref = "No preferences - I follow my guests' lead.";
      break;
  }

  return modifiedPref;
}

export function isTrip5pmBeforeCheckout(
  tripData: TripWithDetails | TripWithDetailsConfirmation,
) {
  const { trip } = tripData;

  const now = new Date();

  const checkoutDate = new Date(trip.checkOut);

  const targetDate = new Date(checkoutDate);
  // set target date to day before checkout date
  targetDate.setDate(checkoutDate.getDate() - 1);
  // set time to 5:00 pm
  targetDate.setHours(17, 0, 0, 0);

  // check if current date is after 5 pm on the day before checkout
  return now >= targetDate;
}

export function isTripWithin48Hours(
  tripData: TripWithDetails | TripWithDetailsConfirmation,
) {
  const { trip } = tripData;
  // now: current date and time
  const now = new Date();

  const checkInDate = new Date(trip.checkIn);
  // targetDate: 48 hours before check-in date
  const targetDate = new Date(checkInDate.getTime() - 48 * 60 * 60 * 1000);

  // check if current date is after target date
  return now >= targetDate;
}

export function convertMonthToNumber(month: string) {
  switch (month) {
    case "January":
      return 0;
    case "February":
      return 1;
    case "March":
      return 2;
    case "April":
      return 3;
    case "May":
      return 4;
    case "June":
      return 5;
    case "July":
      return 6;
    case "August":
      return 7;
    case "September":
      return 8;
    case "October":
      return 9;
    case "November":
      return 10;
    case "December":
      return 11;
    default:
      return 0;
  }
}

export function validateDateValues({
  day,
  month,
  year,
}: {
  day: number;
  month: number;
  year: number;
}) {
  if (year < 1900 || year > new Date().getFullYear()) {
    return "Please enter a valid year";
  }
  if (month >= 0 && month <= 6) {
    if (month % 2 === 0) {
      if (day < 1 || day > 31) {
        return "Please enter a valid day";
      }
    } else {
      if (day < 1 || day > 30) {
        return "Please enter a valid day";
      }
    }
  } else {
    if (month % 2 === 0) {
      if (day < 1 || day > 30) {
        return "Please enter a valid day";
      } else {
        if (day < 1 || day > 31) {
          return "Please enter a valid day";
        }
      }
    }
  }
  return "valid";
}

export function toReversed<T>(arr: T[]) {
  return [...arr].reverse();
}

export function formatRelativeDateShort(
  date: Date,
  { withSuffix }: { withSuffix?: boolean } = {},
) {
  const seconds = Math.floor((new Date().getTime() - date.getTime()) / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);
  const months = Math.floor(days / 30);
  const years = Math.floor(months / 12);

  const suffix = withSuffix ? " ago" : "";

  if (years > 0) return `${years}y${suffix}`;
  if (months > 0) return `${months}mo${suffix}`;
  if (days > 0) return `${days}d${suffix}`;
  if (hours > 0) return `${hours}h${suffix}`;
  if (minutes > 0) return `${minutes}m${suffix}`;
  return "now";
}
</code></pre>
</div>
<div class='file'>
<div class='file-name'>./src/utils/zod-utils.ts</div>
<pre><code>
import { parseISO } from "date-fns";
import { z, type ZodType } from "zod";

/**
 * Zod wasn't meant for forms, so these utilities make it a lot less weird to write
 * validators for react-hook-form (e.g. trim input, parse empty strings as undefined,
 * minimum length of 1 by default)
 *
 * this is also a place for schemas/pipelines that youre reusing (e.g. zodPassword, zodEmail, zodMMDDYYYY)
 *
 * Example usage:
 * const schema = z.object({
 *  name: zodString({ minLen: 3, maxLen: 50 }),
 *  email: zodEmail(),
 *  age: zodNumber({ min: 0, max: 120 }),
 *  birthday: optional(zodMMDDYYYY()),
 * });
 *
 */

/**
 * used for optional form fields (parses the empty string, whitespace, or `undefined` as `undefined`)
 */
export function optional<TZodType extends ZodType>(zodType: TZodType) {
  return zodType.optional().or(
    z
      .string()
      .trim()
      .pipe(z.literal("").transform(() => undefined)),
  );
}

export function zodString({ minLen = 0, maxLen = 255 } = {}) {
  return z
    .string()
    .trim()
    .min(1, { message: "Required" })
    .min(minLen, { message: `Must be ${minLen}+ characters` })
    .max(maxLen, { message: `Must be ${maxLen} characters or less` });
}

export function zodNumber({ min = -Infinity, max = Infinity } = {}) {
  return z
    .union([
      zodString()
        .transform((s) => +s)
        .refine((n) => !isNaN(n), { message: "Must be a number" }),
      z.number(),
    ])
    .refine((n) => n >= min && n <= max, {
      message:
        max === Infinity
          ? `Must be at least ${min}`
          : `Must be between ${min} and ${max}`,
    });
}

export function zodInteger({ min = -Infinity, max = Infinity } = {}) {
  return zodNumber({ min, max }).refine((n) => Number.isInteger(n), {
    message: "Must be an integer",
  });
}

export function zodUrl() {
  return zodString({ maxLen: Infinity }).url({
    message: "Must be a valid URL",
  });
}

export function zodMMDDYYYY() {
  return zodString()
    .refine((s) => /^\d{2}\/\d{2}\/\d{4}$/.test(s), {
      message: "Must be in MM/DD/YYYY format",
    })
    .refine(
      (s) => {
        const [month, day, year] = s.split("/").map((s) => +s) as [
          number,
          number,
          number,
        ];
        const date = new Date(year, month - 1, day);
        return (
          date.getFullYear() === year &&
          date.getMonth() === month - 1 &&
          date.getDate() === day
        );
      },
      { message: "Invalid date" },
    )
    .transform((s) => parseISO(s));
}

export function zodEmail() {
  return zodString()
    .email({ message: "Invalid email address" })
    .transform((s) => s.toLowerCase());
}

export function zodPassword() {
  return z
    .string()
    .min(8, { message: "Must be 8+ characters" })
    .max(32, { message: "Can't be longer than 32 characters" })
    .refine((value) => /[a-z]/.test(value), {
      message: "Must contain at least one lowercase letter",
    })
    .refine((value) => /[A-Z]/.test(value), {
      message: "Must contain at least one uppercase letter",
    })
    .refine((value) => /\d/.test(value), {
      message: "Must contain at least one digit",
    })
    .refine((value) => /[!@#$%^&*]/.test(value), {
      message: "Must contain at least one special character '!@#$%^&*'",
    });
}

export function zodPhone() {
  return z.string().refine(
    (value) => {
      // Remove non-digit characters and check if the length is 10 or 11
      const digitsOnly = value.replace(/\D/g, "");
      return digitsOnly.length === 10 || digitsOnly.length === 11;
    },
    {
      message: "Invalid phone number format",
    },
  );
}

export const zodTime = z
  .string()
  .regex(
    /^(?:(?:[01]\d|2[0-3]):([0-5]\d))|(?:(0?[1-9]|1[0-2]):([0-5]\d)\s?(?:AM|PM))$/i,
    "Invalid time format",
  );

export function formatZodError(error: z.ZodError<unknown>) {
  return JSON.stringify(
    error.issues.map((issue) => ({
      path: issue.path.join("."),
      message: issue.message,
    })),
    null,
    2,
  );
}
</code></pre>
</div>
</div></body></html>
